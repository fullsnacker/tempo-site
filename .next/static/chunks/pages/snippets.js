/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/snippets"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fopt%2Fprojects%2Fblog%2Fpages%2Fsnippets%2Findex.tsx&page=%2Fsnippets!":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fopt%2Fprojects%2Fblog%2Fpages%2Fsnippets%2Findex.tsx&page=%2Fsnippets! ***!
  \*****************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/snippets\",\n      function () {\n        return __webpack_require__(/*! ./pages/snippets/index.tsx */ \"./pages/snippets/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/snippets\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZvcHQlMkZwcm9qZWN0cyUyRmJsb2clMkZwYWdlcyUyRnNuaXBwZXRzJTJGaW5kZXgudHN4JnBhZ2U9JTJGc25pcHBldHMhLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsOERBQTRCO0FBQ25EO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9jMDQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvc25pcHBldHNcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3BhZ2VzL3NuaXBwZXRzL2luZGV4LnRzeFwiKTtcbiAgICAgIH1cbiAgICBdKTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuX19ORVhUX1AucHVzaChbXCIvc25pcHBldHNcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fopt%2Fprojects%2Fblog%2Fpages%2Fsnippets%2Findex.tsx&page=%2Fsnippets!\n"));

/***/ }),

/***/ "./components/Banner.tsx":
/*!*******************************!*\
  !*** ./components/Banner.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Banner; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction Banner(param) {\n    let { title , description , illustration =\"default\"  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n        className: \"bg-gray-800 w-full rounded-2xl h-36 flex items-center gap-10 px-4\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-40 h-full relative\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                    src: \"/avatar-torso.png\",\n                    className: \"absolute bottom-0 left-1\",\n                    alt: \"\"\n                }, void 0, false, {\n                    fileName: \"/opt/projects/blog/components/Banner.tsx\",\n                    lineNumber: 11,\n                    columnNumber: 5\n                }, this)\n            }, void 0, false, {\n                fileName: \"/opt/projects/blog/components/Banner.tsx\",\n                lineNumber: 10,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col gap-1 text-white\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-3xl font-bold\",\n                        children: title\n                    }, void 0, false, {\n                        fileName: \"/opt/projects/blog/components/Banner.tsx\",\n                        lineNumber: 14,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-gray-300 font-medium \",\n                        children: description\n                    }, void 0, false, {\n                        fileName: \"/opt/projects/blog/components/Banner.tsx\",\n                        lineNumber: 15,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/opt/projects/blog/components/Banner.tsx\",\n                lineNumber: 13,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/opt/projects/blog/components/Banner.tsx\",\n        lineNumber: 9,\n        columnNumber: 3\n    }, this);\n}\n_c = Banner;\nvar _c;\n$RefreshReg$(_c, \"Banner\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Jhbm5lci50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQU1lLFNBQVNBLE9BQU8sS0FBdUQsRUFBRTtRQUF6RCxFQUFFQyxNQUFLLEVBQUVDLFlBQVcsRUFBRUMsY0FBZSxVQUFTLEVBQVMsR0FBdkQ7SUFDOUIscUJBQ0MsOERBQUNDO1FBQVFDLFdBQVU7OzBCQUNsQiw4REFBQ0M7Z0JBQUlELFdBQVU7MEJBQ2QsNEVBQUNFO29CQUFJQyxLQUFJO29CQUFvQkgsV0FBVTtvQkFBMkJJLEtBQUk7Ozs7Ozs7Ozs7OzBCQUV2RSw4REFBQ0g7Z0JBQUlELFdBQVU7O2tDQUNkLDhEQUFDSzt3QkFBR0wsV0FBVTtrQ0FBc0JKOzs7Ozs7a0NBQ3BDLDhEQUFDVTt3QkFBRU4sV0FBVTtrQ0FBOEJIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJL0MsQ0FBQztLQVp1QkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9CYW5uZXIudHN4P2FjNzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW50ZXJmYWNlIFByb3BzIHtcblx0dGl0bGU6IHN0cmluZ1xuXHRkZXNjcmlwdGlvbjogc3RyaW5nXG5cdGlsbHVzdHJhdGlvbj86ICdkZWZhdWx0JyB8ICdnbGFzc2VzJ1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCYW5uZXIoeyB0aXRsZSwgZGVzY3JpcHRpb24sIGlsbHVzdHJhdGlvbiA9ICdkZWZhdWx0JyB9OiBQcm9wcykge1xuXHRyZXR1cm4gKFxuXHRcdDxzZWN0aW9uIGNsYXNzTmFtZT0nYmctZ3JheS04MDAgdy1mdWxsIHJvdW5kZWQtMnhsIGgtMzYgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTEwIHB4LTQnPlxuXHRcdFx0PGRpdiBjbGFzc05hbWU9J3ctNDAgaC1mdWxsIHJlbGF0aXZlJz5cblx0XHRcdFx0PGltZyBzcmM9Jy9hdmF0YXItdG9yc28ucG5nJyBjbGFzc05hbWU9J2Fic29sdXRlIGJvdHRvbS0wIGxlZnQtMScgYWx0PScnIC8+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3NOYW1lPSdmbGV4IGZsZXgtY29sIGdhcC0xIHRleHQtd2hpdGUnPlxuXHRcdFx0XHQ8aDIgY2xhc3NOYW1lPSd0ZXh0LTN4bCBmb250LWJvbGQnPnt0aXRsZX08L2gyPlxuXHRcdFx0XHQ8cCBjbGFzc05hbWU9J3RleHQtZ3JheS0zMDAgZm9udC1tZWRpdW0gJz57ZGVzY3JpcHRpb259PC9wPlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9zZWN0aW9uPlxuXHQpXG59XG4iXSwibmFtZXMiOlsiQmFubmVyIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImlsbHVzdHJhdGlvbiIsInNlY3Rpb24iLCJjbGFzc05hbWUiLCJkaXYiLCJpbWciLCJzcmMiLCJhbHQiLCJoMiIsInAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Banner.tsx\n"));

/***/ }),

/***/ "./components/Collapsable.tsx":
/*!************************************!*\
  !*** ./components/Collapsable.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Collapsable; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction Collapsable(param) {\n    let { children , label , tag , open  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"details\", {\n        className: \"group\",\n        open: open,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"summary\", {\n                className: \"py-2.5 px-4 cursor-pointer rounded-md flex items-center justify-between hover:bg-gray-100 transition-all active:scale-[0.98] focus-visible:outline-none focus-visible:ring focus-visible:ring-blue-500 group-open:bg-gray-50 hover:group-open:bg-gray-100 hover:text-gray-900 group-open:text-gray-900\",\n                children: [\n                    label,\n                    tag && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"bg-gray-200 capitalize text-black font-medium text-xs rounded-full px-2.5 py-1\",\n                        children: tag\n                    }, void 0, false, {\n                        fileName: \"/opt/projects/blog/components/Collapsable.tsx\",\n                        lineNumber: 14,\n                        columnNumber: 6\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/opt/projects/blog/components/Collapsable.tsx\",\n                lineNumber: 11,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"px-4 -mt-2 rounded-md  group-open:mb-4\",\n                children: children\n            }, void 0, false, {\n                fileName: \"/opt/projects/blog/components/Collapsable.tsx\",\n                lineNumber: 17,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/opt/projects/blog/components/Collapsable.tsx\",\n        lineNumber: 10,\n        columnNumber: 3\n    }, this);\n}\n_c = Collapsable;\nvar _c;\n$RefreshReg$(_c, \"Collapsable\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0NvbGxhcHNhYmxlLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBT2UsU0FBU0EsWUFBWSxLQUFxQyxFQUFFO1FBQXZDLEVBQUVDLFNBQVEsRUFBRUMsTUFBSyxFQUFFQyxJQUFHLEVBQUVDLEtBQUksRUFBUyxHQUFyQztJQUNuQyxxQkFDQyw4REFBQ0M7UUFBUUMsV0FBVTtRQUFRRixNQUFNQTs7MEJBQ2hDLDhEQUFDRztnQkFBUUQsV0FBVTs7b0JBQ2pCSjtvQkFDQUMscUJBQ0EsOERBQUNLO3dCQUFLRixXQUFVO2tDQUFrRkg7Ozs7Ozs7Ozs7OzswQkFHcEcsOERBQUNNO2dCQUFJSCxXQUFVOzBCQUEwQ0w7Ozs7Ozs7Ozs7OztBQUc1RCxDQUFDO0tBWnVCRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0NvbGxhcHNhYmxlLnRzeD85N2I5Il0sInNvdXJjZXNDb250ZW50IjpbImludGVyZmFjZSBQcm9wcyB7XG5cdGxhYmVsOiBzdHJpbmdcblx0Y2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuXHR0YWc/OiBzdHJpbmdcblx0b3Blbj86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29sbGFwc2FibGUoeyBjaGlsZHJlbiwgbGFiZWwsIHRhZywgb3BlbiB9OiBQcm9wcykge1xuXHRyZXR1cm4gKFxuXHRcdDxkZXRhaWxzIGNsYXNzTmFtZT0nZ3JvdXAnIG9wZW49e29wZW59PlxuXHRcdFx0PHN1bW1hcnkgY2xhc3NOYW1lPSdweS0yLjUgcHgtNCBjdXJzb3ItcG9pbnRlciByb3VuZGVkLW1kIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBob3ZlcjpiZy1ncmF5LTEwMCB0cmFuc2l0aW9uLWFsbCBhY3RpdmU6c2NhbGUtWzAuOThdIGZvY3VzLXZpc2libGU6b3V0bGluZS1ub25lIGZvY3VzLXZpc2libGU6cmluZyBmb2N1cy12aXNpYmxlOnJpbmctYmx1ZS01MDAgZ3JvdXAtb3BlbjpiZy1ncmF5LTUwIGhvdmVyOmdyb3VwLW9wZW46YmctZ3JheS0xMDAgaG92ZXI6dGV4dC1ncmF5LTkwMCBncm91cC1vcGVuOnRleHQtZ3JheS05MDAnPlxuXHRcdFx0XHR7bGFiZWx9XG5cdFx0XHRcdHt0YWcgJiYgKFxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT0nYmctZ3JheS0yMDAgY2FwaXRhbGl6ZSB0ZXh0LWJsYWNrIGZvbnQtbWVkaXVtIHRleHQteHMgcm91bmRlZC1mdWxsIHB4LTIuNSBweS0xJz57dGFnfTwvc3Bhbj5cblx0XHRcdFx0KX1cblx0XHRcdDwvc3VtbWFyeT5cblx0XHRcdDxkaXYgY2xhc3NOYW1lPSdweC00IC1tdC0yIHJvdW5kZWQtbWQgIGdyb3VwLW9wZW46bWItNCc+e2NoaWxkcmVufTwvZGl2PlxuXHRcdDwvZGV0YWlscz5cblx0KVxufVxuIl0sIm5hbWVzIjpbIkNvbGxhcHNhYmxlIiwiY2hpbGRyZW4iLCJsYWJlbCIsInRhZyIsIm9wZW4iLCJkZXRhaWxzIiwiY2xhc3NOYW1lIiwic3VtbWFyeSIsInNwYW4iLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Collapsable.tsx\n"));

/***/ }),

/***/ "./components/Header.tsx":
/*!*******************************!*\
  !*** ./components/Header.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Header; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @utils/config */ \"./utils/config.ts\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_3__);\n\nvar _s = $RefreshSig$();\n\n\n\nfunction Header() {\n    _s();\n    const { pathname  } = (0,next_router__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const isInPath = (path)=>pathname === path;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n        className: \"flex justify-between items-center gap-4 py-4 bg-white bg-opacity-60 backdrop-blur-md  \",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_3___default()), {\n                href: \"/about\",\n                className: \"rounded-md bg-white text-gray-800 py-2 px-3 font-semibold active:scale-95 transition-all whitespace-nowrap\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                    src: \"/avatar.png\",\n                    alt: \"icon\",\n                    className: \"w-10 h-10\"\n                }, void 0, false, {\n                    fileName: \"/opt/projects/blog/components/Header.tsx\",\n                    lineNumber: 17,\n                    columnNumber: 4\n                }, this)\n            }, void 0, false, {\n                fileName: \"/opt/projects/blog/components/Header.tsx\",\n                lineNumber: 13,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n                className: \" flex gap-4\",\n                children: _utils_config__WEBPACK_IMPORTED_MODULE_1__.HEADER_LINKS.map((link, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_3___default()), {\n                        href: link.path,\n                        className: \"px-3 py-2 capitalize font-medium hover:bg-gray-100 rounded-lg hover:text-black transition-all active:scale-95 \".concat(isInPath(link.path) ? \"bg-gray-100 text-gray-900\" : \"text-gray-500\"),\n                        children: link.name\n                    }, link.name + index, false, {\n                        fileName: \"/opt/projects/blog/components/Header.tsx\",\n                        lineNumber: 21,\n                        columnNumber: 6\n                    }, this))\n            }, void 0, false, {\n                fileName: \"/opt/projects/blog/components/Header.tsx\",\n                lineNumber: 19,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex gap-1\"\n            }, void 0, false, {\n                fileName: \"/opt/projects/blog/components/Header.tsx\",\n                lineNumber: 39,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/opt/projects/blog/components/Header.tsx\",\n        lineNumber: 12,\n        columnNumber: 3\n    }, this);\n}\n_s(Header, \"QpP2vYJstxsDz0K+Qwttl8PPVoY=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = Header;\nvar _c;\n$RefreshReg$(_c, \"Header\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0hlYWRlci50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE0QztBQUNMO0FBQ1g7QUFJYixTQUFTRyxTQUFTOztJQUNoQyxNQUFNLEVBQUVDLFNBQVEsRUFBRSxHQUFHSCxzREFBU0E7SUFDOUIsTUFBTUksV0FBVyxDQUFDQyxPQUFpQkYsYUFBYUU7SUFFaEQscUJBQ0MsOERBQUNDO1FBQU9DLFdBQVU7OzBCQUNqQiw4REFBQ04sa0RBQUlBO2dCQUNKTyxNQUFLO2dCQUNMRCxXQUFVOzBCQUVYLDRFQUFDRTtvQkFBSUMsS0FBSTtvQkFBY0MsS0FBSTtvQkFBT0osV0FBVTs7Ozs7Ozs7Ozs7MEJBRTVDLDhEQUFDSztnQkFBSUwsV0FBVTswQkFDYlIsMkRBQWdCLENBQUMsQ0FBQ2UsTUFBTUMsc0JBQ3hCLDhEQUFDZCxrREFBSUE7d0JBRUpPLE1BQU1NLEtBQUtULElBQUk7d0JBQ2ZFLFdBQVcsaUhBRVYsT0FEQUgsU0FBU1UsS0FBS1QsSUFBSSxJQUFJLDhCQUE4QixlQUFlO2tDQUduRVMsS0FBS0UsSUFBSTt1QkFOTEYsS0FBS0UsSUFBSSxHQUFHRDs7Ozs7Ozs7OzswQkFpQnBCLDhEQUFDRTtnQkFBSVYsV0FBVTs7Ozs7Ozs7Ozs7O0FBR2xCLENBQUM7R0FuQ3VCTDs7UUFDRkYsa0RBQVNBOzs7S0FEUEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9IZWFkZXIudHN4PzAzNjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSEVBREVSX0xJTktTIH0gZnJvbSAnQHV0aWxzL2NvbmZpZydcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvcm91dGVyJ1xuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJ1xuaW1wb3J0IHsgRmFGb2xkZXIsIEZhR2l0aHViLCBGYUxpbmsgfSBmcm9tIFwicmVhY3QtaWNvbnMvZmFcIjtcbmltcG9ydCB7IEljb25Db250ZXh0IH0gZnJvbSBcInJlYWN0LWljb25zXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhlYWRlcigpIHtcblx0Y29uc3QgeyBwYXRobmFtZSB9ID0gdXNlUm91dGVyKClcblx0Y29uc3QgaXNJblBhdGggPSAocGF0aDogc3RyaW5nKSA9PiBwYXRobmFtZSA9PT0gcGF0aFxuXG5cdHJldHVybiAoXG5cdFx0PGhlYWRlciBjbGFzc05hbWU9J2ZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlciBnYXAtNCBweS00IGJnLXdoaXRlIGJnLW9wYWNpdHktNjAgYmFja2Ryb3AtYmx1ci1tZCAgJz5cblx0XHRcdDxMaW5rXG5cdFx0XHRcdGhyZWY9Jy9hYm91dCdcblx0XHRcdFx0Y2xhc3NOYW1lPSdyb3VuZGVkLW1kIGJnLXdoaXRlIHRleHQtZ3JheS04MDAgcHktMiBweC0zIGZvbnQtc2VtaWJvbGQgYWN0aXZlOnNjYWxlLTk1IHRyYW5zaXRpb24tYWxsIHdoaXRlc3BhY2Utbm93cmFwJ1xuXHRcdFx0PlxuXHRcdFx0PGltZyBzcmM9Jy9hdmF0YXIucG5nJyBhbHQ9J2ljb24nIGNsYXNzTmFtZT0ndy0xMCBoLTEwJyAvPlxuXHRcdFx0PC9MaW5rPlxuXHRcdFx0PG5hdiBjbGFzc05hbWU9JyBmbGV4IGdhcC00Jz5cblx0XHRcdFx0e0hFQURFUl9MSU5LUy5tYXAoKGxpbmssIGluZGV4KSA9PiAoXG5cdFx0XHRcdFx0PExpbmtcblx0XHRcdFx0XHRcdGtleT17bGluay5uYW1lICsgaW5kZXh9XG5cdFx0XHRcdFx0XHRocmVmPXtsaW5rLnBhdGh9XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9e2BweC0zIHB5LTIgY2FwaXRhbGl6ZSBmb250LW1lZGl1bSBob3ZlcjpiZy1ncmF5LTEwMCByb3VuZGVkLWxnIGhvdmVyOnRleHQtYmxhY2sgdHJhbnNpdGlvbi1hbGwgYWN0aXZlOnNjYWxlLTk1ICR7XG5cdFx0XHRcdFx0XHRcdGlzSW5QYXRoKGxpbmsucGF0aCkgPyAnYmctZ3JheS0xMDAgdGV4dC1ncmF5LTkwMCcgOiAndGV4dC1ncmF5LTUwMCdcblx0XHRcdFx0XHRcdH1gfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHtsaW5rLm5hbWV9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHsvKiA8SWNvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3sgc2l6ZTogXCIxLjVlbVwifX0+XG5cdFx0XHRcdFx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHRcdFx0XHRcdDxGYUdpdGh1YiAvPlxuXHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdDwvSWNvbkNvbnRleHQuUHJvdmlkZXI+ICovfVxuXHRcdFx0XHRcdDwvTGluaz5cblx0XHRcdFx0KSl9XG5cdFx0XHQ8L25hdj5cblxuXHRcdFx0PGRpdiBjbGFzc05hbWU9J2ZsZXggZ2FwLTEnPjwvZGl2PlxuXHRcdDwvaGVhZGVyPlxuXHQpXG59XG4iXSwibmFtZXMiOlsiSEVBREVSX0xJTktTIiwidXNlUm91dGVyIiwiTGluayIsIkhlYWRlciIsInBhdGhuYW1lIiwiaXNJblBhdGgiLCJwYXRoIiwiaGVhZGVyIiwiY2xhc3NOYW1lIiwiaHJlZiIsImltZyIsInNyYyIsImFsdCIsIm5hdiIsIm1hcCIsImxpbmsiLCJpbmRleCIsIm5hbWUiLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Header.tsx\n"));

/***/ }),

/***/ "./layouts/Page.tsx":
/*!**************************!*\
  !*** ./layouts/Page.tsx ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Page; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @components/Header */ \"./components/Header.tsx\");\n\n\nfunction Page(param) {\n    let { title , description , children , footer , hideHeader  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"max-w-screen-lg mx-auto grid gap-4 pb-32 px-14\",\n        children: [\n            !hideHeader && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Header__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n                fileName: \"/opt/projects/blog/layouts/Page.tsx\",\n                lineNumber: 15,\n                columnNumber: 20\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                className: \"pt-10 grid gap-4\",\n                children: children\n            }, void 0, false, {\n                fileName: \"/opt/projects/blog/layouts/Page.tsx\",\n                lineNumber: 16,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/opt/projects/blog/layouts/Page.tsx\",\n        lineNumber: 14,\n        columnNumber: 3\n    }, this);\n}\n_c = Page;\nvar _c;\n$RefreshReg$(_c, \"Page\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYXlvdXRzL1BhZ2UudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ3VDO0FBVXhCLFNBQVNDLEtBQUssS0FBMkQsRUFBRTtRQUE3RCxFQUFFQyxNQUFLLEVBQUVDLFlBQVcsRUFBRUMsU0FBUSxFQUFFQyxPQUFNLEVBQUVDLFdBQVUsRUFBUyxHQUEzRDtJQUM1QixxQkFDQyw4REFBQ0M7UUFBSUMsV0FBVTs7WUFDYixDQUFDRiw0QkFBYyw4REFBQ04sMERBQU1BOzs7OzswQkFDdkIsOERBQUNTO2dCQUFLRCxXQUFVOzBCQUFvQko7Ozs7Ozs7Ozs7OztBQUd2QyxDQUFDO0tBUHVCSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9sYXlvdXRzL1BhZ2UudHN4PzEzYTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEhlYWQgZnJvbSAnbmV4dC9oZWFkJ1xuaW1wb3J0IEhlYWRlciBmcm9tICdAY29tcG9uZW50cy9IZWFkZXInXG5cbmludGVyZmFjZSBQcm9wcyB7XG5cdHRpdGxlOiBzdHJpbmdcblx0ZGVzY3JpcHRpb246IHN0cmluZ1xuXHRjaGlsZHJlbjogSlNYLkVsZW1lbnQgfCBKU1guRWxlbWVudFtdXG5cdGZvb3Rlcj86IGJvb2xlYW5cblx0aGlkZUhlYWRlcj86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGFnZSh7IHRpdGxlLCBkZXNjcmlwdGlvbiwgY2hpbGRyZW4sIGZvb3RlciwgaGlkZUhlYWRlciB9OiBQcm9wcykge1xuXHRyZXR1cm4gKFxuXHRcdDxkaXYgY2xhc3NOYW1lPSdtYXgtdy1zY3JlZW4tbGcgbXgtYXV0byBncmlkIGdhcC00IHBiLTMyIHB4LTE0Jz5cblx0XHRcdHshaGlkZUhlYWRlciAmJiA8SGVhZGVyIC8+fVxuXHRcdFx0PG1haW4gY2xhc3NOYW1lPSdwdC0xMCBncmlkIGdhcC00Jz57Y2hpbGRyZW59PC9tYWluPlxuXHRcdDwvZGl2PlxuXHQpXG59XG4iXSwibmFtZXMiOlsiSGVhZGVyIiwiUGFnZSIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJjaGlsZHJlbiIsImZvb3RlciIsImhpZGVIZWFkZXIiLCJkaXYiLCJjbGFzc05hbWUiLCJtYWluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./layouts/Page.tsx\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGSCxtREFBa0Q7SUFDOUNJLFlBQVksSUFBSTtJQUNoQkMsS0FBSyxXQUFXO1FBQ1osT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLFdBQVdDLE1BQWtDLElBQUk7QUFDdkQsU0FBU0YsZ0JBQWdCSyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxhQUFhLEVBQUU7SUFDM0QsSUFBSU4sS0FBK0IsRUFBRSxFQVdwQyxNQUFNO1FBQ0gsT0FBTyxLQUFLO0lBQ2hCLENBQUM7QUFDTDtBQUVBLElBQUksQ0FBQyxPQUFPTixRQUFReUIsT0FBTyxLQUFLLGNBQWUsT0FBT3pCLFFBQVF5QixPQUFPLEtBQUssWUFBWXpCLFFBQVF5QixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU96QixRQUFReUIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzVCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUXlCLE9BQU8sRUFBRSxjQUFjO1FBQUV4QixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTzZCLE1BQU0sQ0FBQzNCLFFBQVF5QixPQUFPLEVBQUV6QjtJQUMvQjRCLE9BQU81QixPQUFPLEdBQUdBLFFBQVF5QixPQUFPO0FBQ2xDLENBQUMsQ0FFRCw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZ2V0LWRvbWFpbi1sb2NhbGUuanM/NWMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERvbWFpbkxvY2FsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0RG9tYWluTG9jYWxlO1xuICAgIH1cbn0pO1xuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpLm5vcm1hbGl6ZUxvY2FsZVBhdGg7XG4gICAgICAgIGNvbnN0IGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoJy4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKS5kZXRlY3REb21haW5Mb2NhbGU7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGxvY2FsZSB8fCBub3JtYWxpemVMb2NhbGVQYXRoKHBhdGgsIGxvY2FsZXMpLmRldGVjdGVkTG9jYWxlO1xuICAgICAgICBjb25zdCBkb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCB0YXJnZXQpO1xuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICBjb25zdCBwcm90byA9IGBodHRwJHtkb21haW4uaHR0cCA/ICcnIDogJ3MnfTovL2A7XG4gICAgICAgICAgICBjb25zdCBmaW5hbExvY2FsZSA9IHRhcmdldCA9PT0gZG9tYWluLmRlZmF1bHRMb2NhbGUgPyAnJyA6IGAvJHt0YXJnZXR9YDtcbiAgICAgICAgICAgIHJldHVybiBgJHtwcm90b30ke2RvbWFpbi5kb21haW59JHtiYXNlUGF0aH0ke2ZpbmFsTG9jYWxlfSR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtZG9tYWluLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0RG9tYWluTG9jYWxlIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicmVxdWlyZSIsImRldGVjdERvbWFpbkxvY2FsZSIsInRhcmdldCIsImRldGVjdGVkTG9jYWxlIiwiZG9tYWluIiwidW5kZWZpbmVkIiwicHJvdG8iLCJodHRwIiwiZmluYWxMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use client\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _extends = __webpack_require__(/*! @swc/helpers/_/_extends */ \"./node_modules/@swc/helpers/esm/_extends.js\");\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _object_without_properties_loose = __webpack_require__(/*! @swc/helpers/_/_object_without_properties_loose */ \"./node_modules/@swc/helpers/esm/_object_without_properties_loose.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst _resolvehref = __webpack_require__(/*! ../shared/lib/router/utils/resolve-href */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nconst _routercontext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nconst _approutercontext = __webpack_require__(/*! ../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\nconst _useintersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\nconst _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"./node_modules/next/dist/client/get-domain-locale.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, isAppRouter) {\n    if (false) {}\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(router.prefetch(href, as, options)).catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled) {\n    const { nodeName  } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browsers default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                forceOptimisticNavigation: !prefetchEnabled\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * React Component that enables client-side transitions between routes.\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\".concat(args.key, \"` expects a \").concat(args.expected, \" in `<Link>`, but got `\").concat(args.actual, \"` instead.\") + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    let children;\n    const { href: hrefProp , as: asProp , children: childrenProp , prefetch: prefetchProp , passHref , replace , shallow , scroll , locale , onClick , onMouseEnter: onMouseEnterProp , onTouchStart: onTouchStartProp , legacyBehavior =true === false  } = props, restProps = _object_without_properties_loose._(props, [\n        \"href\",\n        \"as\",\n        \"children\",\n        \"prefetch\",\n        \"passHref\",\n        \"replace\",\n        \"shallow\",\n        \"scroll\",\n        \"locale\",\n        \"onClick\",\n        \"onMouseEnter\",\n        \"onTouchStart\",\n        \"legacyBehavior\"\n    ]);\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ _react.default.createElement(\"a\", null, children);\n    }\n    const prefetchEnabled = prefetchProp !== false;\n    const pagesRouter = _react.default.useContext(_routercontext.RouterContext);\n    const appRouter = _react.default.useContext(_approutercontext.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\".concat(href, \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\"));\n                }\n            }\n        }\n    }\n    const { href , as  } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link'));\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link'));\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but one child is required https://nextjs.org/docs/messages/link-no-children\"));\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\") + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, isAppRouter);\n        },\n        onTouchStart (e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ _react.default.createElement(\"a\", _extends._({}, restProps, childProps), children);\n}, \"iGdYZW22TllPihoUFJYL0qIKigo=\")), \"iGdYZW22TllPihoUFJYL0qIKigo=\");\n_c1 = Link;\nconst _default = Link;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUNhOztBQURiO0FBRUFBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsV0FBV0MsbUJBQU9BLENBQUMsNEVBQXlCO0FBQ2xELE1BQU1DLDJCQUEyQkQsbUJBQU9BLENBQUMsNEdBQXlDO0FBQ2xGLE1BQU1FLG1DQUFtQ0YsbUJBQU9BLENBQUMsNEhBQWlEO0FBQ2xHLE1BQU1HLFNBQVMsV0FBVyxHQUFHRix5QkFBeUJHLENBQUMsQ0FBQ0osbUJBQU9BLENBQUMsNENBQU87QUFDdkUsTUFBTUssZUFBZUwsbUJBQU9BLENBQUMsaUhBQXlDO0FBQ3RFLE1BQU1NLGNBQWNOLG1CQUFPQSxDQUFDLGlIQUF5QztBQUNyRSxNQUFNTyxhQUFhUCxtQkFBT0EsQ0FBQyw2R0FBdUM7QUFDbEUsTUFBTVEsU0FBU1IsbUJBQU9BLENBQUMseUVBQXFCO0FBQzVDLE1BQU1TLGFBQWFULG1CQUFPQSxDQUFDLG1FQUFjO0FBQ3pDLE1BQU1VLGlCQUFpQlYsbUJBQU9BLENBQUMsMkZBQThCO0FBQzdELE1BQU1XLG9CQUFvQlgsbUJBQU9BLENBQUMsbUdBQWtDO0FBQ3BFLE1BQU1ZLG1CQUFtQlosbUJBQU9BLENBQUMsK0VBQW9CO0FBQ3JELE1BQU1hLG1CQUFtQmIsbUJBQU9BLENBQUMsaUZBQXFCO0FBQ3RELE1BQU1jLGVBQWVkLG1CQUFPQSxDQUFDLHlFQUFpQjtBQUU5QyxNQUFNZSxhQUFhLElBQUlDO0FBQ3ZCLFNBQVNDLFNBQVNDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLE9BQU8sRUFBRUMsV0FBVyxFQUFFO0lBQ3RELElBQUksS0FBa0IsRUFBYSxFQUVsQztJQUNELGdKQUFn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LFdBQVdyQyxlQUFlLElBQUksR0FBRyxLQUFLLElBQUlBLFlBQVk2QyxhQUFhO0lBQ3JLLENBQUM7SUFDRCxPQUFPaEUsaUJBQWlCLFdBQVcsR0FBR2pGLE9BQU93RCxPQUFPLENBQUMwRixZQUFZLENBQUM1QixPQUFPZSxjQUFjLFdBQVcsR0FBR3JJLE9BQU93RCxPQUFPLENBQUMyQyxhQUFhLENBQUMsS0FBS3ZHLFNBQVNLLENBQUMsQ0FBQyxDQUFDLEdBQUdpRyxXQUFXbUMsYUFBYTVDLFNBQVM7QUFDM0w7O0FBQ0EsTUFBTTlGLFdBQVdrRTtBQUVqQixJQUFJLENBQUMsT0FBT3RFLFFBQVFpRSxPQUFPLEtBQUssY0FBZSxPQUFPakUsUUFBUWlFLE9BQU8sS0FBSyxZQUFZakUsUUFBUWlFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2pFLFFBQVFpRSxPQUFPLENBQUMyRixVQUFVLEtBQUssYUFBYTtJQUNySzlKLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWlFLE9BQU8sRUFBRSxjQUFjO1FBQUVoRSxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTytKLE1BQU0sQ0FBQzdKLFFBQVFpRSxPQUFPLEVBQUVqRTtJQUMvQjhKLE9BQU85SixPQUFPLEdBQUdBLFFBQVFpRSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvbGluay5qcz9lNGY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdDtcbiAgICB9XG59KTtcbmNvbnN0IF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19leHRlbmRzXCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX3Jlc29sdmVocmVmID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3Jlc29sdmUtaHJlZlwiKTtcbmNvbnN0IF9pc2xvY2FsdXJsID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybFwiKTtcbmNvbnN0IF9mb3JtYXR1cmwgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybFwiKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xuY29uc3QgX2FkZGxvY2FsZSA9IHJlcXVpcmUoXCIuL2FkZC1sb2NhbGVcIik7XG5jb25zdCBfcm91dGVyY29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0XCIpO1xuY29uc3QgX2FwcHJvdXRlcmNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG5jb25zdCBfdXNlaW50ZXJzZWN0aW9uID0gcmVxdWlyZShcIi4vdXNlLWludGVyc2VjdGlvblwiKTtcbmNvbnN0IF9nZXRkb21haW5sb2NhbGUgPSByZXF1aXJlKFwiLi9nZXQtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9hZGRiYXNlcGF0aCA9IHJlcXVpcmUoXCIuL2FkZC1iYXNlLXBhdGhcIik7XG5cbmNvbnN0IHByZWZldGNoZWQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCBvcHRpb25zLCBpc0FwcFJvdXRlcikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFwcC1yb3V0ZXIgc3VwcG9ydHMgZXh0ZXJuYWwgdXJscyBvdXQgb2YgdGhlIGJveCBzbyBpdCBzaG91bGRuJ3Qgc2hvcnQtY2lyY3VpdCBoZXJlIGFzIHN1cHBvcnQgZm9yIGUuZy4gYHJlcGxhY2VgIGlzIGFkZGVkIGluIHRoZSBhcHAtcm91dGVyLlxuICAgIGlmICghaXNBcHBSb3V0ZXIgJiYgISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKShocmVmKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdlIHNob3VsZCBvbmx5IGRlZHVwZSByZXF1ZXN0cyB3aGVuIGV4cGVyaW1lbnRhbC5vcHRpbWlzdGljQ2xpZW50Q2FjaGUgaXNcbiAgICAvLyBkaXNhYmxlZC5cbiAgICBpZiAoIW9wdGlvbnMuYnlwYXNzUHJlZmV0Y2hlZENoZWNrKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IC8vIExldCB0aGUgbGluaydzIGxvY2FsZSBwcm9wIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHJvdXRlciBsb2NhbGUuXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmxvY2FsZSA6ICdsb2NhbGUnIGluIHJvdXRlciA/IHJvdXRlci5sb2NhbGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHByZWZldGNoZWRLZXkgPSBocmVmICsgJyUnICsgYXMgKyAnJScgKyBsb2NhbGU7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZmV0Y2hlZCB0aGUga2V5LCB0aGVuIGRvbid0IHByZWZldGNoIGl0IGFnYWluIVxuICAgICAgICBpZiAocHJlZmV0Y2hlZC5oYXMocHJlZmV0Y2hlZEtleSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXJrIHRoaXMgVVJMIGFzIHByZWZldGNoZWQuXG4gICAgICAgIHByZWZldGNoZWQuYWRkKHByZWZldGNoZWRLZXkpO1xuICAgIH1cbiAgICAvLyBQcmVmZXRjaCB0aGUgSlNPTiBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAgIC8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICAgIFByb21pc2UucmVzb2x2ZShyb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBldmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcbiAgICByZXR1cm4gdGFyZ2V0ICYmIHRhcmdldCAhPT0gJ19zZWxmJyB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IC8vIHRyaWdnZXJzIHJlc291cmNlIGRvd25sb2FkXG4gICAgZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDI7XG59XG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSwgaXNBcHBSb3V0ZXIsIHByZWZldGNoRW5hYmxlZCkge1xuICAgIGNvbnN0IHsgbm9kZU5hbWUgIH0gPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgLy8gYW5jaG9ycyBpbnNpZGUgYW4gc3ZnIGhhdmUgYSBsb3dlcmNhc2Ugbm9kZU5hbWVcbiAgICBjb25zdCBpc0FuY2hvck5vZGVOYW1lID0gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0EnO1xuICAgIGlmIChpc0FuY2hvck5vZGVOYW1lICYmIChpc01vZGlmaWVkRXZlbnQoZSkgfHwgLy8gYXBwLXJvdXRlciBzdXBwb3J0cyBleHRlcm5hbCB1cmxzIG91dCBvZiB0aGUgYm94IHNvIGl0IHNob3VsZG4ndCBzaG9ydC1jaXJjdWl0IGhlcmUgYXMgc3VwcG9ydCBmb3IgZS5nLiBgcmVwbGFjZWAgaXMgYWRkZWQgaW4gdGhlIGFwcC1yb3V0ZXIuXG4gICAgIWlzQXBwUm91dGVyICYmICEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoaHJlZikpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBuYXZpZ2F0ZSA9ICgpPT57XG4gICAgICAgIC8vIElmIHRoZSByb3V0ZXIgaXMgYW4gTmV4dFJvdXRlciBpbnN0YW5jZSBpdCB3aWxsIGhhdmUgYGJlZm9yZVBvcFN0YXRlYFxuICAgICAgICBpZiAoJ2JlZm9yZVBvcFN0YXRlJyBpbiByb3V0ZXIpIHtcbiAgICAgICAgICAgIHJvdXRlcltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ3B1c2gnXShocmVmLCBhcywge1xuICAgICAgICAgICAgICAgIHNoYWxsb3csXG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHNjcm9sbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb3V0ZXJbcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10oYXMgfHwgaHJlZiwge1xuICAgICAgICAgICAgICAgIGZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb246ICFwcmVmZXRjaEVuYWJsZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKG5hdmlnYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuYXZpZ2F0ZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdFN0cmluZ09yVXJsKHVybE9iak9yU3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB1cmxPYmpPclN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHVybE9iak9yU3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9mb3JtYXR1cmwuZm9ybWF0VXJsKSh1cmxPYmpPclN0cmluZyk7XG59XG4vKipcbiAqIFJlYWN0IENvbXBvbmVudCB0aGF0IGVuYWJsZXMgY2xpZW50LXNpZGUgdHJhbnNpdGlvbnMgYmV0d2VlbiByb3V0ZXMuXG4gKi8gY29uc3QgTGluayA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuZm9yd2FyZFJlZihmdW5jdGlvbiBMaW5rQ29tcG9uZW50KHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVQcm9wRXJyb3IoYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgRmFpbGVkIHByb3AgdHlwZTogVGhlIHByb3AgXFxgJHthcmdzLmtleX1cXGAgZXhwZWN0cyBhICR7YXJncy5leHBlY3RlZH0gaW4gXFxgPExpbms+XFxgLCBidXQgZ290IFxcYCR7YXJncy5hY3R1YWx9XFxgIGluc3RlYWQuYCArICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFwiXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIiA6ICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wc0d1YXJkID0ge1xuICAgICAgICAgICAgaHJlZjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXF1aXJlZFByb3BzID0gT2JqZWN0LmtleXMocmVxdWlyZWRQcm9wc0d1YXJkKTtcbiAgICAgICAgcmVxdWlyZWRQcm9wcy5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnaHJlZicpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wc1trZXldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBwcm9wc1trZXldID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHByb3BzW2tleV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBjb25zdCBfID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxQcm9wc0d1YXJkID0ge1xuICAgICAgICAgICAgYXM6IHRydWUsXG4gICAgICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICAgICAgc2Nyb2xsOiB0cnVlLFxuICAgICAgICAgICAgc2hhbGxvdzogdHJ1ZSxcbiAgICAgICAgICAgIHBhc3NIcmVmOiB0cnVlLFxuICAgICAgICAgICAgcHJlZmV0Y2g6IHRydWUsXG4gICAgICAgICAgICBsb2NhbGU6IHRydWUsXG4gICAgICAgICAgICBvbkNsaWNrOiB0cnVlLFxuICAgICAgICAgICAgb25Nb3VzZUVudGVyOiB0cnVlLFxuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiB0cnVlLFxuICAgICAgICAgICAgbGVnYWN5QmVoYXZpb3I6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxQcm9wcyA9IE9iamVjdC5rZXlzKG9wdGlvbmFsUHJvcHNHdWFyZCk7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgY29uc3QgdmFsVHlwZSA9IHR5cGVvZiBwcm9wc1trZXldO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2FzJykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdzdHJpbmcnICYmIHZhbFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2xvY2FsZScpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdvbkNsaWNrJyB8fCBrZXkgPT09ICdvbk1vdXNlRW50ZXInIHx8IGtleSA9PT0gJ29uVG91Y2hTdGFydCcpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2BmdW5jdGlvbmAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncmVwbGFjZScgfHwga2V5ID09PSAnc2Nyb2xsJyB8fCBrZXkgPT09ICdzaGFsbG93JyB8fCBrZXkgPT09ICdwYXNzSHJlZicgfHwga2V5ID09PSAncHJlZmV0Y2gnIHx8IGtleSA9PT0gJ2xlZ2FjeUJlaGF2aW9yJykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICE9IG51bGwgJiYgdmFsVHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2Bib29sZWFuYCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBjb25zdCBfID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIGNvbnN0IGhhc1dhcm5lZCA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihmYWxzZSk7XG4gICAgICAgIGlmIChwcm9wcy5wcmVmZXRjaCAmJiAhaGFzV2FybmVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTmV4dC5qcyBhdXRvLXByZWZldGNoZXMgYXV0b21hdGljYWxseSBiYXNlZCBvbiB2aWV3cG9ydC4gVGhlIHByZWZldGNoIGF0dHJpYnV0ZSBpcyBubyBsb25nZXIgbmVlZGVkLiBNb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wcmVmZXRjaC10cnVlLWRlcHJlY2F0ZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY2hpbGRyZW47XG4gICAgY29uc3QgeyBocmVmOiBocmVmUHJvcCAsIGFzOiBhc1Byb3AgLCBjaGlsZHJlbjogY2hpbGRyZW5Qcm9wICwgcHJlZmV0Y2g6IHByZWZldGNoUHJvcCAsIHBhc3NIcmVmICwgcmVwbGFjZSAsIHNoYWxsb3cgLCBzY3JvbGwgLCBsb2NhbGUgLCBvbkNsaWNrICwgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXJQcm9wICwgb25Ub3VjaFN0YXJ0OiBvblRvdWNoU3RhcnRQcm9wICwgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIGlubGluZWQgYXMgYSBsaXRlcmFsIGJvb2xlYW4gbm90IGEgc3RyaW5nXG4gICAgbGVnYWN5QmVoYXZpb3IgPXByb2Nlc3MuZW52Ll9fTkVYVF9ORVdfTElOS19CRUhBVklPUiA9PT0gZmFsc2UgIH0gPSBwcm9wcywgcmVzdFByb3BzID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UuXyhwcm9wcywgW1xuICAgICAgICBcImhyZWZcIixcbiAgICAgICAgXCJhc1wiLFxuICAgICAgICBcImNoaWxkcmVuXCIsXG4gICAgICAgIFwicHJlZmV0Y2hcIixcbiAgICAgICAgXCJwYXNzSHJlZlwiLFxuICAgICAgICBcInJlcGxhY2VcIixcbiAgICAgICAgXCJzaGFsbG93XCIsXG4gICAgICAgIFwic2Nyb2xsXCIsXG4gICAgICAgIFwibG9jYWxlXCIsXG4gICAgICAgIFwib25DbGlja1wiLFxuICAgICAgICBcIm9uTW91c2VFbnRlclwiLFxuICAgICAgICBcIm9uVG91Y2hTdGFydFwiLFxuICAgICAgICBcImxlZ2FjeUJlaGF2aW9yXCJcbiAgICBdKTtcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuUHJvcDtcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkcmVuID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgY29uc3QgcHJlZmV0Y2hFbmFibGVkID0gcHJlZmV0Y2hQcm9wICE9PSBmYWxzZTtcbiAgICBjb25zdCBwYWdlc1JvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX3JvdXRlcmNvbnRleHQuUm91dGVyQ29udGV4dCk7XG4gICAgY29uc3QgYXBwUm91dGVyID0gX3JlYWN0LmRlZmF1bHQudXNlQ29udGV4dChfYXBwcm91dGVyY29udGV4dC5BcHBSb3V0ZXJDb250ZXh0KTtcbiAgICBjb25zdCByb3V0ZXIgPSBwYWdlc1JvdXRlciAhPSBudWxsID8gcGFnZXNSb3V0ZXIgOiBhcHBSb3V0ZXI7XG4gICAgLy8gV2UncmUgaW4gdGhlIGFwcCBkaXJlY3RvcnkgaWYgdGhlcmUgaXMgbm8gcGFnZXMgcm91dGVyLlxuICAgIGNvbnN0IGlzQXBwUm91dGVyID0gIXBhZ2VzUm91dGVyO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChpc0FwcFJvdXRlciAmJiAhYXNQcm9wKSB7XG4gICAgICAgICAgICBsZXQgaHJlZjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaHJlZlByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaHJlZiA9IGhyZWZQcm9wO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaHJlZlByb3AgPT09ICdvYmplY3QnICYmIHR5cGVvZiBocmVmUHJvcC5wYXRobmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBocmVmID0gaHJlZlByb3AucGF0aG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0R5bmFtaWNTZWdtZW50ID0gaHJlZi5zcGxpdCgnLycpLnNvbWUoKHNlZ21lbnQpPT5zZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljU2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER5bmFtaWMgaHJlZiBcXGAke2hyZWZ9XFxgIGZvdW5kIGluIDxMaW5rPiB3aGlsZSB1c2luZyB0aGUgXFxgL2FwcFxcYCByb3V0ZXIsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9hcHAtZGlyLWR5bmFtaWMtaHJlZmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IGhyZWYgLCBhcyAgfSA9IF9yZWFjdC5kZWZhdWx0LnVzZU1lbW8oKCk9PntcbiAgICAgICAgaWYgKCFwYWdlc1JvdXRlcikge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZm9ybWF0U3RyaW5nT3JVcmwoaHJlZlByb3ApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICAgICAgYXM6IGFzUHJvcCA/IGZvcm1hdFN0cmluZ09yVXJsKGFzUHJvcCkgOiByZXNvbHZlZEhyZWZcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShwYWdlc1JvdXRlciwgaHJlZlByb3AsIHRydWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxuICAgICAgICAgICAgYXM6IGFzUHJvcCA/ICgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHBhZ2VzUm91dGVyLCBhc1Byb3ApIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWZcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHBhZ2VzUm91dGVyLFxuICAgICAgICBocmVmUHJvcCxcbiAgICAgICAgYXNQcm9wXG4gICAgXSk7XG4gICAgY29uc3QgcHJldmlvdXNIcmVmID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGhyZWYpO1xuICAgIGNvbnN0IHByZXZpb3VzQXMgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoYXMpO1xuICAgIC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNoaWxkLCBpZiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgIGxldCBjaGlsZDtcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgXCJvbkNsaWNrXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbkNsaWNrIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Nb3VzZUVudGVyUHJvcCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgXCJvbk1vdXNlRW50ZXJcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uTW91c2VFbnRlciBiZSBzZXQgb24gdGhlIGNoaWxkIG9mIG5leHQvbGlua2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IG9uZSBjaGlsZCBpcyByZXF1aXJlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW5vLWNoaWxkcmVuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgb25seSBvbmUgY2hpbGQgaXMgc3VwcG9ydGVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbXVsdGlwbGUtY2hpbGRyZW5gICsgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gXCIgXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIiA6ICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBpZiAoKGNoaWxkcmVuID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZHJlbi50eXBlKSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIDxMaW5rPiB3aXRoIDxhPiBjaGlsZC4gUGxlYXNlIHJlbW92ZSA8YT4gb3IgdXNlIDxMaW5rIGxlZ2FjeUJlaGF2aW9yPi5cXG5MZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLW5ldy1saW5rLXdpdGgtZXh0cmEtYW5jaG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hpbGRSZWYgPSBsZWdhY3lCZWhhdmlvciA/IGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiYgY2hpbGQucmVmIDogZm9yd2FyZGVkUmVmO1xuICAgIGNvbnN0IFtzZXRJbnRlcnNlY3Rpb25SZWYsIGlzVmlzaWJsZSwgcmVzZXRWaXNpYmxlXSA9ICgwLCBfdXNlaW50ZXJzZWN0aW9uLnVzZUludGVyc2VjdGlvbikoe1xuICAgICAgICByb290TWFyZ2luOiAnMjAwcHgnXG4gICAgfSk7XG4gICAgY29uc3Qgc2V0UmVmID0gX3JlYWN0LmRlZmF1bHQudXNlQ2FsbGJhY2soKGVsKT0+e1xuICAgICAgICAvLyBCZWZvcmUgdGhlIGxpbmsgZ2V0dGluZyBvYnNlcnZlZCwgY2hlY2sgaWYgdmlzaWJsZSBzdGF0ZSBuZWVkIHRvIGJlIHJlc2V0XG4gICAgICAgIGlmIChwcmV2aW91c0FzLmN1cnJlbnQgIT09IGFzIHx8IHByZXZpb3VzSHJlZi5jdXJyZW50ICE9PSBocmVmKSB7XG4gICAgICAgICAgICByZXNldFZpc2libGUoKTtcbiAgICAgICAgICAgIHByZXZpb3VzQXMuY3VycmVudCA9IGFzO1xuICAgICAgICAgICAgcHJldmlvdXNIcmVmLmN1cnJlbnQgPSBocmVmO1xuICAgICAgICB9XG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZihlbCk7XG4gICAgICAgIGlmIChjaGlsZFJlZikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gJ2Z1bmN0aW9uJykgY2hpbGRSZWYoZWwpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkUmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNoaWxkUmVmLmN1cnJlbnQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgYXMsXG4gICAgICAgIGNoaWxkUmVmLFxuICAgICAgICBocmVmLFxuICAgICAgICByZXNldFZpc2libGUsXG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZlxuICAgIF0pO1xuICAgIC8vIFByZWZldGNoIHRoZSBVUkwgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IGFuZCBpdCdzIHZpc2libGUuXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIC8vIGluIGRldiwgd2Ugb25seSBwcmVmZXRjaCBvbiBob3ZlciB0byBhdm9pZCB3YXN0aW5nIHJlc291cmNlcyBhcyB0aGUgcHJlZmV0Y2ggd2lsbCB0cmlnZ2VyIGNvbXBpbGluZyB0aGUgcGFnZS5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IG5lZWQgdG8gcHJlZmV0Y2ggdGhlIFVSTCwgZG9uJ3QgZG8gcHJlZmV0Y2guXG4gICAgICAgIGlmICghaXNWaXNpYmxlIHx8ICFwcmVmZXRjaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVmZXRjaCB0aGUgVVJMLlxuICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuICAgIH0sIFtcbiAgICAgICAgYXMsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIGlzVmlzaWJsZSxcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBwcmVmZXRjaEVuYWJsZWQsXG4gICAgICAgIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGUsXG4gICAgICAgIHJvdXRlcixcbiAgICAgICAgaXNBcHBSb3V0ZXJcbiAgICBdKTtcbiAgICBjb25zdCBjaGlsZFByb3BzID0ge1xuICAgICAgICByZWY6IHNldFJlZixcbiAgICAgICAgb25DbGljayAoZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgcmVuZGVyZWQgaW5zaWRlIG5leHQvbGluayBoYXMgdG8gcGFzcyBjbGljayBldmVudCB0byBcIm9uQ2xpY2tcIiBwcm9wLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBpc0FwcFJvdXRlciwgcHJlZmV0Y2hFbmFibGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUVudGVyIChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbk1vdXNlRW50ZXJQcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyUHJvcChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZWZldGNoRW5hYmxlZCAmJiBpc0FwcFJvdXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gQHNlZSB7aHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2Rpc2N1c3Npb25zLzQwMjY4P3NvcnQ9dG9wI2Rpc2N1c3Npb25jb21tZW50LTM1NzI2NDJ9XG4gICAgICAgICAgICAgICAgYnlwYXNzUHJlZmV0Y2hlZENoZWNrOiB0cnVlXG4gICAgICAgICAgICB9LCBpc0FwcFJvdXRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVG91Y2hTdGFydCAoZSkge1xuICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Ub3VjaFN0YXJ0UHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9uVG91Y2hTdGFydFByb3AoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmVmZXRjaEVuYWJsZWQgJiYgaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIEBzZWUge2h0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9kaXNjdXNzaW9ucy80MDI2OD9zb3J0PXRvcCNkaXNjdXNzaW9uY29tbWVudC0zNTcyNjQyfVxuICAgICAgICAgICAgICAgIGJ5cGFzc1ByZWZldGNoZWRDaGVjazogdHJ1ZVxuICAgICAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbiAgICAvLyBkZWZpbmVkLCB3ZSBzcGVjaWZ5IHRoZSBjdXJyZW50ICdocmVmJywgc28gdGhhdCByZXBldGl0aW9uIGlzIG5vdCBuZWVkZWQgYnkgdGhlIHVzZXIuXG4gICAgLy8gSWYgdGhlIHVybCBpcyBhYnNvbHV0ZSwgd2UgY2FuIGJ5cGFzcyB0aGUgbG9naWMgdG8gcHJlcGVuZCB0aGUgZG9tYWluIGFuZCBsb2NhbGUuXG4gICAgaWYgKCgwLCBfdXRpbHMuaXNBYnNvbHV0ZVVybCkoYXMpKSB7XG4gICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGFzO1xuICAgIH0gZWxzZSBpZiAoIWxlZ2FjeUJlaGF2aW9yIHx8IHBhc3NIcmVmIHx8IGNoaWxkLnR5cGUgPT09ICdhJyAmJiAhKCdocmVmJyBpbiBjaGlsZC5wcm9wcykpIHtcbiAgICAgICAgY29uc3QgY3VyTG9jYWxlID0gdHlwZW9mIGxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbGUgOiBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlO1xuICAgICAgICAvLyB3ZSBvbmx5IHJlbmRlciBkb21haW4gbG9jYWxlcyBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIGEgZG9tYWluIGxvY2FsZVxuICAgICAgICAvLyBzbyB0aGF0IGxvY2FsZSBsaW5rcyBhcmUgc3RpbGwgdmlzaXRhYmxlIGluIGRldmVsb3BtZW50L3ByZXZpZXcgZW52c1xuICAgICAgICBjb25zdCBsb2NhbGVEb21haW4gPSAocGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmlzTG9jYWxlRG9tYWluKSAmJiAoMCwgX2dldGRvbWFpbmxvY2FsZS5nZXREb21haW5Mb2NhbGUpKGFzLCBjdXJMb2NhbGUsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGVzLCBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIuZG9tYWluTG9jYWxlcyk7XG4gICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGxvY2FsZURvbWFpbiB8fCAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzLCBjdXJMb2NhbGUsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5kZWZhdWx0TG9jYWxlKSk7XG4gICAgfVxuICAgIHJldHVybiBsZWdhY3lCZWhhdmlvciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgX2V4dGVuZHMuXyh7fSwgcmVzdFByb3BzLCBjaGlsZFByb3BzKSwgY2hpbGRyZW4pO1xufSk7XG5jb25zdCBfZGVmYXVsdCA9IExpbms7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmsuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIl9kZWZhdWx0IiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UiLCJfcmVhY3QiLCJfIiwiX3Jlc29sdmVocmVmIiwiX2lzbG9jYWx1cmwiLCJfZm9ybWF0dXJsIiwiX3V0aWxzIiwiX2FkZGxvY2FsZSIsIl9yb3V0ZXJjb250ZXh0IiwiX2FwcHJvdXRlcmNvbnRleHQiLCJfdXNlaW50ZXJzZWN0aW9uIiwiX2dldGRvbWFpbmxvY2FsZSIsIl9hZGRiYXNlcGF0aCIsInByZWZldGNoZWQiLCJTZXQiLCJwcmVmZXRjaCIsInJvdXRlciIsImhyZWYiLCJhcyIsIm9wdGlvbnMiLCJpc0FwcFJvdXRlciIsImlzTG9jYWxVUkwiLCJieXBhc3NQcmVmZXRjaGVkQ2hlY2siLCJsb2NhbGUiLCJ1bmRlZmluZWQiLCJwcmVmZXRjaGVkS2V5IiwiaGFzIiwiYWRkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsImVyciIsInByb2Nlc3MiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsImV2ZW50VGFyZ2V0IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJwcmVmZXRjaEVuYWJsZWQiLCJub2RlTmFtZSIsImlzQW5jaG9yTm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsInByZXZlbnREZWZhdWx0IiwibmF2aWdhdGUiLCJmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uIiwiZGVmYXVsdCIsInN0YXJ0VHJhbnNpdGlvbiIsImZvcm1hdFN0cmluZ09yVXJsIiwidXJsT2JqT3JTdHJpbmciLCJmb3JtYXRVcmwiLCJMaW5rIiwiZm9yd2FyZFJlZiIsIkxpbmtDb21wb25lbnQiLCJwcm9wcyIsImZvcndhcmRlZFJlZiIsImNyZWF0ZVByb3BFcnJvciIsImFyZ3MiLCJFcnJvciIsImtleSIsImV4cGVjdGVkIiwiYWN0dWFsIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsImtleXMiLCJmb3JFYWNoIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwicGFzc0hyZWYiLCJvbkNsaWNrIiwib25Nb3VzZUVudGVyIiwib25Ub3VjaFN0YXJ0IiwibGVnYWN5QmVoYXZpb3IiLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsInVzZVJlZiIsImN1cnJlbnQiLCJjb25zb2xlIiwid2FybiIsImNoaWxkcmVuIiwiaHJlZlByb3AiLCJhc1Byb3AiLCJjaGlsZHJlblByb3AiLCJwcmVmZXRjaFByb3AiLCJvbk1vdXNlRW50ZXJQcm9wIiwib25Ub3VjaFN0YXJ0UHJvcCIsImVudiIsIl9fTkVYVF9ORVdfTElOS19CRUhBVklPUiIsInJlc3RQcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJwYWdlc1JvdXRlciIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiYXBwUm91dGVyIiwiQXBwUm91dGVyQ29udGV4dCIsInBhdGhuYW1lIiwiaGFzRHluYW1pY1NlZ21lbnQiLCJzcGxpdCIsInNvbWUiLCJzZWdtZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidXNlTWVtbyIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJyZXNvbHZlSHJlZiIsInByZXZpb3VzSHJlZiIsInByZXZpb3VzQXMiLCJjaGlsZCIsIkNoaWxkcmVuIiwib25seSIsInR5cGUiLCJjaGlsZFJlZiIsInJlZiIsInNldEludGVyc2VjdGlvblJlZiIsImlzVmlzaWJsZSIsInJlc2V0VmlzaWJsZSIsInVzZUludGVyc2VjdGlvbiIsInJvb3RNYXJnaW4iLCJzZXRSZWYiLCJ1c2VDYWxsYmFjayIsImVsIiwidXNlRWZmZWN0IiwiY2hpbGRQcm9wcyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJwcmlvcml0eSIsImlzQWJzb2x1dGVVcmwiLCJjdXJMb2NhbGUiLCJsb2NhbGVEb21haW4iLCJpc0xvY2FsZURvbWFpbiIsImdldERvbWFpbkxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwiY2xvbmVFbGVtZW50IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id , observer , elements  } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef , rootMargin , disabled  } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUMsNENBQU87QUFDOUIsTUFBTUMsdUJBQXVCRCxtQkFBT0EsQ0FBQyx5RkFBeUI7QUFDOUQsTUFBTUUsMEJBQTBCLE9BQU9DLHlCQUF5QjtBQUNoRSxNQUFNQyxZQUFZLElBQUlDO0FBQ3RCLE1BQU1DLFNBQVMsRUFBRTtBQUNqQixTQUFTQyxlQUFlQyxPQUFPLEVBQUU7SUFDN0IsTUFBTUMsS0FBSztRQUNQQyxNQUFNRixRQUFRRSxJQUFJLElBQUksSUFBSTtRQUMxQkMsUUFBUUgsUUFBUUksVUFBVSxJQUFJO0lBQ2xDO0lBQ0EsTUFBTUMsV0FBV1AsT0FBT1EsSUFBSSxDQUFDLENBQUNDLE1BQU1BLElBQUlMLElBQUksS0FBS0QsR0FBR0MsSUFBSSxJQUFJSyxJQUFJSixNQUFNLEtBQUtGLEdBQUdFLE1BQU07SUFDcEYsSUFBSUs7SUFDSixJQUFJSCxVQUFVO1FBQ1ZHLFdBQVdaLFVBQVVQLEdBQUcsQ0FBQ2dCO1FBQ3pCLElBQUlHLFVBQVU7WUFDVixPQUFPQTtRQUNYLENBQUM7SUFDTCxDQUFDO0lBQ0QsTUFBTUMsV0FBVyxJQUFJWjtJQUNyQixNQUFNYSxXQUFXLElBQUlmLHFCQUFxQixDQUFDZ0IsVUFBVTtRQUNqREEsUUFBUUMsT0FBTyxDQUFDLENBQUNDLFFBQVE7WUFDckIsTUFBTUMsV0FBV0wsU0FBU3BCLEdBQUcsQ0FBQ3dCLE1BQU1FLE1BQU07WUFDMUMsTUFBTUMsWUFBWUgsTUFBTUksY0FBYyxJQUFJSixNQUFNSyxpQkFBaUIsR0FBRztZQUNwRSxJ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TyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2hFLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTZELE9BQU8sRUFBRSxjQUFjO1FBQUU1RCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2lFLE1BQU0sQ0FBQy9ELFFBQVE2RCxPQUFPLEVBQUU3RDtJQUMvQmdFLE9BQU9oRSxPQUFPLEdBQUdBLFFBQVE2RCxPQUFPO0FBQ2xDLENBQUMsQ0FFRCw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvdXNlLWludGVyc2VjdGlvbi5qcz9mZDk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXNlSW50ZXJzZWN0aW9uXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1c2VJbnRlcnNlY3Rpb247XG4gICAgfVxufSk7XG5jb25zdCBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5jb25zdCBfcmVxdWVzdGlkbGVjYWxsYmFjayA9IHJlcXVpcmUoXCIuL3JlcXVlc3QtaWRsZS1jYWxsYmFja1wiKTtcbmNvbnN0IGhhc0ludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nO1xuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuY29uc3QgaWRMaXN0ID0gW107XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zKSB7XG4gICAgY29uc3QgaWQgPSB7XG4gICAgICAgIHJvb3Q6IG9wdGlvbnMucm9vdCB8fCBudWxsLFxuICAgICAgICBtYXJnaW46IG9wdGlvbnMucm9vdE1hcmdpbiB8fCAnJ1xuICAgIH07XG4gICAgY29uc3QgZXhpc3RpbmcgPSBpZExpc3QuZmluZCgob2JqKT0+b2JqLnJvb3QgPT09IGlkLnJvb3QgJiYgb2JqLm1hcmdpbiA9PT0gaWQubWFyZ2luKTtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIGluc3RhbmNlID0gb2JzZXJ2ZXJzLmdldChleGlzdGluZyk7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKT0+e1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KT0+e1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpbnN0YW5jZSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG9ic2VydmVyLFxuICAgICAgICBlbGVtZW50c1xuICAgIH07XG4gICAgaWRMaXN0LnB1c2goaWQpO1xuICAgIG9ic2VydmVycy5zZXQoaWQsIGluc3RhbmNlKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBvYnNlcnZlKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBpZCAsIG9ic2VydmVyICwgZWxlbWVudHMgIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKTtcbiAgICBlbGVtZW50cy5zZXQoZWxlbWVudCwgY2FsbGJhY2spO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVub2JzZXJ2ZSgpIHtcbiAgICAgICAgZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgIC8vIERlc3Ryb3kgb2JzZXJ2ZXIgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byB3YXRjaDpcbiAgICAgICAgaWYgKGVsZW1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIG9ic2VydmVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpZExpc3QuZmluZEluZGV4KChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZExpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb24oeyByb290UmVmICwgcm9vdE1hcmdpbiAsIGRpc2FibGVkICB9KSB7XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IGRpc2FibGVkIHx8ICFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSAoMCwgX3JlYWN0LnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgZWxlbWVudFJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKShudWxsKTtcbiAgICBjb25zdCBzZXRFbGVtZW50ID0gKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKGVsZW1lbnQpPT57XG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IGVsZW1lbnQ7XG4gICAgfSwgW10pO1xuICAgICgwLCBfcmVhY3QudXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHZpc2libGUpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bm9ic2VydmUgPSBvYnNlcnZlKGVsZW1lbnQsIChpc1Zpc2libGUpPT5pc1Zpc2libGUgJiYgc2V0VmlzaWJsZShpc1Zpc2libGUpLCB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3Q6IHJvb3RSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3RSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgcm9vdE1hcmdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bm9ic2VydmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGxlQ2FsbGJhY2sgPSAoMCwgX3JlcXVlc3RpZGxlY2FsbGJhY2sucmVxdWVzdElkbGVDYWxsYmFjaykoKCk9PnNldFZpc2libGUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKT0+KDAsIF9yZXF1ZXN0aWRsZWNhbGxiYWNrLmNhbmNlbElkbGVDYWxsYmFjaykoaWRsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIHJvb3RNYXJnaW4sXG4gICAgICAgIHJvb3RSZWYsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudFxuICAgIF0pO1xuICAgIGNvbnN0IHJlc2V0VmlzaWJsZSA9ICgwLCBfcmVhY3QudXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldFZpc2libGUoZmFsc2UpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzZXRFbGVtZW50LFxuICAgICAgICB2aXNpYmxlLFxuICAgICAgICByZXNldFZpc2libGVcbiAgICBdO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtaW50ZXJzZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJ1c2VJbnRlcnNlY3Rpb24iLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlcXVlc3RpZGxlY2FsbGJhY2siLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZXJzIiwiTWFwIiwiaWRMaXN0IiwiY3JlYXRlT2JzZXJ2ZXIiLCJvcHRpb25zIiwiaWQiLCJyb290IiwibWFyZ2luIiwicm9vdE1hcmdpbiIsImV4aXN0aW5nIiwiZmluZCIsIm9iaiIsImluc3RhbmNlIiwiZWxlbWVudHMiLCJvYnNlcnZlciIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkiLCJjYWxsYmFjayIsInRhcmdldCIsImlzVmlzaWJsZSIsImlzSW50ZXJzZWN0aW5nIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJwdXNoIiwic2V0Iiwib2JzZXJ2ZSIsImVsZW1lbnQiLCJ1bm9ic2VydmUiLCJkZWxldGUiLCJzaXplIiwiZGlzY29ubmVjdCIsImluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwicm9vdFJlZiIsImRpc2FibGVkIiwiaXNEaXNhYmxlZCIsInZpc2libGUiLCJzZXRWaXNpYmxlIiwidXNlU3RhdGUiLCJlbGVtZW50UmVmIiwidXNlUmVmIiwic2V0RWxlbWVudCIsInVzZUNhbGxiYWNrIiwiY3VycmVudCIsInVzZUVmZmVjdCIsInRhZ05hbWUiLCJpZGxlQ2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwicmVzZXRWaXNpYmxlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "./pages/snippets/index.tsx":
/*!**********************************!*\
  !*** ./pages/snippets/index.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__N_SSG\": function() { return /* binding */ __N_SSG; },\n/* harmony export */   \"default\": function() { return /* binding */ Snippets; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _layouts_Page__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @layouts/Page */ \"./layouts/Page.tsx\");\n/* harmony import */ var _components_Banner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @components/Banner */ \"./components/Banner.tsx\");\n/* harmony import */ var _components_Collapsable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @components/Collapsable */ \"./components/Collapsable.tsx\");\n/* harmony import */ var next_mdx_remote__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next-mdx-remote */ \"./node_modules/next-mdx-remote/index.js\");\n/* harmony import */ var _code_hike_mdx_components__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @code-hike/mdx/components */ \"./node_modules/@code-hike/mdx/dist/components.esm.mjs\");\n\n\n\n\n\n\nvar __N_SSG = true;\nfunction Snippets(param) {\n    let { snippets  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_layouts_Page__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n        description: \"\",\n        title: \"Rodrigo's Blog | Snippets\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Banner__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                title: \"What I've used\",\n                description: \"A collection with \".concat(snippets.length, \" JavaScript snippets that I used most\")\n            }, void 0, false, {\n                fileName: \"/opt/projects/blog/pages/snippets/index.tsx\",\n                lineNumber: 16,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: \"pt-4 grid gap-4\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-xl font-medium pl-4\",\n                        children: \"One line utilities\"\n                    }, void 0, false, {\n                        fileName: \"/opt/projects/blog/pages/snippets/index.tsx\",\n                        lineNumber: 21,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"grid gap-0.5 text-gray-600 hover:text-gray-400 font-medium first-letter:capitalize\",\n                        children: snippets.map((snippet, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Collapsable__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                label: snippet.title,\n                                tag: snippet.topic,\n                                open: true,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_mdx_remote__WEBPACK_IMPORTED_MODULE_4__.MDXRemote, {\n                                    components: {\n                                        CH: _code_hike_mdx_components__WEBPACK_IMPORTED_MODULE_5__.CH\n                                    },\n                                    ...snippet.content\n                                }, void 0, false, {\n                                    fileName: \"/opt/projects/blog/pages/snippets/index.tsx\",\n                                    lineNumber: 25,\n                                    columnNumber: 8\n                                }, this)\n                            }, snippet.title, false, {\n                                fileName: \"/opt/projects/blog/pages/snippets/index.tsx\",\n                                lineNumber: 24,\n                                columnNumber: 7\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"/opt/projects/blog/pages/snippets/index.tsx\",\n                        lineNumber: 22,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/opt/projects/blog/pages/snippets/index.tsx\",\n                lineNumber: 20,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/opt/projects/blog/pages/snippets/index.tsx\",\n        lineNumber: 15,\n        columnNumber: 3\n    }, this);\n}\n_c = Snippets;\nvar _c;\n$RefreshReg$(_c, \"Snippets\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9zbmlwcGV0cy9pbmRleC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFnQztBQUNPO0FBQ1U7QUFFTjtBQUNHOztBQU8vQixTQUFTSyxTQUFTLEtBQW1CLEVBQUU7UUFBckIsRUFBRUMsU0FBUSxFQUFTLEdBQW5CO0lBQ2hDLHFCQUNDLDhEQUFDTixxREFBSUE7UUFBQ08sYUFBWTtRQUFHQyxPQUFNOzswQkFDMUIsOERBQUNQLDBEQUFNQTtnQkFDTk8sT0FBTTtnQkFDTkQsYUFBYSxxQkFBcUMsT0FBaEJELFNBQVNHLE1BQU0sRUFBQzs7Ozs7OzBCQUVuRCw4REFBQ0M7Z0JBQVFDLFdBQVU7O2tDQUNsQiw4REFBQ0M7d0JBQUdELFdBQVU7a0NBQTJCOzs7Ozs7a0NBQ3pDLDhEQUFDRTt3QkFBSUYsV0FBVTtrQ0FDYkwsU0FBU1EsR0FBRyxDQUFDLENBQUNDLFNBQVNDLHNCQUN2Qiw4REFBQ2QsK0RBQVdBO2dDQUFxQmUsT0FBT0YsUUFBUVAsS0FBSztnQ0FBRVUsS0FBS0gsUUFBUUksS0FBSztnQ0FBRUMsSUFBSTswQ0FDOUUsNEVBQUNqQixzREFBU0E7b0NBQUNrQixZQUFZO3dDQUFFakIsRUFBRUEsMkRBQUFBO29DQUFDO29DQUFJLEdBQUdXLFFBQVFPLE9BQU87Ozs7OzsrQkFEakNQLFFBQVFQLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRckMsQ0FBQztLQW5CdUJIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL3NuaXBwZXRzL2luZGV4LnRzeD80MTY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQYWdlIGZyb20gJ0BsYXlvdXRzL1BhZ2UnXG5pbXBvcnQgQmFubmVyIGZyb20gJ0Bjb21wb25lbnRzL0Jhbm5lcidcbmltcG9ydCBDb2xsYXBzYWJsZSBmcm9tICdAY29tcG9uZW50cy9Db2xsYXBzYWJsZSdcbmltcG9ydCB7IGdldEZ1bGxDb250ZW50IH0gZnJvbSAnQHV0aWxzL2NvbnRlbnQnXG5pbXBvcnQgeyBNRFhSZW1vdGUgfSBmcm9tICduZXh0LW1keC1yZW1vdGUnXG5pbXBvcnQgeyBDSCB9IGZyb20gJ0Bjb2RlLWhpa2UvbWR4L2NvbXBvbmVudHMnXG5pbXBvcnQgeyBGdWxsQ29udGVudCB9IGZyb20gJ0Bjb250ZW50L3R5cGVzJ1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuXHRzbmlwcGV0czogRnVsbENvbnRlbnRbXVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTbmlwcGV0cyh7IHNuaXBwZXRzIH06IFByb3BzKSB7XG5cdHJldHVybiAoXG5cdFx0PFBhZ2UgZGVzY3JpcHRpb249JycgdGl0bGU9XCJSb2RyaWdvJ3MgQmxvZyB8IFNuaXBwZXRzXCI+XG5cdFx0XHQ8QmFubmVyXG5cdFx0XHRcdHRpdGxlPSdXaGF0IEkmIzM5O3ZlIHVzZWQnXG5cdFx0XHRcdGRlc2NyaXB0aW9uPXtgQSBjb2xsZWN0aW9uIHdpdGggJHtzbmlwcGV0cy5sZW5ndGh9IEphdmFTY3JpcHQgc25pcHBldHMgdGhhdCBJIHVzZWQgbW9zdGB9XG5cdFx0XHQvPlxuXHRcdFx0PHNlY3Rpb24gY2xhc3NOYW1lPSdwdC00IGdyaWQgZ2FwLTQnPlxuXHRcdFx0XHQ8aDEgY2xhc3NOYW1lPSd0ZXh0LXhsIGZvbnQtbWVkaXVtIHBsLTQnPk9uZSBsaW5lIHV0aWxpdGllczwvaDE+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdncmlkIGdhcC0wLjUgdGV4dC1ncmF5LTYwMCBob3Zlcjp0ZXh0LWdyYXktNDAwIGZvbnQtbWVkaXVtIGZpcnN0LWxldHRlcjpjYXBpdGFsaXplJz5cblx0XHRcdFx0XHR7c25pcHBldHMubWFwKChzbmlwcGV0LCBpbmRleDogbnVtYmVyKSA9PiAoXG5cdFx0XHRcdFx0XHQ8Q29sbGFwc2FibGUga2V5PXtzbmlwcGV0LnRpdGxlfSBsYWJlbD17c25pcHBldC50aXRsZX0gdGFnPXtzbmlwcGV0LnRvcGljfSBvcGVuPlxuXHRcdFx0XHRcdFx0XHQ8TURYUmVtb3RlIGNvbXBvbmVudHM9e3sgQ0ggfX0gey4uLnNuaXBwZXQuY29udGVudH0gLz5cblx0XHRcdFx0XHRcdDwvQ29sbGFwc2FibGU+XG5cdFx0XHRcdFx0KSl9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9zZWN0aW9uPlxuXHRcdDwvUGFnZT5cblx0KVxufVxuXG5leHBvcnQgY29uc3QgZ2V0U3RhdGljUHJvcHMgPSBhc3luYyAoKSA9PiB7XG5cdGNvbnN0IHNuaXBwZXRzID0gYXdhaXQgZ2V0RnVsbENvbnRlbnQoeyB0eXBlOiAnc25pcHBldHMnIH0pXG5cblx0cmV0dXJuIHtcblx0XHRwcm9wczoge1xuXHRcdFx0c25pcHBldHMsXG5cdFx0fSxcblx0fVxufVxuIl0sIm5hbWVzIjpbIlBhZ2UiLCJCYW5uZXIiLCJDb2xsYXBzYWJsZSIsIk1EWFJlbW90ZSIsIkNIIiwiU25pcHBldHMiLCJzbmlwcGV0cyIsImRlc2NyaXB0aW9uIiwidGl0bGUiLCJsZW5ndGgiLCJzZWN0aW9uIiwiY2xhc3NOYW1lIiwiaDEiLCJkaXYiLCJtYXAiLCJzbmlwcGV0IiwiaW5kZXgiLCJsYWJlbCIsInRhZyIsInRvcGljIiwib3BlbiIsImNvbXBvbmVudHMiLCJjb250ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/snippets/index.tsx\n"));

/***/ }),

/***/ "./utils/config.ts":
/*!*************************!*\
  !*** ./utils/config.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONTENT_TYPE_MAP\": function() { return /* binding */ CONTENT_TYPE_MAP; },\n/* harmony export */   \"HEADER_LINKS\": function() { return /* binding */ HEADER_LINKS; }\n/* harmony export */ });\nconst HEADER_LINKS = [\n    {\n        path: \"/\",\n        name: \"Home\"\n    },\n    {\n        path: \"/about\",\n        name: \"About\"\n    },\n    {\n        path: \"/articles\",\n        name: \"Articles\"\n    },\n    {\n        path: \"https://github.com/fullsnacker\",\n        name: \"Github\"\n    },\n    {\n        path: \"https://linktr.ee/fullsnacker\",\n        name: \"Links\"\n    }\n];\nconst CONTENT_TYPE_MAP = {\n    news: \"News \\uD83D\\uDDDE\",\n    nerd: \"Nerding out \\uD83E\\uDD13\",\n    tip: \"Tip \\uD83D\\uDCA1\"\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9jb25maWcudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxNQUFNQSxlQUFlO0lBQzNCO1FBQUVDLE1BQU07UUFBS0MsTUFBTTtJQUFPO0lBQzFCO1FBQUVELE1BQU07UUFBVUMsTUFBTTtJQUFRO0lBQ2hDO1FBQUVELE1BQU07UUFBYUMsTUFBTTtJQUFXO0lBQ3RDO1FBQUVELE1BQU07UUFBa0NDLE1BQU07SUFBUztJQUN6RDtRQUFFRCxNQUFNO1FBQWlDQyxNQUFNO0lBQVE7Q0FDdkQ7QUFFTSxNQUFNQyxtQkFBbUI7SUFDL0JDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxLQUFLO0FBQ04sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9jb25maWcudHM/MGIxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgSEVBREVSX0xJTktTID0gW1xuXHR7IHBhdGg6ICcvJywgbmFtZTogJ0hvbWUnIH0sXG5cdHsgcGF0aDogJy9hYm91dCcsIG5hbWU6ICdBYm91dCcgfSxcblx0eyBwYXRoOiAnL2FydGljbGVzJywgbmFtZTogJ0FydGljbGVzJyB9LFxuXHR7IHBhdGg6ICdodHRwczovL2dpdGh1Yi5jb20vZnVsbHNuYWNrZXInLCBuYW1lOiAnR2l0aHViJyB9LFxuXHR7IHBhdGg6ICdodHRwczovL2xpbmt0ci5lZS9mdWxsc25hY2tlcicsIG5hbWU6ICdMaW5rcycgfSxcbl1cblxuZXhwb3J0IGNvbnN0IENPTlRFTlRfVFlQRV9NQVAgPSB7XG5cdG5ld3M6ICdOZXdzIPCfl57vuI8nLFxuXHRuZXJkOiAnTmVyZGluZyBvdXQg8J+kkycsXG5cdHRpcDogJ1RpcCDwn5KhJyxcbn1cbiJdLCJuYW1lcyI6WyJIRUFERVJfTElOS1MiLCJwYXRoIiwibmFtZSIsIkNPTlRFTlRfVFlQRV9NQVAiLCJuZXdzIiwibmVyZCIsInRpcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/config.ts\n"));

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/link */ \"./node_modules/next/dist/client/link.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHlHQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzPzc1YjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/link.js\n"));

/***/ }),

/***/ "./node_modules/next/router.js":
/*!*************************************!*\
  !*** ./node_modules/next/router.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/router */ \"./node_modules/next/dist/client/router.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9yb3V0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsNkdBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L3JvdXRlci5qcz8xYmI2Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9yb3V0ZXInKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/router.js\n"));

/***/ }),

/***/ "./node_modules/next-mdx-remote/dist/jsx-runtime.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/next-mdx-remote/dist/jsx-runtime.cjs ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Copyright (c) HashiCorp, Inc.\n * SPDX-License-Identifier: MPL-2.0\n */\n\n/**\n * Allow jsx-runtime to be successfully imported from either React 17 or React 18.\n *\n * Inspired by the approach here: https://github.com/contentlayerdev/contentlayer/blob/main/packages/next-contentlayer/src/hooks/jsx-runtime.cjs\n */\nif (true) {\n  module.exports.jsxRuntime = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\")\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1tZHgtcmVtb3RlL2Rpc3QvanN4LXJ1bnRpbWUuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQXNDO0FBQzFDLEVBQUUsdUhBQTREO0FBQzlELEVBQUUsS0FBSyxFQUVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LW1keC1yZW1vdGUvZGlzdC9qc3gtcnVudGltZS5janM/OWFiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgSGFzaGlDb3JwLCBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuICovXG5cbi8qKlxuICogQWxsb3cganN4LXJ1bnRpbWUgdG8gYmUgc3VjY2Vzc2Z1bGx5IGltcG9ydGVkIGZyb20gZWl0aGVyIFJlYWN0IDE3IG9yIFJlYWN0IDE4LlxuICpcbiAqIEluc3BpcmVkIGJ5IHRoZSBhcHByb2FjaCBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vY29udGVudGxheWVyZGV2L2NvbnRlbnRsYXllci9ibG9iL21haW4vcGFja2FnZXMvbmV4dC1jb250ZW50bGF5ZXIvc3JjL2hvb2tzL2pzeC1ydW50aW1lLmNqc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMuanN4UnVudGltZSA9IHJlcXVpcmUoJ3JlYWN0L2pzeC1kZXYtcnVudGltZScpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cy5qc3hSdW50aW1lID0gcmVxdWlyZSgncmVhY3QvanN4LXJ1bnRpbWUnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-mdx-remote/dist/jsx-runtime.cjs\n"));

/***/ }),

/***/ "./node_modules/@code-hike/mdx/dist/components.esm.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@code-hike/mdx/dist/components.esm.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Annotation\": function() { return /* binding */ Annotation; },\n/* harmony export */   \"CH\": function() { return /* binding */ CH; },\n/* harmony export */   \"Code\": function() { return /* binding */ Code; },\n/* harmony export */   \"CodeSlot\": function() { return /* binding */ CodeSlot; },\n/* harmony export */   \"InlineCode\": function() { return /* binding */ InlineCode; },\n/* harmony export */   \"Preview\": function() { return /* binding */ Preview; },\n/* harmony export */   \"PreviewSlot\": function() { return /* binding */ PreviewSlot; },\n/* harmony export */   \"Scrollycoding\": function() { return /* binding */ Scrollycoding; },\n/* harmony export */   \"Section\": function() { return /* binding */ Section; },\n/* harmony export */   \"SectionCode\": function() { return /* binding */ SectionCode; },\n/* harmony export */   \"SectionLink\": function() { return /* binding */ SectionLink; },\n/* harmony export */   \"Slideshow\": function() { return /* binding */ Slideshow; },\n/* harmony export */   \"Spotlight\": function() { return /* binding */ Spotlight; },\n/* harmony export */   \"annotations\": function() { return /* binding */ annotationsMap; },\n/* harmony export */   \"internal\": function() { return /* binding */ internal; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n\"use client\";\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\n// from https://stackoverflow.com/a/53936623/1325646\r\nconst isValidHex = (hex) => /^#([A-Fa-f0-9]{3,4}){1,2}$/.test(hex);\r\nconst getChunksFromString = (st, chunkSize) => st.match(new RegExp(`.{${chunkSize}}`, \"g\"));\r\nconst convertHexUnitTo256 = (hex) => parseInt(hex.repeat(2 / hex.length), 16);\r\nfunction getAlphaFloat(a, alpha) {\r\n    if (typeof a !== \"undefined\") {\r\n        return a / 255;\r\n    }\r\n    if (typeof alpha != \"number\" || alpha < 0 || alpha > 1) {\r\n        return 1;\r\n    }\r\n    return alpha;\r\n}\r\nfunction hexToObject(hex) {\r\n    if (!hex) {\r\n        return undefined;\r\n    }\r\n    if (!isValidHex(hex)) {\r\n        throw new Error(\"Invalid color string, must be a valid hex color\");\r\n    }\r\n    const chunkSize = Math.floor((hex.length - 1) / 3);\r\n    const hexArr = getChunksFromString(hex.slice(1), chunkSize);\r\n    const [r, g, b, a] = hexArr.map(convertHexUnitTo256);\r\n    return {\r\n        r,\r\n        g,\r\n        b,\r\n        a: getAlphaFloat(a, 1),\r\n    };\r\n}\r\nfunction objectToHex(object) {\r\n    if (!object) {\r\n        return undefined;\r\n    }\r\n    const { r, g, b, a } = object;\r\n    const alpha = Math.round(a * 255);\r\n    return `#${r.toString(16).padStart(2, \"0\")}${g\r\n        .toString(16)\r\n        .padStart(2, \"0\")}${b\r\n        .toString(16)\r\n        .padStart(2, \"0\")}${alpha\r\n        .toString(16)\r\n        .padStart(2, \"0\")}`;\r\n}\r\nfunction transparent(color, opacity) {\r\n    if (!color) {\r\n        return color;\r\n    }\r\n    const { r, g, b, a } = hexToObject(color);\r\n    return objectToHex({ r, g, b, a: a * opacity });\r\n}\n\nfunction map(tween, fn) {\r\n    return {\r\n        prev: fn(tween.prev, \"prev\"),\r\n        next: fn(tween.next, \"next\"),\r\n    };\r\n}\r\nfunction withDefault(t, deft) {\r\n    return {\r\n        prev: (t === null || t === void 0 ? void 0 : t.prev) === undefined ? deft : t.prev,\r\n        next: (t === null || t === void 0 ? void 0 : t.next) === undefined ? deft : t.next,\r\n    };\r\n}\r\nfunction mapWithDefault(tween, deft, fn) {\r\n    return map(withDefault(tween, deft), fn);\r\n}\r\nfunction anyValue(tween, fn) {\r\n    return fn(tween.prev) || fn(tween.next);\r\n}\n\nfunction codeToText(code) {\r\n    return code.lines\r\n        .map(line => line.tokens.map(token => token.content).join(\"\"))\r\n        .join(\"\\n\");\r\n}\n\nfunction mapFocusToLineNumbers(focus, lines) {\r\n    if (!focus) {\r\n        // focus all lines\r\n        return mergeToObject([...lines.keys()].map(lineIndex => ({\r\n            [lineIndex + 1]: true,\r\n        })));\r\n    }\r\n    else {\r\n        return mergeToObject(splitParts(focus).map(parsePartToObject));\r\n    }\r\n}\r\nfunction splitParts(focus) {\r\n    return focus.split(/,(?![^\\[]*\\])/g);\r\n}\r\nfunction mergeToObject(entries) {\r\n    return entries.reduce((acc, obj) => Object.assign(acc, obj), {});\r\n}\r\nfunction hasColumns(part) {\r\n    return !!part.match(/(\\d+)\\[(.+)\\]/);\r\n}\r\nfunction parsePartToObject(part) {\r\n    // a part could be\r\n    // - a line number: \"2\"\r\n    // - a line range: \"5:9\"\r\n    // - a line number with a column selector: \"2[1,3:5,9]\"\r\n    const columnsMatch = part.match(/(\\d+)\\[(.+)\\]/);\r\n    if (columnsMatch) {\r\n        const [, line, columns] = columnsMatch;\r\n        const columnsList = columns\r\n            .split(\",\")\r\n            .map(parseExtremes);\r\n        const lineNumber = Number(line);\r\n        return { [lineNumber]: columnsList };\r\n    }\r\n    else {\r\n        return mergeToObject(expandString(part).map(lineNumber => ({\r\n            [lineNumber]: true,\r\n        })));\r\n    }\r\n}\r\nfunction parseExtremes(part) {\r\n    // Transforms something like\r\n    // - \"1:3\" to {start:1, end: 3}\r\n    // - \"4\" to {start:4, end:4}\r\n    const [start, end] = part.split(\":\");\r\n    if (!isNaturalNumber(start)) {\r\n        throw new FocusNumberError(start);\r\n    }\r\n    const startNumber = Number(start);\r\n    if (startNumber < 1) {\r\n        throw new LineOrColumnNumberError();\r\n    }\r\n    if (!end) {\r\n        return { start: startNumber, end: startNumber };\r\n    }\r\n    else {\r\n        if (!isNaturalNumber(end)) {\r\n            throw new FocusNumberError(end);\r\n        }\r\n        return { start: startNumber, end: +end };\r\n    }\r\n}\r\n/**\r\n * Return the first and last indexes to focus, both included\r\n */\r\nfunction getFocusExtremes(focus, lines) {\r\n    if (!focus) {\r\n        return [0, lines.length - 1];\r\n    }\r\n    else {\r\n        const parsed = parseFocus(focus);\r\n        const focusedIndexes = Object.keys(parsed).map(i => parseInt(i, 10));\r\n        return [\r\n            Math.min(...focusedIndexes),\r\n            Math.max(...focusedIndexes),\r\n        ];\r\n    }\r\n}\r\nfunction getFocusIndexes(focus, lines) {\r\n    if (!focus) {\r\n        return [...lines.keys()];\r\n    }\r\n    else {\r\n        const parsed = parseFocus(focus);\r\n        const focusedIndexes = Object.keys(parsed).map(i => parseInt(i, 10));\r\n        return focusedIndexes;\r\n    }\r\n}\r\nfunction parseFocus(focus) {\r\n    if (!focus) {\r\n        throw new Error(\"Focus cannot be empty\");\r\n    }\r\n    try {\r\n        const parts = focus\r\n            .split(/,(?![^\\[]*\\])/g)\r\n            .map(parsePart);\r\n        return fromEntries(parts.flat());\r\n    }\r\n    catch (error) {\r\n        // TODO enhance error\r\n        throw error;\r\n    }\r\n}\r\nfunction parsePart(part) {\r\n    // a part could be\r\n    // - a line number: \"2\"\r\n    // - a line range: \"5:9\"\r\n    // - a line number with a column selector: \"2[1,3:5,9]\"\r\n    const columnsMatch = part.match(/(\\d+)\\[(.+)\\]/);\r\n    if (columnsMatch) {\r\n        const [, line, columns] = columnsMatch;\r\n        const columnsList = columns.split(\",\").map(expandString);\r\n        const lineIndex = Number(line) - 1;\r\n        const columnIndexes = columnsList.flat().map(c => c - 1);\r\n        return [[lineIndex, columnIndexes]];\r\n    }\r\n    else {\r\n        return expandString(part).map(lineNumber => [\r\n            lineNumber - 1,\r\n            true,\r\n        ]);\r\n    }\r\n}\r\nfunction expandString(part) {\r\n    // Transforms something like\r\n    // - \"1:3\" to [1,2,3]\r\n    // - \"4\" to [4]\r\n    const [start, end] = part.split(\":\");\r\n    if (!isNaturalNumber(start)) {\r\n        throw new FocusNumberError(start);\r\n    }\r\n    const startNumber = Number(start);\r\n    if (startNumber < 1) {\r\n        throw new LineOrColumnNumberError();\r\n    }\r\n    if (!end) {\r\n        return [startNumber];\r\n    }\r\n    else {\r\n        if (!isNaturalNumber(end)) {\r\n            throw new FocusNumberError(end);\r\n        }\r\n        const list = [];\r\n        for (let i = startNumber; i <= +end; i++) {\r\n            list.push(i);\r\n        }\r\n        return list;\r\n    }\r\n}\r\nfunction isNaturalNumber(n) {\r\n    n = n.toString(); // force the value in case it is not\r\n    var n1 = Math.abs(n), n2 = parseInt(n, 10);\r\n    return !isNaN(n1) && n2 === n1 && n1.toString() === n;\r\n}\r\nclass LineOrColumnNumberError extends Error {\r\n    constructor() {\r\n        super(`Invalid line or column number in focus string`);\r\n        Object.setPrototypeOf(this, new.target.prototype);\r\n    }\r\n}\r\nclass FocusNumberError extends Error {\r\n    constructor(number) {\r\n        super(`Invalid number \"${number}\" in focus string`);\r\n        this.number = number;\r\n        Object.setPrototypeOf(this, new.target.prototype);\r\n    }\r\n}\r\nfunction fromEntries(pairs) {\r\n    const result = {};\r\n    let index = -1, length = pairs == null ? 0 : pairs.length;\r\n    while (++index < length) {\r\n        var pair = pairs[index];\r\n        result[pair[0]] = pair[1];\r\n    }\r\n    return result;\r\n}\n\nconst useLayoutEffect$4 = typeof window !== \"undefined\"\r\n    ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect\r\n    : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\r\n// for debugging:\r\n// export const useLayoutEffect = (\r\n//   effect: any,\r\n//   deps?: any\r\n// ) => {}\r\n// from https://overreacted.io/making-setinterval-declarative-with-react-hooks/\r\nfunction useInterval(callback, delay) {\r\n    const savedCallback = react__WEBPACK_IMPORTED_MODULE_0__.useRef(callback);\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        savedCallback.current = callback;\r\n    }, [callback]);\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        if (!delay && delay !== 0) {\r\n            return undefined;\r\n        }\r\n        const id = setInterval(() => savedCallback.current(), delay);\r\n        return () => clearInterval(id);\r\n    }, [delay]);\r\n}\n\nfunction clamp$2(x, min, max) {\r\n    return Math.min(Math.max(x, min), max);\r\n}\n\nconst DEFAULT_WIDTH = 200;\r\n// type DimensionsResult = {\r\n//   width: number\r\n//   height: number\r\n//   lineWidths: { prev: number; next: number }\r\n//   lineHeight: number\r\n//   colWidth: number\r\n// }\r\nfunction useDimensions(code, focus, minColumns, lineNumbers, rows, deps) {\r\n    const [dimensions, setDimensions] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\r\n    // in case the element starts hidden https://github.com/code-hike/codehike/issues/372\r\n    const [visibility, markAsVisible] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\r\n    const windowWidth = useWindowWidth();\r\n    const prevLineRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\r\n    // the element to render before dimensions are calculated\r\n    const { prevLongestLine, nextLongestLine, element } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n        const prevLongestLine = getLongestLine(code.prev, focus.prev);\r\n        const nextLongestLine = getLongestLine(code.next, focus.next);\r\n        const lines = (code.prev || code.next)\r\n            .trimEnd()\r\n            .split(newlineRe);\r\n        const largestLineNumber = Math.max(lines.length, 10);\r\n        if (rows) {\r\n            // make the lines match the requested number of rows\r\n            const heightInLines = rows === \"focus\"\r\n                ? focusHeightInLines(focus, lines)\r\n                : rows;\r\n            let i = lines.length;\r\n            while (i < heightInLines) {\r\n                lines.push(\"\");\r\n                i++;\r\n            }\r\n            // remove extra lines to match the requested rows\r\n            while (i > heightInLines) {\r\n                lines.pop();\r\n                i--;\r\n            }\r\n            // if we removed prevLongestLine, add it back\r\n            if (prevLongestLine &&\r\n                !lines.includes(prevLongestLine)) {\r\n                lines[lines.length - 1] = prevLongestLine;\r\n            }\r\n        }\r\n        // avod setting the ref more than once https://github.com/code-hike/codehike/issues/232\r\n        let prevLineRefSet = false;\r\n        const element = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", { className: \"ch-code-scroll-parent\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"br\", null),\r\n            lines.map((line, i) => {\r\n                const ref = !prevLineRefSet && line === prevLongestLine\r\n                    ? prevLineRef\r\n                    : undefined;\r\n                prevLineRefSet = prevLineRefSet || ref != null;\r\n                return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: ref, key: i },\r\n                    lineNumbers ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"ch-code-line-number\" },\r\n                        \"_\",\r\n                        largestLineNumber)) : undefined,\r\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: {\r\n                            display: \"inline-block\",\r\n                            // leftPad\r\n                            marginLeft: 16,\r\n                        } },\r\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, line))));\r\n            }),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"br\", null)));\r\n        return { prevLongestLine, nextLongestLine, element };\r\n    }, [code]);\r\n    const allDeps = [\r\n        ...deps,\r\n        windowWidth,\r\n        prevLongestLine,\r\n        nextLongestLine,\r\n        minColumns,\r\n        visibility,\r\n    ];\r\n    useLayoutEffect$4(() => {\r\n        var _a;\r\n        if (prevLineRef.current) {\r\n            const pll = prevLineRef.current;\r\n            const contentElement = pll === null || pll === void 0 ? void 0 : pll.parentElement;\r\n            const codeElement = contentElement.parentElement;\r\n            const { width } = codeElement.getBoundingClientRect();\r\n            if (!width && visibility === 0) {\r\n                const resizeObserver = new ResizeObserver(([entry]) => {\r\n                    const { width } = entry.contentRect;\r\n                    if (width) {\r\n                        resizeObserver.disconnect();\r\n                        markAsVisible(1);\r\n                    }\r\n                });\r\n                resizeObserver.observe(codeElement);\r\n                return () => resizeObserver.disconnect();\r\n            }\r\n            // TODO is it clientWidth or clientRect?\r\n            const lineContentDiv = pll === null || pll === void 0 ? void 0 : pll.querySelector(\":scope > div\");\r\n            const lineNumberSpan = pll === null || pll === void 0 ? void 0 : pll.querySelector(\":scope > span\");\r\n            const lnw = lineNumberSpan\r\n                ? getWidthWithPadding(lineNumberSpan)\r\n                : 0;\r\n            const plw = getWidthWithoutPadding(lineContentDiv);\r\n            const colWidth = plw / prevLongestLine.length || 1;\r\n            const nlw = nextLongestLine.length * colWidth;\r\n            const lineHeight = (_a = getHeightWithoutPadding(lineContentDiv)) !== null && _a !== void 0 ? _a : 20;\r\n            const d = {\r\n                containerWidth: getWidthWithoutPadding(codeElement.parentElement),\r\n                containerHeight: getHeightWithoutPadding(codeElement.parentElement),\r\n                contentWidth: getWidthWithoutPadding(contentElement.parentElement),\r\n                contentHeight: getHeightWithoutPadding(contentElement.parentElement),\r\n                lineWidths: [\r\n                    plw || nlw || DEFAULT_WIDTH,\r\n                    nlw || plw || DEFAULT_WIDTH,\r\n                ],\r\n                lineWidth: [\r\n                    Math.max(plw || nlw || DEFAULT_WIDTH, colWidth * minColumns),\r\n                    Math.max(nlw || plw || DEFAULT_WIDTH, colWidth * minColumns),\r\n                ],\r\n                lineHeight,\r\n                colWidth,\r\n                lineNumberWidth: lnw,\r\n                deps: allDeps,\r\n            };\r\n            setDimensions(d);\r\n        }\r\n        return () => { };\r\n    }, allDeps);\r\n    if (!dimensions ||\r\n        depsChanged(dimensions.deps, allDeps)) {\r\n        return { element, dimensions: null };\r\n    }\r\n    else {\r\n        return { element, dimensions };\r\n    }\r\n}\r\nconst newlineRe = /\\r\\n|\\r|\\n/;\r\nfunction getLongestLine(code, focus) {\r\n    const lines = code ? code.split(newlineRe) : [\"\"];\r\n    const focusIndexes = getFocusIndexes(focus, lines);\r\n    let longestLine = \"\";\r\n    lines.forEach((line, index) => {\r\n        if (focusIndexes.includes(index) &&\r\n            line.length > longestLine.length) {\r\n            longestLine = line;\r\n        }\r\n    });\r\n    return longestLine;\r\n}\r\nfunction getWidthWithoutPadding(element) {\r\n    const computedStyle = getComputedStyle(element);\r\n    return (parseFloat(computedStyle.width) -\r\n        parseFloat(computedStyle.paddingLeft) -\r\n        parseFloat(computedStyle.paddingRight));\r\n}\r\nfunction getWidthWithPadding(element) {\r\n    const computedStyle = getComputedStyle(element);\r\n    return parseFloat(computedStyle.width);\r\n}\r\nfunction getHeightWithoutPadding(element) {\r\n    if (!element)\r\n        return null;\r\n    const computedStyle = getComputedStyle(element);\r\n    return (parseFloat(computedStyle.height) -\r\n        parseFloat(computedStyle.paddingTop) -\r\n        parseFloat(computedStyle.paddingBottom));\r\n}\r\nfunction depsChanged(oldDeps, newDeps) {\r\n    for (let i = 0; i < oldDeps.length; i++) {\r\n        if (oldDeps[i] !== newDeps[i])\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nfunction useWindowWidth() {\r\n    const [width, setWidth] = react__WEBPACK_IMPORTED_MODULE_0__.useState(undefined);\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        function handleResize() {\r\n            setWidth(window.innerWidth);\r\n        }\r\n        window.addEventListener(\"resize\", handleResize);\r\n        return () => window.removeEventListener(\"resize\", handleResize);\r\n    }, []);\r\n    return width;\r\n}\r\nfunction focusHeightInLines(focus, lines) {\r\n    const [start, end] = getFocusExtremes(focus.prev, lines);\r\n    return end - start + 1;\r\n}\n\nfunction Diff() {}\nDiff.prototype = {\n  diff: function diff(oldString, newString) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = void 0;\n\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          // This should not happen, but we want to be safe.\n\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n  castInput: function castInput(value) {\n    return value;\n  },\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var lastComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 008000FF\n//  - U+00D7   Multiplication sign\n//  - U+00F7   Division sign\n// Latin Extended-A, 0100017F\n// Latin Extended-B, 0180024F\n// IPA Extensions, 025002AF\n// Spacing Modifier Letters, 02B002FF\n//  - U+02C7   &#711;  Caron\n//  - U+02D8   &#728;  Breve\n//  - U+02D9   &#729;  Dot Above\n//  - U+02DA   &#730;  Ring Above\n//  - U+02DB   &#731;  Ogonek\n//  - U+02DC   &#732;  Small Tilde\n//  - U+02DD   &#733;  Double Acute Accent\n// Latin Extended Additional, 1E001EFF\n\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\n\nwordDiff.equals = function (left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\n\nwordDiff.tokenize = function (value) {\n  var tokens = value.split(/(\\s+|[()[\\]{}'\"]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nvar lineDiff = new Diff();\n\nlineDiff.tokenize = function (value) {\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  } // Merge the content and line separators into single tokens\n\n\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\n\nvar sentenceDiff = new Diff();\n\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nvar cssDiff = new Diff();\n\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\n\njsonDiff.castInput = function (value) {\n  var _this$options = this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n    return typeof v === 'undefined' ? undefinedReplacement : v;\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (_typeof(obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}\n\nvar arrayDiff = new Diff();\n\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\n\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\n\nfunction mergeLines(code, lines) {\r\n    let enterIndex = 0;\r\n    let exitIndex = 0;\r\n    const indexes = diff(code);\r\n    const newLines = indexes.map(index => {\r\n        if (index.next === undefined) {\r\n            return Object.assign(Object.assign({}, lines.prev[index.prev]), { lineNumber: {\r\n                    prev: index.prev + 1,\r\n                }, move: \"exit\", enterIndex: null, exitIndex: exitIndex++ });\r\n        }\r\n        if (index.prev === undefined) {\r\n            return Object.assign(Object.assign({}, lines.next[index.next]), { lineNumber: {\r\n                    next: index.next + 1,\r\n                }, move: \"enter\", enterIndex: enterIndex++, exitIndex: null });\r\n        }\r\n        return Object.assign(Object.assign({}, lines.prev[index.prev]), { lineNumber: {\r\n                prev: index.prev + 1,\r\n                next: index.next + 1,\r\n            }, move: \"stay\", enterIndex: null, exitIndex: null });\r\n    });\r\n    return {\r\n        lines: newLines,\r\n        enterCount: enterIndex,\r\n        exitCount: exitIndex,\r\n    };\r\n}\r\n/**\r\n * Returns a list of pairs of line indexes:\r\n *\r\n * For example if lines 2 and 3 were removed\r\n * and two lines where added at the end:\r\n *  0 0\r\n *  1 -\r\n *  2 -\r\n *  3 1\r\n *  - 2\r\n *  - 3\r\n */\r\nfunction diff(code) {\r\n    const changes = diffLines(code.prev, code.next);\r\n    let indexes = [];\r\n    let prevIndex = 0;\r\n    let nextIndex = 0;\r\n    changes.forEach(change => {\r\n        if (change.added) {\r\n            for (let i = 0; i < change.count; i++) {\r\n                indexes.push({ next: nextIndex++ });\r\n            }\r\n        }\r\n        else if (change.removed) {\r\n            for (let i = 0; i < change.count; i++) {\r\n                indexes.push({ prev: prevIndex++ });\r\n            }\r\n        }\r\n        else {\r\n            for (let i = 0; i < change.count; i++) {\r\n                indexes.push({\r\n                    prev: prevIndex++,\r\n                    next: nextIndex++,\r\n                });\r\n            }\r\n        }\r\n    });\r\n    return indexes;\r\n}\n\nfunction splitByFocus(mergedCode, focus, annotations) {\r\n    const { lines } = mergedCode, mergedCodeRest = __rest(mergedCode, [\"lines\"]);\r\n    const focusByLineNumber = map(focus, (focus, key) => {\r\n        // we need to filter the lines that don't belong to the step\r\n        // for the case where focus == \"\"\r\n        const stepLines = key === \"prev\"\r\n            ? lines.filter(l => l.move !== \"enter\")\r\n            : lines.filter(l => l.move !== \"exit\");\r\n        return mapFocusToLineNumbers(focus, stepLines);\r\n    });\r\n    const splittedLines = lines.map(line => {\r\n        const { tokens } = line, rest = __rest(line, [\"tokens\"]);\r\n        const lineFocus = {\r\n            prev: line.lineNumber.prev\r\n                ? focusByLineNumber.prev[line.lineNumber.prev]\r\n                : false,\r\n            next: line.lineNumber.next\r\n                ? focusByLineNumber.next[line.lineNumber.next]\r\n                : false,\r\n        };\r\n        const lineAnnotations = {\r\n            prev: line.lineNumber.prev\r\n                ? annotations.prev[line.lineNumber.prev] || []\r\n                : [],\r\n            next: line.lineNumber.next\r\n                ? annotations.next[line.lineNumber.next] || []\r\n                : [],\r\n        };\r\n        return Object.assign({ focused: map(lineFocus, focus => !!focus), groups: getTokenGroups(tokens, lineFocus, lineAnnotations) }, rest);\r\n    });\r\n    const focusedLineNumbers = map(focusByLineNumber, focusByLineNumber => Object.keys(focusByLineNumber).map(k => Number(k)));\r\n    const firstFocusedLineNumber = map(focusedLineNumbers, focusedLineNumbers => Math.min(...focusedLineNumbers));\r\n    const lastFocusedLineNumber = map(focusedLineNumbers, focusedLineNumbers => Math.max(...focusedLineNumbers));\r\n    return Object.assign({ lines: splittedLines, firstFocusedLineNumber,\r\n        lastFocusedLineNumber }, mergedCodeRest);\r\n}\r\n/**\r\n * Get the least amount of groups where no consecutive groups have\r\n * the same combination of prevFocus, nextFocus, prevAnnotation, nextAnnotation.\r\n */\r\nfunction getTokenGroups(tokens, focus, annotations) {\r\n    const focusExtremes = map(focus, focus => Array.isArray(focus) ? focus : []);\r\n    const annotationExtremes = map(annotations, annotations => annotations.map(({ columnNumbers }) => columnNumbers));\r\n    const allExtremes = [\r\n        ...focusExtremes.prev,\r\n        ...focusExtremes.next,\r\n        ...annotationExtremes.prev,\r\n        ...annotationExtremes.next,\r\n    ];\r\n    const splittedTokens = splitTokens(tokens, allExtremes);\r\n    let startIndex = 0;\r\n    let currentGroup = null;\r\n    const groups = [];\r\n    splittedTokens.forEach(token => {\r\n        const newPrevFocus = isIn(startIndex, focus.prev);\r\n        const newNextFocus = isIn(startIndex, focus.next);\r\n        const newPrevAnnotation = getAnnotation(startIndex, annotations.prev);\r\n        const newNextAnnotation = getAnnotation(startIndex, annotations.next);\r\n        if (!currentGroup ||\r\n            currentGroup.focused.prev !== newPrevFocus ||\r\n            currentGroup.focused.next !== newNextFocus ||\r\n            currentGroup.annotation.prev !== newPrevAnnotation ||\r\n            currentGroup.annotation.next !== newNextAnnotation) {\r\n            currentGroup = {\r\n                focused: {\r\n                    prev: newPrevFocus,\r\n                    next: newNextFocus,\r\n                },\r\n                tokens: [],\r\n                annotation: {\r\n                    prev: newPrevAnnotation,\r\n                    next: newNextAnnotation,\r\n                },\r\n            };\r\n            groups.push(currentGroup);\r\n        }\r\n        currentGroup === null || currentGroup === void 0 ? void 0 : currentGroup.tokens.push(token);\r\n        startIndex += token.content.length;\r\n    });\r\n    return groups.map(group => ({\r\n        focused: group.focused,\r\n        tokens: group.tokens,\r\n        element: getGroupElement(group),\r\n    }));\r\n}\r\nfunction getGroupElement(group) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, group.tokens.map(({ content, props }, i) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", Object.assign({}, props, { key: i + 1 }), content)))));\r\n}\r\n/**\r\n * Split a list of tokens into a more fine-graned list of tokens\r\n *\r\n * tokens: [abc][defg]\r\n * extremes: [1:2,2:5]\r\n * result tokens: [ab][c][de][fg]\r\n *\r\n */\r\nfunction splitTokens(tokens, extremes) {\r\n    const splitIndexes = [\r\n        ...extremes.map(e => e.start - 1),\r\n        ...extremes.map(e => e.end),\r\n    ];\r\n    let oldTokens = tokens;\r\n    splitIndexes.forEach(splitIndex => {\r\n        const newTokens = [];\r\n        let i = 0;\r\n        oldTokens.forEach(token => {\r\n            const startIndex = i;\r\n            const endIndex = i + token.content.length;\r\n            const shouldSplit = startIndex < splitIndex && splitIndex < endIndex;\r\n            if (shouldSplit) {\r\n                const sliceIndex = splitIndex - startIndex;\r\n                const content0 = token.content.slice(0, sliceIndex);\r\n                const content1 = token.content.slice(sliceIndex);\r\n                newTokens.push(Object.assign(Object.assign({}, token), { content: content0 }));\r\n                newTokens.push(Object.assign(Object.assign({}, token), { content: content1 }));\r\n            }\r\n            else {\r\n                newTokens.push(token);\r\n            }\r\n            i = endIndex;\r\n        });\r\n        oldTokens = newTokens;\r\n    });\r\n    return oldTokens;\r\n}\r\nfunction isIn(index, intervals) {\r\n    if (!Array.isArray(intervals)) {\r\n        return intervals;\r\n    }\r\n    return intervals.some(({ start, end }) => start - 1 <= index && index < end);\r\n}\r\nfunction getAnnotation(index, annotations) {\r\n    return annotations.find(({ columnNumbers }) => columnNumbers.start - 1 <= index &&\r\n        index < columnNumbers.end);\r\n}\n\nfunction tween$1(params, t) {\r\n    // needs === true for typescript...\r\n    if (params.fixed === true) {\r\n        return params.value;\r\n    }\r\n    else {\r\n        const [start, end] = params.interval;\r\n        const [from, to] = params.extremes;\r\n        if (t < start)\r\n            return from;\r\n        if (t > end)\r\n            return to;\r\n        const x = (t - start) / (end - start);\r\n        const ease = params.ease || easing.linear;\r\n        return from + ease(x) * (to - from);\r\n    }\r\n}\r\nfunction stagger([start, end], index, count) {\r\n    if (count <= 1)\r\n        return [start, end];\r\n    const totalDuration = end - start;\r\n    const stepDuration = totalDuration / Math.pow(count, 1 / 8);\r\n    const tick = (totalDuration - stepDuration) / (count - 1);\r\n    const stepStart = start + tick * index;\r\n    const stepEnd = stepStart + stepDuration;\r\n    return [stepStart, stepEnd];\r\n}\r\nconst easing = {\r\n    linear: function (t) {\r\n        return t;\r\n    },\r\n    easeInQuad: function (t) {\r\n        return t * t;\r\n    },\r\n    easeOutQuad: function (t) {\r\n        return t * (2 - t);\r\n    },\r\n    easeInOutCubic: function (t) {\r\n        return t < 0.5\r\n            ? 4 * t * t * t\r\n            : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n    },\r\n};\n\nfunction getLinesWithElements(lines, verticalInterval, enterCount, exitCount) {\r\n    // startY is the progress when we start moving vertically\r\n    // endY is when we stop\r\n    const [startY, endY] = verticalInterval;\r\n    return lines.map(line => {\r\n        const lineIndex = map(line.lineNumber, ln => ln && ln - 1);\r\n        const { enterIndex, exitIndex } = line;\r\n        const tweenY = line.move === \"exit\"\r\n            ? { fixed: true, value: lineIndex.prev }\r\n            : line.move === \"enter\"\r\n                ? { fixed: true, value: lineIndex.next }\r\n                : {\r\n                    fixed: false,\r\n                    extremes: [lineIndex.prev, lineIndex.next],\r\n                    interval: [startY, endY],\r\n                    ease: easing.easeInOutCubic,\r\n                };\r\n        const tweenX = line.move === \"exit\"\r\n            ? {\r\n                fixed: false,\r\n                extremes: [0, -1],\r\n                ease: easing.easeInQuad,\r\n                interval: stagger([0, startY], exitIndex, exitCount),\r\n            }\r\n            : line.move === \"enter\"\r\n                ? {\r\n                    fixed: false,\r\n                    extremes: [1, 0],\r\n                    ease: easing.easeOutQuad,\r\n                    interval: stagger([endY, 1], enterIndex, enterCount),\r\n                }\r\n                : { fixed: true, value: 0 };\r\n        return Object.assign(Object.assign({}, line), { tweenX,\r\n            tweenY });\r\n    });\r\n}\n\nfunction parseAnnotations(annotations) {\r\n    // split annotations with multiple parts in the focus string\r\n    // \"1:2,3[4:5]\" becomes  two annotations \"1:2\" and \"3[4:5]\"\r\n    const expandedAnnotations = mapWithDefault(annotations, [], annotations => annotations.flatMap(annotation => splitParts(annotation.focus).map(part => (Object.assign(Object.assign({}, annotation), { focus: part })))));\r\n    const inlineCodeAnnotations = mapWithDefault(expandedAnnotations, [], annotations => annotations.filter(isInline));\r\n    const multilineCodeAnnotations = mapWithDefault(expandedAnnotations, [], annotations => annotations.filter(a => !isInline(a)));\r\n    return {\r\n        inlineAnnotations: map(inlineCodeAnnotations, annotations => parseInlineAnnotations(annotations)),\r\n        multilineAnnotations: map(multilineCodeAnnotations, annotations => parseMultilineAnnotations(annotations)),\r\n    };\r\n}\r\nfunction isInline(annotation) {\r\n    return hasColumns(annotation.focus);\r\n}\r\nfunction parseInlineAnnotations(annotations) {\r\n    const annotationMap = {};\r\n    annotations.forEach(annotation => {\r\n        const focusMap = parsePartToObject(annotation.focus);\r\n        const lineNumber = +Object.keys(focusMap)[0];\r\n        const columnNumbersList = focusMap[lineNumber];\r\n        const lineAnnotations = annotationMap[lineNumber] || [];\r\n        lineAnnotations.push({\r\n            columnNumbers: columnNumbersList[0],\r\n            data: annotation.data,\r\n            Component: annotation.Component,\r\n        });\r\n        annotationMap[lineNumber] = lineAnnotations;\r\n    });\r\n    return annotationMap;\r\n}\r\nfunction parseMultilineAnnotations(annotations) {\r\n    return annotations.map(annotation => {\r\n        return {\r\n            lineNumbers: parseExtremes(annotation.focus),\r\n            data: annotation.data,\r\n            Component: annotation.Component,\r\n        };\r\n    });\r\n}\r\n// --- multiline\r\nfunction annotateMultiline(lines, annotations) {\r\n    return {\r\n        prev: annotateMultilineSide(lines, annotations.prev, line => line.lineNumber.prev),\r\n        next: annotateMultilineSide(lines, annotations.next, line => line.lineNumber.next),\r\n    };\r\n}\r\nfunction annotateMultilineSide(lines, ogAnnotations, getLineNumber) {\r\n    const annotations = [...ogAnnotations];\r\n    annotations.sort((a, b) => a.lineNumbers.start - b.lineNumbers.start);\r\n    let lineIndex = 0;\r\n    const groups = [];\r\n    while (lineIndex < lines.length) {\r\n        const annotation = annotations[0];\r\n        let line = lines[lineIndex];\r\n        if (annotation &&\r\n            getLineNumber(line) > annotation.lineNumbers.start) {\r\n            throw \"Code Hike can't handle two annotations for the same line\";\r\n        }\r\n        if (annotation &&\r\n            getLineNumber(line) === annotation.lineNumbers.start) {\r\n            // create annotation group\r\n            const group = {\r\n                lines: [],\r\n                annotation,\r\n            };\r\n            while (line &&\r\n                (!getLineNumber(line) ||\r\n                    getLineNumber(line) <=\r\n                        annotation.lineNumbers.end)) {\r\n                group.lines.push(line);\r\n                line = lines[++lineIndex];\r\n            }\r\n            groups.push(group);\r\n            annotations.shift();\r\n        }\r\n        else if (!annotation) {\r\n            // create unannotated group until the end\r\n            groups.push({ lines: lines.slice(lineIndex) });\r\n            lineIndex = lines.length;\r\n        }\r\n        else {\r\n            // create unannotated group until next annotation\r\n            const group = {\r\n                lines: [],\r\n            };\r\n            while (line &&\r\n                (!getLineNumber(line) ||\r\n                    getLineNumber(line) <\r\n                        annotation.lineNumbers.start)) {\r\n                group.lines.push(line);\r\n                line = lines[++lineIndex];\r\n            }\r\n            groups.push(group);\r\n        }\r\n    }\r\n    return groups;\r\n}\r\n// --- inline\r\nfunction annotateInline(lines, inlineAnnotations) {\r\n    return lines.map((_a) => {\r\n        var { groups } = _a, line = __rest(_a, [\"groups\"]);\r\n        const { lineNumber } = line;\r\n        const annotations = {\r\n            prev: lineNumber.prev\r\n                ? inlineAnnotations.prev[lineNumber.prev] || []\r\n                : [],\r\n            next: lineNumber.next\r\n                ? inlineAnnotations.next[lineNumber.next] || []\r\n                : [],\r\n        };\r\n        return Object.assign(Object.assign({}, line), { annotatedGroups: annotateLineTokenGroups(groups, annotations) });\r\n    });\r\n}\r\n/**\r\n * Generate a list of annotated groups tweens\r\n * each annotated group contains a list of token groups and maybe an annotation.\r\n * The two annotated groups in a tween doesn't need to have the same token groups.\r\n */\r\nfunction annotateLineTokenGroups(tokenGroups, annotations) {\r\n    let prevTokenGroups = [...tokenGroups];\r\n    let nextTokenGroups = [...tokenGroups];\r\n    const prevAnnotations = [...annotations.prev];\r\n    const nextAnnotations = [...annotations.next];\r\n    const annotatedGroups = [];\r\n    let prevColumn = 1;\r\n    let nextColumn = 1;\r\n    // iterate until we consume both lists of token groups\r\n    while (prevTokenGroups.length > 0 ||\r\n        nextTokenGroups.length > 0) {\r\n        const prevAnnotation = prevAnnotations[0];\r\n        const nextAnnotation = nextAnnotations[0];\r\n        const isPrevAnnotationStarting = prevAnnotation &&\r\n            prevAnnotation.columnNumbers.start === prevColumn;\r\n        const isNextAnnotationStarting = nextAnnotation &&\r\n            nextAnnotation.columnNumbers.start === nextColumn;\r\n        if (prevColumn < nextColumn) {\r\n            // if the prev list is behind we consume from prevTokenGroups\r\n            if (isPrevAnnotationStarting) {\r\n                // if there is an annotation starting at this point we consume until the annotation ends\r\n                const end = prevAnnotation.columnNumbers.end + 1;\r\n                annotatedGroups.push({\r\n                    prev: {\r\n                        annotation: prevAnnotation,\r\n                        groups: shiftGroups(prevTokenGroups, prevColumn, end),\r\n                    },\r\n                });\r\n                prevColumn = end;\r\n                prevAnnotations.shift();\r\n            }\r\n            else {\r\n                // if there isn't we consume until we sync with the next list or an annotation starts\r\n                const end = Math.min(nextColumn, (prevAnnotation === null || prevAnnotation === void 0 ? void 0 : prevAnnotation.columnNumbers.start) || nextColumn);\r\n                annotatedGroups.push({\r\n                    prev: {\r\n                        groups: shiftGroups(prevTokenGroups, prevColumn, end),\r\n                    },\r\n                });\r\n                prevColumn = end;\r\n            }\r\n        }\r\n        else if (prevColumn > nextColumn) {\r\n            // if the next list is behind we consume from nextTokenGroups\r\n            if (isNextAnnotationStarting) {\r\n                // if there is an annotation starting at this point we consume until the annotation ends\r\n                const end = nextAnnotation.columnNumbers.end + 1;\r\n                annotatedGroups.push({\r\n                    next: {\r\n                        annotation: nextAnnotation,\r\n                        groups: shiftGroups(nextTokenGroups, nextColumn, end),\r\n                    },\r\n                });\r\n                nextColumn = end;\r\n                nextAnnotations.shift();\r\n            }\r\n            else {\r\n                // if there isn't we consume until we sync with the prev list or an annotation starts\r\n                const end = Math.min(prevColumn, (nextAnnotation === null || nextAnnotation === void 0 ? void 0 : nextAnnotation.columnNumbers.start) || prevColumn);\r\n                annotatedGroups.push({\r\n                    next: {\r\n                        groups: shiftGroups(nextTokenGroups, nextColumn, end),\r\n                    },\r\n                });\r\n                nextColumn = end;\r\n            }\r\n        }\r\n        else if (prevColumn == nextColumn) {\r\n            // if we are at the same column in both lists we have 5 different cases\r\n            if (isPrevAnnotationStarting &&\r\n                isNextAnnotationStarting &&\r\n                prevAnnotation.columnNumbers.end ===\r\n                    nextAnnotation.columnNumbers.end) {\r\n                // both annotations starts here and end at the same place, so we puth both in one tween annotated group\r\n                const end = nextAnnotation.columnNumbers.end + 1;\r\n                annotatedGroups.push({\r\n                    prev: {\r\n                        annotation: prevAnnotation,\r\n                        groups: shiftGroups(prevTokenGroups, prevColumn, end),\r\n                    },\r\n                    next: {\r\n                        annotation: nextAnnotation,\r\n                        groups: shiftGroups(nextTokenGroups, nextColumn, end),\r\n                    },\r\n                });\r\n                prevColumn = end;\r\n                nextColumn = end;\r\n                prevAnnotations.shift();\r\n                nextAnnotations.shift();\r\n            }\r\n            else if (isPrevAnnotationStarting) {\r\n                // if only the prev annotation starting at this point we consume until the annotation ends\r\n                const end = prevAnnotation.columnNumbers.end + 1;\r\n                annotatedGroups.push({\r\n                    prev: {\r\n                        annotation: prevAnnotation,\r\n                        groups: shiftGroups(prevTokenGroups, prevColumn, end),\r\n                    },\r\n                });\r\n                prevColumn = end;\r\n                prevAnnotations.shift();\r\n            }\r\n            else if (isNextAnnotationStarting) {\r\n                // same for the next annotation\r\n                const end = nextAnnotation.columnNumbers.end + 1;\r\n                annotatedGroups.push({\r\n                    next: {\r\n                        annotation: nextAnnotation,\r\n                        groups: shiftGroups(nextTokenGroups, nextColumn, end),\r\n                    },\r\n                });\r\n                nextColumn = end;\r\n                nextAnnotations.shift();\r\n            }\r\n            else if (!prevAnnotation && !nextAnnotation) {\r\n                // if there aren't any remaining annotation we add a last group\r\n                annotatedGroups.push({\r\n                    prev: { groups: prevTokenGroups },\r\n                    next: { groups: nextTokenGroups },\r\n                });\r\n                // this is the last iteration\r\n                prevTokenGroups = [];\r\n                nextTokenGroups = [];\r\n            }\r\n            else {\r\n                // if we still have annotations left we consume until the next one\r\n                const end = Math.min((prevAnnotation === null || prevAnnotation === void 0 ? void 0 : prevAnnotation.columnNumbers.start) ||\r\n                    Number.MAX_VALUE, (nextAnnotation === null || nextAnnotation === void 0 ? void 0 : nextAnnotation.columnNumbers.start) ||\r\n                    Number.MAX_VALUE);\r\n                annotatedGroups.push({\r\n                    prev: {\r\n                        groups: shiftGroups(prevTokenGroups, prevColumn, end),\r\n                    },\r\n                    next: {\r\n                        groups: shiftGroups(nextTokenGroups, nextColumn, end),\r\n                    },\r\n                });\r\n                prevColumn = end;\r\n                nextColumn = end;\r\n            }\r\n        }\r\n    }\r\n    return annotatedGroups;\r\n}\r\n/**\r\n * Remove and return some groups from the beggining of the array\r\n * startColumn is the column at which the array is starting\r\n * (because other groups has been already removed)\r\n * newStartColumn is the first column that should stay in the array\r\n */\r\nfunction shiftGroups(tokenGroups, startColumn, newStartColumn) {\r\n    const removedGroups = [];\r\n    let currentStartColumn = startColumn;\r\n    while (currentStartColumn < newStartColumn &&\r\n        tokenGroups.length > 0) {\r\n        const currentTokenGroup = tokenGroups.shift();\r\n        removedGroups.push(currentTokenGroup);\r\n        const length = currentTokenGroup.tokens.reduce((a, t) => a + t.content.length, 0);\r\n        currentStartColumn += length;\r\n    }\r\n    return removedGroups;\r\n}\n\nfunction useStepParser(input) {\r\n    const { highlightedLines, focus } = input;\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => parse$1(input), [\r\n        highlightedLines.prev,\r\n        highlightedLines.next,\r\n        focus.prev,\r\n        focus.next,\r\n    ]);\r\n}\r\nfunction parse$1({ focus, annotations, highlightedLines, lang, }) {\r\n    const normalCode = getCode(highlightedLines);\r\n    const mergedCode = merge(normalCode, highlightedLines);\r\n    const { inlineAnnotations, multilineAnnotations } = parseAllAnnotations(annotations);\r\n    const focusedCode = splitLinesByFocus(mergedCode, withDefault(focus, null), inlineAnnotations);\r\n    const annotatedCode = addAnnotations(focusedCode, inlineAnnotations, multilineAnnotations);\r\n    const codeStep = addExtraStuff(annotatedCode, normalCode, lang);\r\n    // console.log({ codeStep })\r\n    return codeStep;\r\n}\r\n// 0 - normalize\r\nfunction getCode(highlightedLines) {\r\n    return map(highlightedLines, lines => lines\r\n        .map(line => line.tokens.map(t => t.content).join(\"\"))\r\n        .join(\"\\n\")\r\n        .trimEnd()\r\n        .concat(\"\\n\"));\r\n}\r\nfunction merge(code, highlightedLines) {\r\n    return mergeLines(code, highlightedLines);\r\n}\r\nfunction parseAllAnnotations(annotations) {\r\n    return parseAnnotations(annotations);\r\n}\r\nfunction splitLinesByFocus(mergedCode, focus, annotations) {\r\n    return splitByFocus(mergedCode, focus, annotations);\r\n}\r\nfunction addAnnotations(_a, inlineAnnotations, annotations) {\r\n    var { lines } = _a, focusedCode = __rest(_a, [\"lines\"]);\r\n    const annotatedLines = annotateInline(lines, inlineAnnotations);\r\n    const lineGroups = annotateMultiline(annotatedLines, annotations);\r\n    return Object.assign(Object.assign({}, focusedCode), { lineGroups: lineGroups, lineCount: {\r\n            prev: lines.filter(l => l.lineNumber.prev != null)\r\n                .length,\r\n            next: lines.filter(l => l.lineNumber.next != null)\r\n                .length,\r\n        } });\r\n}\r\nfunction addExtraStuff(codeStep, code, lang) {\r\n    const vInterval = verticalInterval(codeStep.enterCount, codeStep.exitCount);\r\n    const newGroups = map(codeStep.lineGroups, groups => groups.map(group => (Object.assign(Object.assign({}, group), { lines: getLinesWithElements(group.lines, vInterval, codeStep.enterCount, codeStep.exitCount) }))));\r\n    return Object.assign(Object.assign({}, codeStep), { groups: newGroups, verticalInterval: vInterval, code,\r\n        lang });\r\n}\r\nfunction verticalInterval(enterCount, exitCount) {\r\n    if (enterCount <= 0 && exitCount <= 0)\r\n        return [0, 1];\r\n    if (enterCount <= 0 && exitCount >= 1)\r\n        return [0.33, 1];\r\n    if (enterCount >= 1 && exitCount <= 0)\r\n        return [0, 0.67];\r\n    return [0.25, 0.75];\r\n}\n\nfunction SmoothContainer({ dimensions, codeStep, children, minZoom = 0, maxZoom = 1.2, center = false, progress, }) {\r\n    const { prev, next } = getTweenContentProps({\r\n        codeStep,\r\n        dimensions,\r\n        minZoom,\r\n        maxZoom,\r\n        horizontalCenter: center,\r\n    });\r\n    // all these tweens depends on annotations now (t instead of progress)\r\n    const zoom = tweenProp(prev.zoom, next.zoom, progress);\r\n    const dx = tweenProp(prev.dx, next.dx, progress);\r\n    const dy = tweenProp(prev.dy, next.dy, progress, codeStep.verticalInterval);\r\n    const focusHeight = tweenProp(prev.focusHeight, next.focusHeight, progress);\r\n    const focusWidth = tweenProp(prev.focusWidth, next.focusWidth, progress);\r\n    const lineNumberPad = ((dimensions === null || dimensions === void 0 ? void 0 : dimensions.lineNumberWidth) || 0) * zoom;\r\n    const leftPad = lineNumberPad || 16;\r\n    const width = Math.max(focusWidth + leftPad, dimensions.contentWidth);\r\n    const startX = leftPad / zoom;\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Container, { width: dimensions.containerWidth, height: dimensions.containerHeight, lang: codeStep.lang },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Content$1, { dx: dx, dy: dy, scale: zoom, height: Math.max(focusHeight, dimensions.contentHeight), width: width }, children(focusWidth, startX))));\r\n}\r\nfunction Container({ width, height, children, lang, }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", { style: {\r\n            width,\r\n            height,\r\n            position: \"relative\",\r\n            overflow: \"auto\",\r\n        }, className: \"ch-code-scroll-parent\", children: children, \"data-ch-lang\": lang }));\r\n}\r\nfunction Content$1({ dx, dy, scale, height, width, children, }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: {\r\n            position: \"absolute\",\r\n            top: 0,\r\n            left: 0,\r\n            transformOrigin: \"top left\",\r\n            width: width,\r\n            height: height,\r\n            overflow: \"hidden\",\r\n        }, className: \"ch-code-scroll-content\" },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: {\r\n                position: \"absolute\",\r\n                top: 0,\r\n                left: 0,\r\n                transform: `translateX(${dx}px) translateY(${dy}px) scale(${scale})`,\r\n                transformOrigin: \"left top\",\r\n                width: width / scale,\r\n                height: (height - 2 * dy) / scale,\r\n                // outline: \"1px solid yellow\",\r\n            }, children: children })));\r\n}\r\nfunction getTweenContentProps(_a) {\r\n    var { codeStep } = _a, rest = __rest(_a, [\"codeStep\"]);\r\n    const { lineHeight, lineWidth } = rest.dimensions;\r\n    const paramTween = {\r\n        prev: {\r\n            extremes: [\r\n                codeStep.firstFocusedLineNumber.prev - 1,\r\n                codeStep.lastFocusedLineNumber.prev - 1,\r\n            ],\r\n            originalContentHeight: codeStep.lineCount.prev * lineHeight,\r\n            lineWidth: lineWidth[0],\r\n        },\r\n        next: {\r\n            extremes: [\r\n                codeStep.firstFocusedLineNumber.next - 1,\r\n                codeStep.lastFocusedLineNumber.next - 1,\r\n            ],\r\n            originalContentHeight: codeStep.lineCount.next * lineHeight,\r\n            lineWidth: lineWidth[1],\r\n        },\r\n    };\r\n    return map(paramTween, ({ extremes, originalContentHeight, lineWidth }) => getContentProps(Object.assign({ extremes,\r\n        originalContentHeight,\r\n        lineWidth }, rest)));\r\n}\r\nfunction getContentProps({ dimensions, lineWidth, minZoom, maxZoom, extremes, originalContentHeight, horizontalCenter, }) {\r\n    const { lineHeight } = dimensions;\r\n    const containerHeight = dimensions === null || dimensions === void 0 ? void 0 : dimensions.contentHeight;\r\n    const containerWidth = dimensions === null || dimensions === void 0 ? void 0 : dimensions.contentWidth;\r\n    const originalFocusHeight = (extremes[1] - extremes[0] + 3) * lineHeight;\r\n    const leftPadding = (dimensions === null || dimensions === void 0 ? void 0 : dimensions.lineNumberWidth) || 16;\r\n    const rightPadding = 16;\r\n    const zoom = Math.max(Math.min((containerWidth - leftPadding - rightPadding) /\r\n        lineWidth, containerHeight / originalFocusHeight, maxZoom), minZoom);\r\n    const contentHeight = originalContentHeight * zoom;\r\n    const focusStart = (extremes[0] - 1) * lineHeight * zoom;\r\n    const focusEnd = (extremes[1] + 2) * lineHeight * zoom;\r\n    const focusCenter = (focusEnd + focusStart) / 2;\r\n    const focusHeight = focusEnd - focusStart;\r\n    const dy = containerHeight > contentHeight\r\n        ? (containerHeight - contentHeight) / 2\r\n        : clamp$1(containerHeight / 2 - focusCenter, Math.max(containerHeight - contentHeight, -focusStart // to ensure first focus line is shown when focus is bigger than container\r\n        ), 0);\r\n    const dx = horizontalCenter\r\n        ? Math.max(containerWidth / 2 - (lineWidth * zoom) / 2, 0)\r\n        : 0;\r\n    return {\r\n        zoom,\r\n        dx,\r\n        dy,\r\n        focusHeight: focusHeight,\r\n        focusWidth: lineWidth * zoom,\r\n    };\r\n}\r\nfunction clamp$1(num, min, max) {\r\n    return num <= min ? min : num >= max ? max : num;\r\n}\r\nfunction tweenProp(start, end, progress, interval = [0, 1]) {\r\n    return tween$1({\r\n        fixed: false,\r\n        interval,\r\n        extremes: [start, end],\r\n        ease: easing.easeInOutCubic,\r\n    }, progress);\r\n}\n\nfunction SmoothLines(props) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(SmoothContainer, Object.assign({}, props), (focusWidth, startX) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Lines, { codeStep: props.codeStep, focusWidth: focusWidth, lineHeight: props.dimensions.lineHeight, progress: props.progress, startX: startX, lineNumberWidth: props.dimensions.lineNumberWidth }))));\r\n}\r\nfunction Lines({ codeStep, progress, focusWidth, lineHeight, startX, lineNumberWidth, }) {\r\n    const groups = progress < 0.5\r\n        ? codeStep.groups.prev\r\n        : codeStep.groups.next;\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, groups.map((group, i) => {\r\n        if (!group.annotation) {\r\n            return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(LineGroup, { lines: group.lines, t: progress, focusWidth: focusWidth, lineHeight: lineHeight, startX: startX, key: i, lineNumberWidth: lineNumberWidth }));\r\n        }\r\n        const startY = tween$1(group.lines[0].tweenY, progress);\r\n        const lineCount = group.annotation.lineNumbers.end -\r\n            group.annotation.lineNumbers.start +\r\n            1;\r\n        const Component = group.annotation.Component;\r\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, { style: {\r\n                position: \"absolute\",\r\n                height: lineCount * lineHeight,\r\n                width: \"100%\",\r\n                transform: `translateY(${startY * lineHeight}px)`,\r\n            }, key: i, data: group.annotation.data, isInline: false, lines: group.lines },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(LineGroup, { lines: group.lines, t: progress, focusWidth: focusWidth, lineHeight: lineHeight, startY: startY, startX: startX, lineNumberWidth: lineNumberWidth })));\r\n    })));\r\n}\r\nfunction LineGroup({ lines, focusWidth, lineHeight, t, startX, startY = 0, lineNumberWidth, }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, lines.map((line, key) => {\r\n        const { tweenX, tweenY, focused } = line;\r\n        const dx = tween$1(tweenX, t);\r\n        const dy = tween$1(tweenY, t);\r\n        const opacity = getOpacity(focused, t, dx);\r\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, { key: key },\r\n            lineNumberWidth ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"ch-code-line-number\", style: {\r\n                    position: \"absolute\",\r\n                    top: 0,\r\n                    left: 0,\r\n                    transform: `translate(${dx * focusWidth}px, ${(dy - startY) * lineHeight}px)`,\r\n                    width: lineNumberWidth,\r\n                    opacity,\r\n                } }, t < 0.5\r\n                ? line.lineNumber.prev\r\n                : line.lineNumber.next)) : undefined,\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(LineContainer, { dx: startX + dx * focusWidth, dy: (dy - startY) * lineHeight, width: focusWidth, opacity: opacity },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(LineContent, { line: line, progress: t, dx: dx }))));\r\n    })));\r\n}\r\nfunction LineContent({ line, progress, dx, }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: {\r\n            display: \"inline-block\",\r\n            width: \"100%\",\r\n        } },\r\n        line.annotatedGroups.map((annotatedGroup, i) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(AnnotatedTokens, { annotatedGroup: annotatedGroup, progress: progress, dx: dx, key: i }))),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"br\", null)));\r\n}\r\nfunction AnnotatedTokens({ annotatedGroup, progress, dx, }) {\r\n    var _a, _b;\r\n    const annotated = progress < 0.5\r\n        ? annotatedGroup.prev\r\n        : annotatedGroup.next;\r\n    const tokenGroups = (annotated === null || annotated === void 0 ? void 0 : annotated.groups) || [];\r\n    const Component = (_a = annotated === null || annotated === void 0 ? void 0 : annotated.annotation) === null || _a === void 0 ? void 0 : _a.Component;\r\n    const children = tokenGroups.map((group, i) => {\r\n        const opacity = getOpacity(group.focused, progress, dx);\r\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { style: { opacity }, key: i + 1 }, group.element));\r\n    });\r\n    return Component ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, { children: children, data: (_b = annotated === null || annotated === void 0 ? void 0 : annotated.annotation) === null || _b === void 0 ? void 0 : _b.data, isInline: true })) : (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children));\r\n}\r\nfunction LineContainer({ children, dx, dy, opacity, width, }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: {\r\n            position: \"absolute\",\r\n            top: 0,\r\n            left: 0,\r\n            transform: `translate(${dx}px, ${dy}px)`,\r\n            width,\r\n            display: opacity <= 0 ? \"none\" : undefined,\r\n        } }, children));\r\n}\r\nconst OFF_OPACITY = 0.33;\r\nfunction getOpacity(focused, progress, dx) {\r\n    return (tween$1({\r\n        fixed: false,\r\n        extremes: [\r\n            focused.prev ? 0.99 : OFF_OPACITY,\r\n            focused.next ? 0.99 : OFF_OPACITY,\r\n        ],\r\n        interval: [0, 1],\r\n    }, progress) -\r\n        Math.abs(dx) * 1);\r\n}\n\nfunction CopyButton({ content, style, className, }) {\r\n    const [copied, setCopied] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { type: \"button\", title: \"Copy code\", className: className, style: style, onClick: () => {\r\n            copyToClipboard(content);\r\n            setCopied(true);\r\n            setTimeout(() => {\r\n                setCopied(false);\r\n            }, 1200);\r\n        } },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", xmlns: \"http://www.w3.org/2000/svg\" }, copied ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: 2, d: \"M5 13l4 4L19 7\" })) : (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: \"1.6px\", d: \"M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\" })))));\r\n}\r\nfunction copyToClipboard(text) {\r\n    if (!navigator.clipboard) {\r\n        fallbackCopyTextToClipboard(text);\r\n        return;\r\n    }\r\n    navigator.clipboard.writeText(text);\r\n}\r\nfunction fallbackCopyTextToClipboard(text) {\r\n    var textArea = document.createElement(\"textarea\");\r\n    textArea.value = text;\r\n    // Avoid scrolling to bottom\r\n    textArea.style.top = \"0\";\r\n    textArea.style.left = \"0\";\r\n    textArea.style.position = \"fixed\";\r\n    document.body.appendChild(textArea);\r\n    textArea.focus();\r\n    textArea.select();\r\n    try {\r\n        var successful = document.execCommand(\"copy\");\r\n        // var msg = successful ? \"successful\" : \"unsuccessful\"\r\n        // console.log(\"Fallback: Copying text command was \" + msg)\r\n    }\r\n    catch (err) {\r\n        // console.error(\"Fallback: Oops, unable to copy\", err)\r\n    }\r\n    document.body.removeChild(textArea);\r\n}\n\nfunction useCodeShift({ tween, }) {\r\n    return useStepParser({\r\n        highlightedLines: map(tween, tween => tween.code.lines),\r\n        focus: map(tween, tween => tween.focus),\r\n        annotations: map(tween, tween => tween.annotations),\r\n        lang: anyValue(tween, tween => { var _a; return (_a = tween === null || tween === void 0 ? void 0 : tween.code) === null || _a === void 0 ? void 0 : _a.lang; }),\r\n    });\r\n}\r\nconst DEFAULT_MIN_COLUMNS = 10;\r\nfunction CodeTween(_a) {\r\n    var { tween, progress, config } = _a, preProps = __rest(_a, [\"tween\", \"progress\", \"config\"]);\r\n    const stepInfo = useCodeShift({ tween });\r\n    const { element, dimensions } = useDimensions(stepInfo.code, map(tween, tween => tween.focus), config.minColumns || DEFAULT_MIN_COLUMNS, config.lineNumbers || false, config.rows, [config.parentHeight]);\r\n    return !dimensions || config.debug ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(BeforeDimensions, { element: element, htmlProps: preProps, debug: config.debug })) : (react__WEBPACK_IMPORTED_MODULE_0__.createElement(AfterDimensions, { dimensions: dimensions, stepInfo: stepInfo, config: config, progress: progress, htmlProps: preProps }));\r\n}\r\nfunction BeforeDimensions({ element, htmlProps, debug, }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wrapper, { htmlProps: htmlProps, measured: false }, element));\r\n}\r\nfunction AfterDimensions({ config: { minZoom = 1, maxZoom = 1, horizontalCenter = false, }, dimensions, stepInfo, progress, htmlProps, config, }) {\r\n    var _a;\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wrapper, { htmlProps: htmlProps, measured: true },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(SmoothLines, { codeStep: stepInfo, progress: progress, dimensions: dimensions, \r\n            // TODO move to dimensions?\r\n            minZoom: minZoom, maxZoom: maxZoom, center: horizontalCenter }),\r\n        config.showCopyButton ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CopyButton, { className: \"ch-code-button\", content: (_a = stepInfo === null || stepInfo === void 0 ? void 0 : stepInfo.code) === null || _a === void 0 ? void 0 : _a.prev })) : undefined));\r\n}\r\nfunction Wrapper({ htmlProps, children, measured, }) {\r\n    return (\r\n    // not using <pre> because https://github.com/code-hike/codehike/issues/120\r\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({}, htmlProps, { className: `ch-code-wrapper ${(htmlProps === null || htmlProps === void 0 ? void 0 : htmlProps.className) || \"\"}`, \"data-ch-measured\": measured, children: children })));\r\n}\n\nfunction currentTime() {\n  if (typeof window !== \"undefined\") {\n    return performance.now();\n  } else {\n    return 0;\n  }\n}\n\nfunction useSpringInstance(target, config) {\n  var ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n\n  if (ref.current == null) {\n    ref.current = {\n      config: getConfigWithDefaults(target, config),\n      state: getInitialState(target, config)\n    };\n  }\n\n  return ref.current;\n}\nfunction getConfigWithDefaults(target, _ref) {\n  var stiffness = _ref.stiffness,\n      damping = _ref.damping,\n      mass = _ref.mass,\n      decimals = _ref.decimals,\n      teleport = _ref.teleport;\n  return {\n    X: target,\n    k: stiffness !== null && stiffness !== void 0 ? stiffness : 170,\n    c: damping !== null && damping !== void 0 ? damping : 26,\n    m: mass !== null && mass !== void 0 ? mass : 1,\n    teleport: teleport !== null && teleport !== void 0 ? teleport : false,\n    decimals: decimals !== null && decimals !== void 0 ? decimals : 2\n  };\n}\n\nfunction getInitialState(target, _ref2) {\n  var from = _ref2.from,\n      initialSpeed = _ref2.initialSpeed;\n  return {\n    x0: from !== null && from !== void 0 ? from : target,\n    v0: initialSpeed !== null && initialSpeed !== void 0 ? initialSpeed : 0,\n    t0: currentTime(),\n    raf: null\n  };\n}\n\nvar sqrt = Math.sqrt,\n    exp = Math.exp,\n    sin = Math.sin,\n    cos = Math.cos;\nfunction spring(_ref) {\n  var x0 = _ref.x0,\n      v0 = _ref.v0,\n      t0 = _ref.t0,\n      t = _ref.t,\n      k = _ref.k,\n      c = _ref.c,\n      m = _ref.m,\n      X = _ref.X;\n  var dx = x0 - X;\n  var dt = (t - t0) / 1000;\n  var radicand = c * c - 4 * k * m;\n\n  if (radicand > 0) {\n    var rp = (-c + sqrt(radicand)) / (2 * m);\n    var rn = (-c - sqrt(radicand)) / (2 * m);\n    var a = (dx * rp - v0) / (rp - rn);\n    var b = (v0 - dx * rn) / (rp - rn);\n    return {\n      x: X + a * exp(rn * dt) + b * exp(rp * dt),\n      v: a * rn * exp(rn * dt) + b * rp * exp(rp * dt)\n    };\n  } else if (radicand < 0) {\n    var r = -c / (2 * m);\n    var s = sqrt(-radicand) / (2 * m);\n    var _a = dx;\n\n    var _b = (v0 - r * dx) / s;\n\n    return {\n      x: X + exp(r * dt) * (_a * cos(s * dt) + _b * sin(s * dt)),\n      v: exp(r * dt) * ((_b * s + _a * r) * cos(s * dt) - (_a * s - _b * r) * sin(s * dt))\n    };\n  } else {\n    var _r = -c / (2 * m);\n\n    var _a2 = dx;\n\n    var _b2 = v0 - _r * dx;\n\n    return {\n      x: X + (_a2 + _b2 * dt) * exp(_r * dt),\n      v: (_b2 + _a2 * _r + _b2 * _r * dt) * exp(_r * dt)\n    };\n  }\n}\n\nvar nextFrameQueue = [];\nvar nextFrameId = null;\nfunction queueAnimationFrame(fn) {\n  var length = nextFrameQueue.push(fn);\n\n  if (length === 1) {\n    nextFrameId = requestAnimationFrame(runQueue);\n  }\n\n  return [nextFrameId, length - 1];\n}\nfunction unqueueAnimationFrame(_ref) {\n  var frameId = _ref[0],\n      index = _ref[1];\n\n  if (frameId === nextFrameId) {\n    delete nextFrameQueue[index];\n  }\n}\n\nfunction runQueue() {\n  var now = currentTime();\n  var queue = nextFrameQueue;\n  nextFrameQueue = [];\n  (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(function () {\n    return queue.forEach(function (task) {\n      return task && task(now);\n    });\n  });\n}\n\nvar useLayoutEffect$3 = typeof window !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useSpring(target, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(),\n      forceUpdate = _React$useState[1];\n\n  var newConfig = getConfigWithDefaults(target, config);\n\n  var _useSpringInstance = useSpringInstance(target, config),\n      state = _useSpringInstance.state,\n      oldConfig = _useSpringInstance.config; // TODO all springs should use the same t in the same frame\n\n\n  var t = currentTime();\n  var x0 = state.x0,\n      v0 = state.v0,\n      t0 = state.t0;\n  var k = oldConfig.k,\n      c = oldConfig.c,\n      m = oldConfig.m,\n      X = oldConfig.X;\n\n  var _ref = newConfig.teleport ? {\n    x: X,\n    v: 0\n  } : spring({\n    x0: x0,\n    v0: v0,\n    t0: t0,\n    t: t,\n    k: k,\n    c: c,\n    m: m,\n    X: X\n  }),\n      x = _ref.x,\n      v = _ref.v;\n\n  var moving = isMoving(x, v, t, newConfig);\n  useLayoutEffect$3(function () {\n    Object.assign(oldConfig, newConfig);\n  }, [newConfig.X, newConfig.k, newConfig.c, newConfig.m, newConfig.teleport]);\n  useLayoutEffect$3(function () {\n    state.x0 = x;\n    state.v0 = v;\n    state.t0 = t;\n  }, [x, v, t]);\n  useLayoutEffect$3(function () {\n    var loop = function loop(now) {\n      var x0 = state.x0,\n          v0 = state.v0,\n          t0 = state.t0;\n      var k = oldConfig.k,\n          c = oldConfig.c,\n          m = oldConfig.m,\n          X = oldConfig.X,\n          decimals = oldConfig.decimals;\n\n      var _spring = spring({\n        x0: x0,\n        v0: v0,\n        t0: t0,\n        t: now,\n        k: k,\n        c: c,\n        m: m,\n        X: X\n      }),\n          nextX = _spring.x;\n\n      if (roundTo(nextX, decimals) !== roundTo(x0, decimals)) {\n        state.raf = null;\n        forceUpdate(now);\n      } else {\n        state.raf = queueAnimationFrame(loop);\n      }\n    };\n\n    if (moving && state.raf == null) {\n      state.raf = queueAnimationFrame(loop);\n    } else if (!moving && state.raf != null) {\n      unqueueAnimationFrame(state.raf);\n      state.raf = null;\n    }\n  });\n  useLayoutEffect$3(function () {\n    return function () {\n      if (state.raf != null) {\n        unqueueAnimationFrame(state.raf);\n      }\n    };\n  }, []);\n  return [roundTo(x, newConfig.decimals), moving];\n}\n\nfunction isMoving(x, v, t, _ref2) {\n  var decimals = _ref2.decimals,\n      X = _ref2.X,\n      k = _ref2.k,\n      c = _ref2.c,\n      m = _ref2.m;\n\n  if (roundTo(x, decimals) !== roundTo(X, decimals)) {\n    return true;\n  }\n\n  var nextT = t + 0.016;\n\n  var _spring2 = spring({\n    x0: x,\n    v0: v,\n    t0: t,\n    t: nextT,\n    k: k,\n    c: c,\n    m: m,\n    X: X\n  }),\n      nextX = _spring2.x;\n\n  return roundTo(nextX, decimals) !== roundTo(X, decimals);\n}\n\nfunction roundTo(x, decimals) {\n  var p = Math.pow(10, decimals);\n  return Math.round(x * p) / p;\n}\n\nconst defaultSpring$1 = {\r\n    stiffness: 120,\r\n    damping: 24,\r\n    mass: 0.2,\r\n    decimals: 3,\r\n};\r\nfunction CodeSpring(_a) {\r\n    var { step, config } = _a, htmlProps = __rest(_a, [\"step\", \"config\"]);\r\n    const { tween, t } = useStepSpring$1(step, config.spring);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CodeTween, Object.assign({ tween: tween, progress: t, config: config }, htmlProps)));\r\n}\r\nfunction useStepSpring$1(step, springConfig = defaultSpring$1) {\r\n    const [{ target, steps, index }, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\r\n        target: 2,\r\n        steps: [step, step, step],\r\n        index: 0,\r\n    });\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        const lastStep = steps[steps.length - 1];\r\n        if (lastStep != step) {\r\n            setState(s => updateStepSpring$1(s, step, progress));\r\n        }\r\n    }, [step]);\r\n    const [progress] = useSpring(target, springConfig);\r\n    const trioProgress = progress - index;\r\n    const result = trioProgress <= 1\r\n        ? {\r\n            tween: { prev: steps[0], next: steps[1] },\r\n            t: trioProgress,\r\n        }\r\n        : {\r\n            tween: { prev: steps[1], next: steps[2] },\r\n            t: trioProgress - 1,\r\n        };\r\n    return result;\r\n}\r\nfunction updateStepSpring$1(state, newStep, progress) {\r\n    const { steps, target, index } = state;\r\n    const stepsClone = steps.slice();\r\n    const trioProgress = progress - index;\r\n    if (trioProgress < 1) {\r\n        stepsClone[2] = newStep;\r\n        return Object.assign(Object.assign({}, state), { steps: stepsClone });\r\n    }\r\n    else {\r\n        stepsClone[0] = steps[1];\r\n        stepsClone[1] = steps[2];\r\n        stepsClone[2] = newStep;\r\n        return Object.assign(Object.assign({}, state), { steps: stepsClone, target: target + 1, index: index + 1 });\r\n    }\r\n}\n\nconst MiniFrame = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (_a, ref) {\r\n    var { title, children, titleBar, zoom = 1, overflow } = _a, props = __rest(_a, [\"title\", \"children\", \"titleBar\", \"zoom\", \"overflow\"]);\r\n    const bar = titleBar || react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultTitleBar, { title: title });\r\n    const zoomStyle = {\r\n        \"--ch-frame-zoom\": zoom,\r\n        overflow,\r\n    };\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({}, props, { ref: ref }),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-title-bar\" }, bar),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-content\" },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-zoom\", style: zoomStyle }, children)))));\r\n});\r\nreact__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (_a, ref) {\r\n    var { title, children, titleBar, overflow } = _a, props = __rest(_a, [\"title\", \"children\", \"titleBar\", \"overflow\"]);\r\n    const bar = titleBar || react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultTitleBar, { title: title });\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({}, props, { ref: ref }),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-simple-frame\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-title-bar\" }, bar),\r\n            children)));\r\n});\r\nfunction DefaultTitleBar({ title }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-left-bar\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(FrameButtons, null)),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-middle-bar\" }, title),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-right-bar\" })));\r\n}\r\nfunction FrameButtons() {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-buttons\" },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-button ch-frame-button-left\" }),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-button-space\" }),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-button ch-frame-button-middle\" }),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-button-space\" }),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-button ch-frame-button-right\" })));\r\n}\n\nconst EditorFrame = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function InnerEditorFrame(_a, ref) {\r\n    var _b;\r\n    var { northPanel, southPanel, terminalPanel, style, height, northButton, southButton, className, onTabClick } = _a, rest = __rest(_a, [\"northPanel\", \"southPanel\", \"terminalPanel\", \"style\", \"height\", \"northButton\", \"southButton\", \"className\", \"onTabClick\"]);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({ ref: ref }, rest, { className: \"ch-editor-frame\", style: style }),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-title-bar\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(TabsContainer, { tabs: northPanel.tabs, showFrameButtons: true, button: northButton, panel: \"north\", onTabClick: onTabClick })),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { \"data-ch-panel\": \"north\", style: northPanel.style, children: northPanel.children }),\r\n        southPanel && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-frame-title-bar\", style: {\r\n                    transform: (_b = southPanel.style) === null || _b === void 0 ? void 0 : _b.transform,\r\n                } },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(TabsContainer, { tabs: southPanel.tabs, showFrameButtons: false, button: southButton, topBorder: true, panel: \"south\", onTabClick: onTabClick })),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { \"data-ch-panel\": \"south\", children: southPanel.children, style: southPanel.style })))));\r\n});\r\nfunction TabsContainer({ tabs, button, showFrameButtons, topBorder, panel, onTabClick, }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        topBorder && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-editor-group-border\" })),\r\n        showFrameButtons ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(FrameButtons, null) : react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null),\r\n        tabs.map(({ title, active, style }) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: title, title: title, \"data-ch-tab\": panel, \"data-active\": active, className: \"ch-editor-tab\", style: style, onClick: onTabClick && (() => onTabClick(title)) },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(TabTitle, { title: title })))),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: { flex: 1, minWidth: \"0.8em\" } }),\r\n        button));\r\n}\r\nfunction TabTitle({ title }) {\r\n    if (!title) {\r\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null);\r\n    }\r\n    const separatorIndex = title.lastIndexOf(\"/\") + 1;\r\n    const filename = title.substring(separatorIndex);\r\n    const folder = title.substring(0, separatorIndex);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { style: { opacity: 0.5 } }, folder),\r\n        filename));\r\n}\n\nfunction getCommands(text) {\r\n    const [, ...lines] = text.split(/^\\$\\s*/gm);\r\n    const commands = lines.map((c) => {\r\n        const [run, ...outputLines] = c.split(/\\r?\\n/);\r\n        return {\r\n            run,\r\n            output: outputLines.length > 0 ? outputLines.join(\"\\n\") : null,\r\n        };\r\n    });\r\n    const lastCommand = commands[commands.length - 1];\r\n    const isRunning = commands.length > 0 && lastCommand.output != null;\r\n    const title = isRunning ? lastCommand.run.split(/(\\s+)/)[0] : \"bash\";\r\n    return {\r\n        title,\r\n        isRunning,\r\n        commands,\r\n    };\r\n}\n\nconst prompt = react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"ch-terminal-prompt\" }, \"$\");\r\nfunction TerminalContent({ text, progress = 1, style, }) {\r\n    const commands = parse(text, progress);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pre\", { style: style, className: \"ch-terminal-content\" }, commands.map(({ run, output }, i) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, { key: i },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null,\r\n            prompt,\r\n            \" \",\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, run)),\r\n        output && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-terminal-output\" }, output)))))));\r\n}\r\nfunction parse(text, progress) {\r\n    if (!text)\r\n        return [];\r\n    const chars = Math.round(text.length * progress);\r\n    const { commands } = getCommands(text.slice(0, chars));\r\n    return commands;\r\n}\n\nfunction InnerTerminalTransition({ prev = \"\", prevKey, next = \"\", nextKey, progress, }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-terminal\" },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: {\r\n                position: \"relative\",\r\n                transform: `translateY(-${progress * 100}%)`,\r\n            } },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(TerminalContent, { text: prev, progress: 1, key: prevKey }),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(TerminalContent, { style: { position: \"absolute\" }, text: next, progress: progress, key: nextKey }))));\r\n}\n\nfunction InnerTerminalTransitions({ steps, progress, }) {\r\n    const textSteps = steps.map((s) => s.text);\r\n    const stepProgress = progress % 1;\r\n    const prevIndex = clamp(Math.floor(progress), 0, steps.length - 1);\r\n    const nextIndex = prevIndex + 1;\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerTerminalTransition, { prev: textSteps[prevIndex], prevKey: prevIndex, next: textSteps[nextIndex] || \"\", nextKey: nextIndex, progress: stepProgress }));\r\n}\r\nfunction clamp(x, min, max) {\r\n    return Math.min(Math.max(x, min), max);\r\n}\n\nfunction TerminalPanel({ prev, next, t, backward, }) {\r\n    const height = getHeight({ prev, next, t, backward });\r\n    return !height ? null : (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-editor-terminal\", style: { height } },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-editor-terminal-tab\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, \"Terminal\")),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-editor-terminal-content\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerTerminalTransitions, { steps: [\r\n                    { text: prev || \"\" },\r\n                    { text: next || \"\" },\r\n                ], progress: t }),\r\n            \")\")));\r\n}\r\nfunction getHeight({ prev, next, t, backward, }) {\r\n    if (!prev && !next)\r\n        return 0;\r\n    if (!prev && next)\r\n        return MAX_HEIGHT * Math.min(t * 4, 1);\r\n    if (prev && !next)\r\n        return MAX_HEIGHT * Math.max(1 - t * 4, 0);\r\n    return MAX_HEIGHT;\r\n}\r\nconst MAX_HEIGHT = 150;\n\nfunction northConfig(codeConfig) {\r\n    if (Array.isArray(codeConfig.rows)) {\r\n        return Object.assign(Object.assign({}, codeConfig), { rows: codeConfig.rows[0] });\r\n    }\r\n    return codeConfig;\r\n}\r\nfunction southConfig(codeConfig) {\r\n    if (Array.isArray(codeConfig.rows)) {\r\n        return Object.assign(Object.assign({}, codeConfig), { rows: codeConfig.rows[1] });\r\n    }\r\n    return codeConfig;\r\n}\r\nfunction useTransition(ref, prev, next, t, backward, codeConfig) {\r\n    // prevSnapshot has the dimensions of the editor for t=0\r\n    // nextSnapshot has the dimensions of the editor for t=1\r\n    const { prevSnapshot, nextSnapshot } = useSnapshots(ref, prev, next);\r\n    // we return the default styles for t=0 until we measure the dimensions\r\n    if (!prevSnapshot) {\r\n        return startingPosition(prev, next, codeConfig);\r\n    }\r\n    // and the same for t=1\r\n    if (!nextSnapshot) {\r\n        return endingPosition(prev, next, codeConfig);\r\n    }\r\n    // TODO this should be commented\r\n    // if (t === 0) {\r\n    //   return startingPosition(prev, next, codeConfig)\r\n    // }\r\n    if (t === 1) {\r\n        return endingPosition(prev, next, codeConfig);\r\n    }\r\n    const inputSouthPanel = prev.southPanel || next.southPanel;\r\n    const { prevNorthFile, prevSouthFile, nextNorthFile, nextSouthFile, } = getStepFiles(prev, next, t == 0 || backward);\r\n    const { northStyle, southStyle } = getPanelStyles(prevSnapshot, nextSnapshot, t);\r\n    const { northTabs, southTabs } = getTabs(prevSnapshot, nextSnapshot, prevNorthFile.name, prevSouthFile === null || prevSouthFile === void 0 ? void 0 : prevSouthFile.name, t);\r\n    return {\r\n        northContent: getContentFromFile(nextNorthFile),\r\n        northPanel: {\r\n            tabs: northTabs,\r\n            style: northStyle,\r\n            children: (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CodeTransition, { codeConfig: northConfig(codeConfig), prevFile: prevNorthFile, nextFile: nextNorthFile, t: t, parentHeight: (northStyle.height ||\r\n                    northStyle.minHeight) })),\r\n        },\r\n        southContent: getContentFromFile(nextSouthFile),\r\n        southPanel: inputSouthPanel && {\r\n            tabs: southTabs,\r\n            style: southStyle,\r\n            children: (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CodeTransition, { codeConfig: southConfig(codeConfig), prevFile: prevSouthFile, nextFile: nextSouthFile, t: t, parentHeight: ((southStyle === null || southStyle === void 0 ? void 0 : southStyle.height) ||\r\n                    (southStyle === null || southStyle === void 0 ? void 0 : southStyle.minHeight)) })),\r\n        },\r\n    };\r\n}\r\n// Returns the t=0 state of the transition\r\nfunction startingPosition(prev, next, codeConfig) {\r\n    const inputNorthPanel = prev.northPanel;\r\n    const inputSouthPanel = prev.southPanel;\r\n    const { prevNorthFile, prevSouthFile, nextNorthFile, nextSouthFile, } = getStepFiles(prev, next, true);\r\n    return {\r\n        northContent: getContentFromFile(prevNorthFile),\r\n        northPanel: {\r\n            tabs: inputNorthPanel.tabs.map(title => ({\r\n                title,\r\n                active: title === inputNorthPanel.active,\r\n                style: {},\r\n            })),\r\n            style: {\r\n                flexGrow: 1,\r\n                overflow: \"hidden\",\r\n            },\r\n            children: (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CodeTransition, { codeConfig: northConfig(codeConfig), prevFile: prevNorthFile, nextFile: prevNorthFile, t: 0, parentHeight: \"0\" })),\r\n        },\r\n        southContent: getContentFromFile(prevSouthFile),\r\n        southPanel: inputSouthPanel && {\r\n            tabs: inputSouthPanel.tabs.map(title => ({\r\n                title,\r\n                active: title === inputSouthPanel.active,\r\n                style: {},\r\n            })),\r\n            style: {\r\n                flexGrow: 1,\r\n                overflow: \"hidden\",\r\n            },\r\n            children: (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CodeTransition, { codeConfig: southConfig(codeConfig), prevFile: prevSouthFile, nextFile: prevSouthFile, t: 0, parentHeight: \"0\" })),\r\n        },\r\n    };\r\n}\r\n// Returns the t=1 state of the transition\r\nfunction endingPosition(prev, next, codeConfig) {\r\n    var _a;\r\n    const inputNorthPanel = next.northPanel;\r\n    const inputSouthPanel = next.southPanel;\r\n    let { prevNorthFile, prevSouthFile, nextNorthFile, nextSouthFile, } = getStepFiles(prev, next, false);\r\n    // getStepFiles return the intermediate files, we need to patch the ending state (2to1south)\r\n    const isTwoToOneSouth = !inputSouthPanel &&\r\n        inputNorthPanel.active === ((_a = prev === null || prev === void 0 ? void 0 : prev.southPanel) === null || _a === void 0 ? void 0 : _a.active);\r\n    if (isTwoToOneSouth) {\r\n        nextNorthFile = nextSouthFile;\r\n    }\r\n    return {\r\n        northContent: getContentFromFile(nextNorthFile),\r\n        northPanel: {\r\n            tabs: inputNorthPanel.tabs.map(title => ({\r\n                title,\r\n                active: title === inputNorthPanel.active,\r\n                style: {},\r\n            })),\r\n            style: {\r\n                flexGrow: 1,\r\n                overflow: \"hidden\",\r\n            },\r\n            children: (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CodeTransition, { codeConfig: northConfig(codeConfig), prevFile: nextNorthFile, nextFile: nextNorthFile, t: 1, parentHeight: \"1\" })),\r\n        },\r\n        southContent: getContentFromFile(nextSouthFile),\r\n        southPanel: inputSouthPanel && {\r\n            tabs: inputSouthPanel.tabs.map(title => ({\r\n                title,\r\n                active: title === inputSouthPanel.active,\r\n                style: {},\r\n            })),\r\n            style: {\r\n                flexGrow: 1,\r\n                overflow: \"hidden\",\r\n            },\r\n            children: (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CodeTransition, { codeConfig: southConfig(codeConfig), prevFile: nextSouthFile, nextFile: nextSouthFile, t: 1, parentHeight: \"1\" })),\r\n        },\r\n    };\r\n}\r\nfunction CodeTransition({ prevFile, nextFile, t, codeConfig, parentHeight, }) {\r\n    var _a;\r\n    const htmlProps = Object.assign(Object.assign({}, codeConfig === null || codeConfig === void 0 ? void 0 : codeConfig.htmlProps), { style: Object.assign({ height: \"100%\" }, (_a = codeConfig === null || codeConfig === void 0 ? void 0 : codeConfig.htmlProps) === null || _a === void 0 ? void 0 : _a.style) });\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CodeTween, Object.assign({ progress: t, tween: { prev: prevFile, next: nextFile }, config: Object.assign(Object.assign({}, codeConfig), { parentHeight }) }, htmlProps)));\r\n}\r\nfunction getContentFromFile(file) {\r\n    return file ? codeToText(file.code) : \"\";\r\n}\r\n/**\r\n * Get the StepFiles for a transition\r\n * in each panel, if the prev and next active files are the same\r\n * we return the prev and next version of that panel\r\n * if the active files are different, we return the same file twice,\r\n * if backward is true we return the prev active file twice,\r\n * or else the next active file twice\r\n */\r\nfunction getStepFiles(prev, next, backward) {\r\n    var _a, _b;\r\n    // The active file in each panel before and after:\r\n    // +----+----+\r\n    // | pn | nn |\r\n    // +----+----+\r\n    // | ps | ns |\r\n    // +----+----+\r\n    //\r\n    const pn = prev.northPanel.active;\r\n    const nn = next.northPanel.active;\r\n    const ps = (_a = prev.southPanel) === null || _a === void 0 ? void 0 : _a.active;\r\n    const ns = (_b = next.southPanel) === null || _b === void 0 ? void 0 : _b.active;\r\n    const pnFile = prev.files.find(f => f.name === pn);\r\n    const nnFile = next.files.find(f => f.name === nn);\r\n    const psFile = ps\r\n        ? prev.files.find(f => f.name === ps)\r\n        : null;\r\n    const nsFile = ns\r\n        ? next.files.find(f => f.name === ns)\r\n        : null;\r\n    const oneToTwoSouth = !ps && pn === ns;\r\n    if (oneToTwoSouth) {\r\n        return {\r\n            prevNorthFile: nnFile,\r\n            nextNorthFile: nnFile,\r\n            prevSouthFile: pnFile,\r\n            nextSouthFile: nsFile,\r\n        };\r\n    }\r\n    const twoToOneSouth = !ns && nn === ps;\r\n    if (twoToOneSouth) {\r\n        return {\r\n            prevNorthFile: pnFile,\r\n            nextNorthFile: pnFile,\r\n            prevSouthFile: psFile,\r\n            nextSouthFile: nnFile,\r\n        };\r\n    }\r\n    const prevNorthFile = pn === nn ? pnFile : backward ? pnFile : nnFile;\r\n    const nextNorthFile = pn === nn ? nnFile : backward ? pnFile : nnFile;\r\n    const prevSouthFile = ps === ns\r\n        ? psFile\r\n        : backward\r\n            ? psFile || nsFile\r\n            : nsFile || psFile;\r\n    const nextSouthFile = ps === ns\r\n        ? nsFile\r\n        : backward\r\n            ? psFile || nsFile\r\n            : nsFile || psFile;\r\n    return {\r\n        prevNorthFile,\r\n        nextNorthFile,\r\n        prevSouthFile,\r\n        nextSouthFile,\r\n    };\r\n}\r\nfunction getPanelStyles(prev, next, t) {\r\n    // +---+---+\r\n    // | x | x |\r\n    // +---+---+\r\n    // |   |   |\r\n    // +---+---+\r\n    if (prev.southHeight === null &&\r\n        next.southHeight === null) {\r\n        return {\r\n            northStyle: {\r\n                minHeight: prev.northHeight,\r\n            },\r\n        };\r\n    }\r\n    // +---+---+\r\n    // | x | x |\r\n    // +---+---+\r\n    // | y |   |\r\n    // +---+---+\r\n    if (prev.southHeight !== null &&\r\n        next.southHeight === null &&\r\n        next.northKey !== prev.southKey) {\r\n        return {\r\n            northStyle: {\r\n                minHeight: tween(prev.northHeight, next.northHeight, t),\r\n            },\r\n            southStyle: {\r\n                minHeight: prev.southHeight,\r\n            },\r\n        };\r\n    }\r\n    // +---+---+\r\n    // | x | y |\r\n    // +---+---+\r\n    // | y |   |\r\n    // +---+---+\r\n    if (prev.southHeight !== null &&\r\n        next.southHeight === null &&\r\n        prev.southKey === next.northKey) {\r\n        return {\r\n            northStyle: {\r\n                minHeight: prev.northHeight,\r\n            },\r\n            southStyle: {\r\n                position: \"relative\",\r\n                minHeight: tween(prev.southHeight, next.northHeight, t),\r\n                transform: `translateY(${tween(0, -(prev.northHeight + prev.titleBarHeight), t)}px)`,\r\n            },\r\n        };\r\n    }\r\n    // +---+---+\r\n    // | x | x |\r\n    // +---+---+\r\n    // |   | y |\r\n    // +---+---+\r\n    if (prev.southHeight === null &&\r\n        next.southHeight !== null &&\r\n        prev.northKey !== next.southKey) {\r\n        return {\r\n            northStyle: {\r\n                minHeight: tween(prev.northHeight, next.northHeight, t),\r\n            },\r\n            southStyle: {\r\n                position: \"relative\",\r\n                minHeight: next.southHeight,\r\n            },\r\n        };\r\n    }\r\n    // +---+---+\r\n    // | y | x |\r\n    // +---+---+\r\n    // |   | y |\r\n    // +---+---+\r\n    if (prev.southHeight === null &&\r\n        next.southHeight !== null &&\r\n        prev.northKey === next.southKey) {\r\n        return {\r\n            northStyle: {\r\n                minHeight: next.northHeight,\r\n            },\r\n            southStyle: {\r\n                position: \"relative\",\r\n                minHeight: tween(prev.northHeight, next.southHeight, t),\r\n                transform: `translateY(${tween(-(next.northHeight + next.titleBarHeight), 0, t)}px)`,\r\n            },\r\n        };\r\n    }\r\n    // +---+---+\r\n    // | x | x |\r\n    // +---+---+\r\n    // | y | y |\r\n    // +---+---+\r\n    return {\r\n        northStyle: {\r\n            minHeight: tween(prev.northHeight, next.northHeight, t),\r\n        },\r\n        southStyle: {\r\n            minHeight: tween(prev.southHeight, next.southHeight, t),\r\n        },\r\n    };\r\n}\r\nfunction tween(a, b, t) {\r\n    return a + (b - a) * t;\r\n}\r\nfunction getTabs(prevSnapshot, nextSnapshot, northActive, southActive, t) {\r\n    // TODO simplify\r\n    if (!prevSnapshot.southTabs &&\r\n        isPresent(southActive, prevSnapshot.northTabs)) {\r\n        /// one to two south\r\n        return {\r\n            northTabs: getPanelTabs(nextSnapshot.northTabs, nextSnapshot.southTabs, prevSnapshot.southTabs, prevSnapshot.northTabs, northActive, t),\r\n            southTabs: getPanelTabs(nextSnapshot.southTabs, nextSnapshot.northTabs, prevSnapshot.northTabs, prevSnapshot.southTabs, southActive, t),\r\n        };\r\n    }\r\n    if (!nextSnapshot.southTabs &&\r\n        isPresent(southActive, nextSnapshot.northTabs)) {\r\n        /// two to one south\r\n        return {\r\n            northTabs: getPanelTabs(nextSnapshot.southTabs, nextSnapshot.northTabs, prevSnapshot.northTabs, prevSnapshot.southTabs, northActive, t),\r\n            southTabs: getPanelTabs(nextSnapshot.northTabs, nextSnapshot.southTabs, prevSnapshot.southTabs, prevSnapshot.northTabs, southActive, t),\r\n        };\r\n    }\r\n    return {\r\n        northTabs: getPanelTabs(nextSnapshot.northTabs, nextSnapshot.southTabs, prevSnapshot.northTabs, prevSnapshot.southTabs, northActive, t),\r\n        southTabs: getPanelTabs(nextSnapshot.southTabs, nextSnapshot.northTabs, prevSnapshot.southTabs, prevSnapshot.northTabs, southActive, t),\r\n    };\r\n}\r\nfunction getPanelTabs(nextSnapshot, otherNextSnapshot, prevSnapshot, otherPrevSnapshot, active, t) {\r\n    // For each tab bar there are four types of tabs\r\n    // - oldTabs: tabs that are present in both prev and next versions of the bar\r\n    // - totallyNewTabs: tabs that are totally new (present in next\r\n    // but not in any prev)\r\n    // - migratingTabs: tabs that are come from the other bar (present\r\n    // in next and in otherPrev)\r\n    // - disappearingTabs: present in prev but not in next or otherNext\r\n    const oldTabs = !nextSnapshot\r\n        ? []\r\n        : Object.keys(nextSnapshot)\r\n            .filter(filename => isPresent(filename, prevSnapshot) ||\r\n            !prevSnapshot)\r\n            .map(filename => {\r\n            const prev = prevSnapshot && prevSnapshot[filename];\r\n            const next = nextSnapshot[filename];\r\n            const dx = prev\r\n                ? prev.left + (next.left - prev.left) * t\r\n                : next.left;\r\n            const width = prev\r\n                ? prev.width + (next.width - prev.width) * t\r\n                : next.width;\r\n            return {\r\n                active: filename === active,\r\n                title: filename,\r\n                style: {\r\n                    position: \"absolute\",\r\n                    transform: `translateX(${dx}px)`,\r\n                    width,\r\n                },\r\n            };\r\n        });\r\n    const totallyNewTabs = !nextSnapshot\r\n        ? []\r\n        : Object.keys(nextSnapshot)\r\n            .filter(filename => prevSnapshot &&\r\n            !isPresent(filename, prevSnapshot)\r\n        // && !isPresent(filename, otherPrevSnapshot)\r\n        )\r\n            .map(filename => {\r\n            const next = nextSnapshot[filename];\r\n            return {\r\n                active: filename === active,\r\n                title: filename,\r\n                style: {\r\n                    position: \"absolute\",\r\n                    transform: `translateX(${next.left}px)`,\r\n                    opacity: t,\r\n                    width: next.width,\r\n                },\r\n            };\r\n        });\r\n    !nextSnapshot\r\n        ? []\r\n        : Object.keys(nextSnapshot)\r\n            .filter(filename => isPresent(filename, otherPrevSnapshot))\r\n            .map(filename => {\r\n            const prev = otherPrevSnapshot[filename];\r\n            const next = nextSnapshot[filename];\r\n            const dx = next.left - prev.left;\r\n            return {\r\n                active: filename === active,\r\n                title: filename,\r\n                style: {\r\n                    position: \"absolute\",\r\n                    transform: `translateX(${dx}px)`,\r\n                },\r\n            };\r\n        });\r\n    const disappearingTabs = !prevSnapshot\r\n        ? []\r\n        : Object.keys(prevSnapshot)\r\n            .filter(filename => !isPresent(filename, nextSnapshot)\r\n        // && !isPresent(filename, otherNextSnapshot)\r\n        )\r\n            .map(filename => {\r\n            const prev = prevSnapshot[filename];\r\n            return {\r\n                active: filename === active,\r\n                title: filename,\r\n                style: {\r\n                    position: \"absolute\",\r\n                    opacity: 1 - t,\r\n                    transform: `translateX(${prev.left}px)`,\r\n                    width: prev.width,\r\n                },\r\n            };\r\n        });\r\n    return [\r\n        ...totallyNewTabs,\r\n        // ...migratingTabs,\r\n        ...oldTabs,\r\n        ...disappearingTabs,\r\n    ];\r\n}\r\nfunction isPresent(filename, snapshot) {\r\n    return snapshot && filename && filename in snapshot;\r\n}\r\n// snapshots\r\nconst useLayoutEffect$2 = typeof window !== \"undefined\"\r\n    ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect\r\n    : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\r\nfunction useSnapshots(ref, prev, next) {\r\n    const [{ prevSnapshot, nextSnapshot }, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\r\n        prevSnapshot: null,\r\n        nextSnapshot: null,\r\n    });\r\n    useLayoutEffect$2(() => {\r\n        if (prevSnapshot || nextSnapshot) {\r\n            setState({\r\n                prevSnapshot: null,\r\n                nextSnapshot: null,\r\n            });\r\n        }\r\n    }, [prev, next]);\r\n    useLayoutEffect$2(() => {\r\n        if (!prevSnapshot) {\r\n            const parent = ref.current;\r\n            setState(s => (Object.assign(Object.assign({}, s), { prevSnapshot: Object.assign(Object.assign({}, getPanelSnapshot(parent, prev)), getTabsSnapshot(parent, prev)) })));\r\n        }\r\n        else if (!nextSnapshot) {\r\n            const parent = ref.current;\r\n            setState(s => (Object.assign(Object.assign({}, s), { nextSnapshot: Object.assign(Object.assign({}, getPanelSnapshot(parent, next)), getTabsSnapshot(parent, next)) })));\r\n        }\r\n    });\r\n    return { prevSnapshot, nextSnapshot };\r\n}\r\nfunction getPanelSnapshot(parent, step) {\r\n    var _a;\r\n    const northElement = parent.querySelector(\"[data-ch-panel='north']\");\r\n    const southElement = parent.querySelector(\"[data-ch-panel='south']\");\r\n    const bar = parent.querySelector(\".ch-frame-title-bar\");\r\n    return {\r\n        titleBarHeight: bar.getBoundingClientRect().height,\r\n        northHeight: northElement.getBoundingClientRect().height,\r\n        northKey: step.northPanel.active,\r\n        southHeight: (southElement === null || southElement === void 0 ? void 0 : southElement.getBoundingClientRect().height) || null,\r\n        southKey: (_a = step.southPanel) === null || _a === void 0 ? void 0 : _a.active,\r\n    };\r\n}\r\nfunction getTabsSnapshot(parent, step) {\r\n    var _a;\r\n    const northTabs = Array.from(parent.querySelectorAll(\"[data-ch-tab='north']\"));\r\n    const southTabs = Array.from(parent.querySelectorAll(\"[data-ch-tab='south']\"));\r\n    return {\r\n        northTabs: getTabsDimensions(northTabs, step.northPanel.active),\r\n        southTabs: getTabsDimensions(southTabs, (_a = step.southPanel) === null || _a === void 0 ? void 0 : _a.active),\r\n    };\r\n}\r\nfunction getTabsDimensions(tabElements, active) {\r\n    if (!tabElements[0]) {\r\n        return null;\r\n    }\r\n    const parent = tabElements[0].parentElement;\r\n    const parentLeft = parent.getBoundingClientRect().left;\r\n    const dimensions = {};\r\n    tabElements.forEach(child => {\r\n        const filename = child.getAttribute(\"title\");\r\n        const rect = child.getBoundingClientRect();\r\n        dimensions[filename] = {\r\n            left: rect.left - parentLeft,\r\n            width: rect.width,\r\n            active: filename === active,\r\n        };\r\n    });\r\n    return dimensions;\r\n}\n\nfunction CodeBrowser({ files, startingFileName, }) {\r\n    const [activeFile, setActiveFile] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => files.find(f => f.name === startingFileName));\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-code-browser\" },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Sidebar, { files: files, activeFile: activeFile, setActiveFile: setActiveFile }),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Content, { file: activeFile })));\r\n}\r\nfunction Sidebar({ files, activeFile, setActiveFile, }) {\r\n    const tree = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => toFileTree(files), [files]);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-code-browser-sidebar\" },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(SidebarNodes, { tree: tree, activeFile: activeFile, setActiveFile: setActiveFile })));\r\n}\r\nfunction SidebarNodes({ tree, activeFile, setActiveFile, level = 0, }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, tree.map(node => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(SidebarNode, { key: node.name, node: node, activeFile: activeFile, setActiveFile: setActiveFile, level: level })))));\r\n}\r\nfunction SidebarNode({ node, activeFile, setActiveFile, level, }) {\r\n    const isFolder = node.children && node.children.length > 0;\r\n    const isSelected = node.codeFile === activeFile;\r\n    if (isFolder) {\r\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null,\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-code-browser-sidebar-folder\" },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: { paddingLeft: level * 1.5 + \"ch\" } }, node.name)),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(SidebarNodes, { tree: node.children, activeFile: activeFile, setActiveFile: setActiveFile, level: level + 1 })));\r\n    }\r\n    else {\r\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null,\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-code-browser-sidebar-file\", \"data-selected\": isSelected, onClick: () => setActiveFile(node.codeFile) },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: { paddingLeft: level * 1.5 + \"ch\" } }, node.name))));\r\n    }\r\n}\r\nfunction Content({ file }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-code-browser-content\" },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(CopyButton, { className: \"ch-code-browser-button\", content: codeToText(file.code) }),\r\n        file.code.lines.map((line, i) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: i },\r\n            line.tokens.map((token, i) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", Object.assign({ key: i }, token.props), token.content))),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"br\", null))))));\r\n}\r\nfunction toFileTree(files) {\r\n    let tree = [];\r\n    for (const file of files) {\r\n        const parts = file.name.split(\"/\");\r\n        let current = tree;\r\n        for (let i = 0; i < parts.length; i++) {\r\n            const part = parts[i];\r\n            const isLastPart = i === parts.length - 1;\r\n            const index = current.findIndex(f => f.name === part);\r\n            if (index === -1) {\r\n                const sub = {\r\n                    name: part,\r\n                    children: [],\r\n                    codeFile: undefined,\r\n                };\r\n                if (isLastPart) {\r\n                    sub.codeFile = file;\r\n                }\r\n                current.push(sub);\r\n                current = sub.children;\r\n            }\r\n            else {\r\n                current = current[index].children;\r\n            }\r\n        }\r\n    }\r\n    tree = sortTree(tree);\r\n    return tree;\r\n}\r\nfunction sortTree(tree) {\r\n    for (const child of tree) {\r\n        child.children = sortTree(child.children);\r\n    }\r\n    return tree.sort((a, b) => {\r\n        const aIsFolder = a.children && a.children.length > 0;\r\n        const bIsFolder = b.children && b.children.length > 0;\r\n        if ((aIsFolder && bIsFolder) ||\r\n            (!aIsFolder && !bIsFolder)) {\r\n            return a.name.localeCompare(b.name);\r\n        }\r\n        if (aIsFolder) {\r\n            return -1;\r\n        }\r\n        return 1;\r\n    });\r\n}\n\nfunction ExpandButton({ style, step, className, }) {\r\n    const [expanded, setExpanded] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\r\n    const [dialogSupported, setDialogSupported] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\r\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\r\n    const files = step.files;\r\n    // check if <dialog /> is supported\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        if (ref.current && !ref.current.showModal) {\r\n            setDialogSupported(false);\r\n        }\r\n    }, []);\r\n    if (!dialogSupported) {\r\n        return null;\r\n    }\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(ExpandIcon, { className: className, style: style, onClick: () => {\r\n                ref.current.showModal();\r\n                document.body.classList.add(\"ch-no-scroll\");\r\n                setExpanded(true);\r\n            } }),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"dialog\", { ref: ref, className: \"ch-expand-dialog\", onClose: () => {\r\n                setExpanded(false);\r\n            }, onClick: e => {\r\n                if (e.currentTarget === e.target) {\r\n                    ref.current.close();\r\n                    document.body.classList.remove(\"ch-no-scroll\");\r\n                }\r\n            } },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(CloseButton, { onClick: () => {\r\n                    ref.current.close();\r\n                    document.body.classList.remove(\"ch-no-scroll\");\r\n                } }),\r\n            expanded ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-expand-dialog-content\" },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(CodeBrowser, { files: files, startingFileName: step.northPanel.active }))) : undefined)));\r\n}\r\nfunction ExpandIcon({ onClick, style, className, }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { type: \"button\", title: \"Expand\", style: style, onClick: onClick, className: className },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", xmlns: \"http://www.w3.org/2000/svg\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: 2, d: \"M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4\" }))));\r\n}\r\nfunction CloseButton({ onClick }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { onClick: onClick, className: \"ch-expand-close\", type: \"button\", title: \"Close\" },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", xmlns: \"http://www.w3.org/2000/svg\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: 2, d: \"M6 18L18 6M6 6l12 12\" }))));\r\n}\n\nconst DEFAULT_STEP = {\r\n    files: [\r\n        {\r\n            code: { lines: [], lang: \"js\" },\r\n            focus: \"\",\r\n            name: \"\",\r\n        },\r\n    ],\r\n    northPanel: { active: \"\", tabs: [\"\"], heightRatio: 1 },\r\n};\r\nfunction EditorTween(_a) {\r\n    var { prev = DEFAULT_STEP, next, t, backward, codeConfig, frameProps = {} } = _a, divProps = __rest(_a, [\"prev\", \"next\", \"t\", \"backward\", \"codeConfig\", \"frameProps\"]);\r\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\r\n    const { showCopyButton, showExpandButton } = codeConfig, config = __rest(codeConfig, [\"showCopyButton\", \"showExpandButton\"]);\r\n    const { northPanel, southPanel, northContent, southContent, } = useTransition(ref, prev, next || prev, t, backward, config);\r\n    const [frozenHeight, freezeHeight] = react__WEBPACK_IMPORTED_MODULE_0__.useState(undefined);\r\n    useLayoutEffect$4(() => {\r\n        var _a;\r\n        const height = (_a = ref.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().height;\r\n        freezeHeight(height);\r\n    }, []);\r\n    const framePropsWithHeight = Object.assign(Object.assign(Object.assign({}, frameProps), divProps), { style: Object.assign(Object.assign({}, frameProps === null || frameProps === void 0 ? void 0 : frameProps.style), divProps === null || divProps === void 0 ? void 0 : divProps.style) });\r\n    if (frozenHeight) {\r\n        framePropsWithHeight.style.height = frozenHeight;\r\n        framePropsWithHeight.style.maxHeight = frozenHeight;\r\n    }\r\n    const northButtons = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        showCopyButton ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CopyButton, { className: \"ch-editor-button\", content: northContent })) : undefined,\r\n        showExpandButton ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(ExpandButton, { className: \"ch-editor-button\", step: next || prev })) : undefined));\r\n    const southCopyButton = showCopyButton ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CopyButton, { className: \"ch-editor-button\", content: southContent })) : undefined;\r\n    const terminalPanel = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(TerminalPanel, { prev: prev.terminal, next: (next || prev).terminal, t: t, backward: backward }));\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorFrame, Object.assign({ ref: ref }, framePropsWithHeight, { northPanel: northPanel, southPanel: southPanel, terminalPanel: terminalPanel, northButton: northButtons, southButton: southCopyButton })));\r\n}\n\nconst defaultSpring = {\r\n    stiffness: 120,\r\n    damping: 24,\r\n    mass: 0.2,\r\n    decimals: 3,\r\n};\r\nfunction EditorSpring(_a) {\r\n    var { northPanel, southPanel, files, terminal, springConfig } = _a, props = __rest(_a, [\"northPanel\", \"southPanel\", \"files\", \"terminal\", \"springConfig\"]);\r\n    const step = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n        return {\r\n            northPanel,\r\n            southPanel,\r\n            files,\r\n            terminal,\r\n        };\r\n    }, [northPanel, southPanel, files, terminal]);\r\n    const { prev, next, t } = useStepSpring(step, springConfig);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorTween, Object.assign({ t: t, backward: false, prev: prev, next: next }, props)));\r\n}\r\nfunction useStepSpring(step, springConfig = defaultSpring) {\r\n    const [{ target, steps, index }, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\r\n        target: 2,\r\n        steps: [step, step, step],\r\n        index: 0,\r\n    });\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        const lastStep = steps[steps.length - 1];\r\n        if (lastStep != step) {\r\n            setState(s => updateStepSpring(s, step, progress));\r\n        }\r\n    }, [step]);\r\n    const [progress] = useSpring(target, springConfig);\r\n    const trioProgress = progress - index;\r\n    const result = trioProgress <= 1\r\n        ? {\r\n            prev: steps[0],\r\n            next: steps[1],\r\n            t: trioProgress,\r\n        }\r\n        : {\r\n            prev: steps[1],\r\n            next: steps[2],\r\n            t: trioProgress - 1,\r\n        };\r\n    return result;\r\n}\r\nfunction updateStepSpring(state, newStep, progress) {\r\n    const { steps, target, index } = state;\r\n    const stepsClone = steps.slice();\r\n    const trioProgress = progress - index;\r\n    if (trioProgress < 1) {\r\n        stepsClone[2] = newStep;\r\n        return Object.assign(Object.assign({}, state), { steps: stepsClone });\r\n    }\r\n    else {\r\n        stepsClone[0] = steps[1];\r\n        stepsClone[1] = steps[2];\r\n        stepsClone[2] = newStep;\r\n        return Object.assign(Object.assign({}, state), { steps: stepsClone, target: target + 1, index: index + 1 });\r\n    }\r\n}\n\nfunction Code(props) {\r\n    const [step, setStep] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props);\r\n    function onTabClick(filename) {\r\n        const newStep = updateEditorStep(step, filename, null);\r\n        setStep(Object.assign(Object.assign({}, step), newStep));\r\n    }\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerCode, Object.assign({}, step, { onTabClick: onTabClick }));\r\n}\r\n// build the CodeConfig from props and props.codeConfig\r\nfunction mergeCodeConfig(props) {\r\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\r\n    const { lineNumbers, showCopyButton, showExpandButton, minZoom, maxZoom } = props, rest = __rest(props, [\"lineNumbers\", \"showCopyButton\", \"showExpandButton\", \"minZoom\", \"maxZoom\"]);\r\n    const codeConfig = Object.assign(Object.assign({}, props.codeConfig), { maxZoom: maxZoom == null ? (_a = props.codeConfig) === null || _a === void 0 ? void 0 : _a.maxZoom : maxZoom, minZoom: minZoom == null ? (_b = props.codeConfig) === null || _b === void 0 ? void 0 : _b.minZoom : minZoom, horizontalCenter: (_d = (_c = props.codeConfig) === null || _c === void 0 ? void 0 : _c.horizontalCenter) !== null && _d !== void 0 ? _d : props.horizontalCenter, lineNumbers: lineNumbers == null\r\n            ? (_e = props.codeConfig) === null || _e === void 0 ? void 0 : _e.lineNumbers\r\n            : lineNumbers, showCopyButton: showCopyButton == null\r\n            ? (_f = props.codeConfig) === null || _f === void 0 ? void 0 : _f.showCopyButton\r\n            : showCopyButton, showExpandButton: showExpandButton == null\r\n            ? (_g = props.codeConfig) === null || _g === void 0 ? void 0 : _g.showExpandButton\r\n            : showExpandButton, rows: props.rows, debug: (_h = props.debug) !== null && _h !== void 0 ? _h : (_j = props.codeConfig) === null || _j === void 0 ? void 0 : _j.debug });\r\n    return Object.assign(Object.assign({}, rest), { codeConfig });\r\n}\r\nfunction InnerCode(_a) {\r\n    var _b, _c;\r\n    var { onTabClick } = _a, props = __rest(_a, [\"onTabClick\"]);\r\n    const _d = mergeCodeConfig(props), { className, style, codeConfig } = _d, editorProps = __rest(_d, [\"className\", \"style\", \"codeConfig\"]);\r\n    if (!props.southPanel &&\r\n        props.files.length === 1 &&\r\n        !props.files[0].name) {\r\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: `ch-codeblock not-prose ${className || \"\"}`, \"data-ch-theme\": (_b = props.codeConfig) === null || _b === void 0 ? void 0 : _b.themeName, style: style },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(CodeSpring, { className: \"ch-code\", config: codeConfig, step: editorProps.files[0] })));\r\n    }\r\n    else {\r\n        const frameProps = Object.assign(Object.assign({}, editorProps === null || editorProps === void 0 ? void 0 : editorProps.frameProps), { onTabClick });\r\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: `ch-codegroup not-prose ${className || \"\"}`, \"data-ch-theme\": (_c = props.codeConfig) === null || _c === void 0 ? void 0 : _c.themeName, style: style },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorSpring, Object.assign({}, editorProps, { frameProps: frameProps, codeConfig: codeConfig }))));\r\n    }\r\n}\r\nfunction updateEditorStep(step, filename, focus) {\r\n    const name = filename || step.northPanel.active;\r\n    const newFiles = step.files.map((file) => file.name === name\r\n        ? Object.assign(Object.assign({}, file), { focus: focus === null ? file.focus : focus }) : file);\r\n    let northPanel = Object.assign({}, step.northPanel);\r\n    let southPanel = step.southPanel && Object.assign({}, step.southPanel);\r\n    if (step.northPanel.tabs.includes(name)) {\r\n        northPanel.active = name;\r\n    }\r\n    else if (southPanel) {\r\n        southPanel.active = name;\r\n    }\r\n    return { files: newFiles, northPanel, southPanel };\r\n}\n\nconst SectionContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\r\n    props: null,\r\n    setFocus: () => { },\r\n});\r\nfunction Section(_a) {\r\n    var { children, className, style } = _a, props = __rest(_a, [\"children\", \"className\", \"style\"]);\r\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(props);\r\n    const resetFocus = () => setState(props);\r\n    const setFocus = ({ fileName, focus, id, }) => {\r\n        const newStep = updateEditorStep(state, fileName, focus);\r\n        setState(Object.assign(Object.assign(Object.assign({}, state), newStep), { selectedId: id }));\r\n    };\r\n    const rest = __rest(state, [\"selectedId\"]);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"section\", { className: `ch-section ${className || \"\"}`, style: style },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(SectionContext.Provider, { value: {\r\n                props: rest,\r\n                setFocus,\r\n            } },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(LinkableSection, { onActivation: setFocus, onReset: resetFocus }, children))));\r\n}\r\nfunction SectionCode(innerProps) {\r\n    const { props, setFocus } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SectionContext);\r\n    const onTabClick = (filename) => {\r\n        setFocus({ fileName: filename, focus: null, id: \"\" });\r\n    };\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerCode, Object.assign({}, innerProps, props, { onTabClick: onTabClick })));\r\n}\r\n// ---\r\nfunction SectionLink({ focus, file, children, id, }) {\r\n    const { activate, reset, activatedId } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LinkableContext);\r\n    const isSelected = activatedId === id;\r\n    // const handleClick = isSelected\r\n    //   ? resetFocus\r\n    //   : () => setFocus({ fileName: file, focus, id })\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"ch-section-link\", \"data-active\": isSelected, \r\n        // onClick={handleClick}\r\n        children: children, onMouseOver: () => activate({ fileName: file, focus, id }), onMouseOut: reset }));\r\n}\r\nconst LinkableContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\r\n    activatedId: undefined,\r\n    activate: () => { },\r\n    reset: () => { },\r\n});\r\nfunction LinkableSection({ onActivation, onReset, children, }) {\r\n    const [activatedId, setActivatedId] = react__WEBPACK_IMPORTED_MODULE_0__.useState(undefined);\r\n    const activate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(x => {\r\n        setActivatedId(x.id);\r\n        onActivation(x);\r\n    }, [onActivation]);\r\n    const reset = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\r\n        setActivatedId(undefined);\r\n        onReset();\r\n    }, [onReset]);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(LinkableContext.Provider, { value: {\r\n            activate,\r\n            reset,\r\n            activatedId,\r\n        } }, children));\r\n}\n\nfunction Back() {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { fill: \"currentColor\", preserveAspectRatio: \"xMidYMid meet\", height: \"1em\", viewBox: \"13 10 14 23\", className: \"ch-browser-button ch-browser-back-button\" },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", null,\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"m26.5 12.1q0 0.3-0.2 0.6l-8.8 8.7 8.8 8.8q0.2 0.2 0.2 0.5t-0.2 0.5l-1.1 1.1q-0.3 0.3-0.6 0.3t-0.5-0.3l-10.4-10.4q-0.2-0.2-0.2-0.5t0.2-0.5l10.4-10.4q0.3-0.2 0.5-0.2t0.6 0.2l1.1 1.1q0.2 0.2 0.2 0.5z\" }))));\r\n}\r\nfunction Forward() {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { fill: \"currentColor\", preserveAspectRatio: \"xMidYMid meet\", height: \"1em\", viewBox: \"13 10 14 23\", className: \"ch-browser-button ch-browser-forward-button\" },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", null,\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"m26.3 21.4q0 0.3-0.2 0.5l-10.4 10.4q-0.3 0.3-0.6 0.3t-0.5-0.3l-1.1-1.1q-0.2-0.2-0.2-0.5t0.2-0.5l8.8-8.8-8.8-8.7q-0.2-0.3-0.2-0.6t0.2-0.5l1.1-1.1q0.3-0.2 0.5-0.2t0.6 0.2l10.4 10.4q0.2 0.2 0.2 0.5z\" }))));\r\n}\r\nfunction Open({ href }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", { className: \"ch-browser-button ch-browser-open-button\", title: \"Open in new tab\", href: href, target: \"_blank\", rel: \"noopener noreferrer\" },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { stroke: \"currentColor\", fill: \"currentColor\", strokeWidth: \"0\", viewBox: \"3 3 18 18\", height: \"1em\", width: \"1em\", className: \"ch-browser-open-icon\", xmlns: \"http://www.w3.org/2000/svg\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z\" }))));\r\n}\n\nfunction TitleBar({ url, linkUrl, }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(FrameButtons, null),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Back, null),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Forward, null),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"input\", { value: url || \"\", readOnly: true }),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Open, { href: linkUrl })));\r\n}\n\nfunction useSteps$1(steps) {\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n        if (!steps) {\r\n            return [{ zoom: 1 }];\r\n        }\r\n        return steps.map(step => {\r\n            const { displayUrl, loadUrl } = transformUrl(step.url, step.loadUrl, step.prependOrigin);\r\n            return {\r\n                zoom: step.zoom || 1,\r\n                displayUrl,\r\n                loadUrl,\r\n                children: step.children,\r\n            };\r\n        });\r\n    }, [steps]);\r\n}\r\nfunction transformUrl(url, loadUrl, prependOrigin) {\r\n    const currentOrigin = typeof window !== \"undefined\" ? window.origin : \"\";\r\n    const displayUrl = url && prependOrigin === true\r\n        ? currentOrigin + url\r\n        : url;\r\n    return { displayUrl, loadUrl: loadUrl || displayUrl };\r\n}\n\nconst MiniBrowserHike = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(MiniBrowserWithRef);\r\nfunction MiniBrowserWithRef(_a, ref) {\r\n    var { progress = 0, backward = false, steps: ogSteps, transition = \"none\" } = _a, props = __rest(_a, [\"progress\", \"backward\", \"steps\", \"transition\"]);\r\n    const steps = useSteps$1(ogSteps);\r\n    const stepIndex = Math.round(progress);\r\n    const { zoom, displayUrl, loadUrl, children } = steps[stepIndex];\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(MiniFrame, Object.assign({}, props, { zoom: zoom, className: `ch-mini-browser ${props.className || \"\"}`, style: Object.assign(Object.assign({}, transitionStyle({ progress, transition })), props.style), titleBar: react__WEBPACK_IMPORTED_MODULE_0__.createElement(TitleBar, { url: displayUrl, linkUrl: loadUrl }) }), children || react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"iframe\", { ref: ref, src: loadUrl })));\r\n}\r\nfunction transitionStyle({ progress, transition, }) {\r\n    if (transition === \"slide\") {\r\n        const X = 50;\r\n        const t = progress - Math.floor(progress);\r\n        const x = t <= 0.5 ? -X * t : X - X * t;\r\n        const o = Math.abs(t - 0.5) * 2;\r\n        return {\r\n            transform: `translateX(${x}px)`,\r\n            opacity: o * o,\r\n        };\r\n    }\r\n    return {};\r\n}\n\nfunction MiniBrowser(_a) {\r\n    var { url, loadUrl, prependOrigin, children, zoom } = _a, rest = __rest(_a, [\"url\", \"loadUrl\", \"prependOrigin\", \"children\", \"zoom\"]);\r\n    const [steps, progress] = useSteps({\r\n        url,\r\n        loadUrl,\r\n        prependOrigin,\r\n        children,\r\n        zoom,\r\n    });\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(MiniBrowserHike, Object.assign({}, rest, { steps: steps, progress: progress })));\r\n}\r\nfunction useSteps({ url, loadUrl, prependOrigin, children, zoom, }) {\r\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\r\n        target: 0,\r\n        steps: [\r\n            { url, loadUrl, prependOrigin, children, zoom },\r\n        ],\r\n    });\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        const last = state.steps[state.steps.length - 1];\r\n        if (last.url !== url ||\r\n            last.loadUrl !== loadUrl ||\r\n            last.prependOrigin !== prependOrigin ||\r\n            last.children !== children) {\r\n            setState(s => ({\r\n                target: s.target + 1,\r\n                steps: [\r\n                    ...s.steps,\r\n                    { url, loadUrl, prependOrigin, children, zoom },\r\n                ],\r\n            }));\r\n        }\r\n    }, [url, loadUrl, prependOrigin, children, zoom]);\r\n    const [progress] = useSpring(state.target, {\r\n        stiffness: 100,\r\n        decimals: 3,\r\n    });\r\n    return [state.steps, progress];\r\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar templates = {};\n\nObject.defineProperty(templates, \"__esModule\", { value: true });\nfunction getMainFile(template) {\n    if (template === \"vue-cli\") {\n        return \"src/main.js\";\n    }\n    if (template === \"angular-cli\") {\n        return \"src/main.ts\";\n    }\n    if (template === \"create-react-app-typescript\") {\n        return \"src/index.tsx\";\n    }\n    if (template === \"parcel\") {\n        return \"index.html\";\n    }\n    if (template === \"gatsby\") {\n        return \"src/pages/index.js\";\n    }\n    if (template === \"nuxt\") {\n        // Wildcard, because nuxt is not specific on this\n        return \"package.json\";\n    }\n    if (template === \"next\") {\n        // Wildcard, because next is not specific on this\n        return \"package.json\";\n    }\n    if (template === \"apollo\") {\n        // Wildcard, because apollo is not specific on this\n        return \"package.json\";\n    }\n    if (template === \"reason\") {\n        // Wildcard, because reason is not specific on this\n        return \"package.json\";\n    }\n    if (template === \"sapper\") {\n        // Wildcard, because sapper is not specific on this\n        return \"package.json\";\n    }\n    if (template === \"nest\") {\n        return \"src/main.ts\";\n    }\n    if (template === \"static\") {\n        return \"index.html\";\n    }\n    return \"src/index.js\";\n}\ntemplates.getMainFile = getMainFile;\nvar SANDBOX_CONFIG = \"sandbox.config.json\";\nfunction getTemplate(packageJSONPackage, modules) {\n    var sandboxConfig = modules[SANDBOX_CONFIG] || modules[\"/\" + SANDBOX_CONFIG];\n    if (sandboxConfig) {\n        try {\n            var config = JSON.parse(sandboxConfig.content);\n            if (config.template) {\n                return config.template;\n            }\n        }\n        catch (e) { }\n    }\n    var _a = packageJSONPackage.dependencies, dependencies = _a === void 0 ? {} : _a, _b = packageJSONPackage.devDependencies, devDependencies = _b === void 0 ? {} : _b;\n    var totalDependencies = Object.keys(dependencies).concat(Object.keys(devDependencies));\n    var nuxt = [\"nuxt\", \"nuxt-edge\"];\n    if (totalDependencies.some(function (dep) { return nuxt.indexOf(dep) > -1; })) {\n        return \"nuxt\";\n    }\n    if (totalDependencies.indexOf(\"next\") > -1) {\n        return \"next\";\n    }\n    var apollo = [\n        \"apollo-server\",\n        \"apollo-server-express\",\n        \"apollo-server-hapi\",\n        \"apollo-server-koa\",\n        \"apollo-server-lambda\",\n        \"apollo-server-micro\"\n    ];\n    if (totalDependencies.some(function (dep) { return apollo.indexOf(dep) > -1; })) {\n        return \"apollo\";\n    }\n    if (totalDependencies.indexOf(\"ember-cli\") > -1) {\n        return \"ember\";\n    }\n    if (totalDependencies.indexOf(\"sapper\") > -1) {\n        return \"sapper\";\n    }\n    var moduleNames = Object.keys(modules);\n    if (moduleNames.some(function (m) { return m.endsWith(\".vue\"); })) {\n        return \"vue-cli\";\n    }\n    if (moduleNames.some(function (m) { return m.endsWith(\".re\"); })) {\n        return \"reason\";\n    }\n    if (totalDependencies.indexOf(\"gatsby\") > -1) {\n        return \"gatsby\";\n    }\n    if (totalDependencies.indexOf(\"parcel-bundler\") > -1) {\n        return \"parcel\";\n    }\n    if (totalDependencies.indexOf(\"react-scripts\") > -1) {\n        return \"create-react-app\";\n    }\n    if (totalDependencies.indexOf(\"react-scripts-ts\") > -1) {\n        return \"create-react-app-typescript\";\n    }\n    if (totalDependencies.indexOf(\"@angular/core\") > -1) {\n        return \"angular-cli\";\n    }\n    if (totalDependencies.indexOf(\"preact-cli\") > -1) {\n        return \"preact-cli\";\n    }\n    if (totalDependencies.indexOf(\"svelte\") > -1) {\n        return \"svelte\";\n    }\n    if (totalDependencies.indexOf(\"vue\") > -1) {\n        return \"vue-cli\";\n    }\n    var dojo = [\"@dojo/core\", \"@dojo/framework\"];\n    if (totalDependencies.some(function (dep) { return dojo.indexOf(dep) > -1; })) {\n        return \"@dojo/cli-create-app\";\n    }\n    if (totalDependencies.indexOf(\"cx\") > -1) {\n        return \"cxjs\";\n    }\n    if (totalDependencies.indexOf(\"@nestjs/core\") > -1 ||\n        totalDependencies.indexOf(\"@nestjs/common\") > -1) {\n        return \"nest\";\n    }\n    return undefined;\n}\nvar getTemplate_1 = templates.getTemplate = getTemplate;\n\nvar lodash_isequal = {exports: {}};\n\n/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n(function (module, exports) {\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n}(lodash_isequal, lodash_isequal.exports));\n\nvar isEqual = lodash_isequal.exports;\n\n// src/client.ts\n\n// src/file-resolver-protocol.ts\nvar generateId = () => Math.floor(Math.random() * 1e6 + Math.random() * 1e6);\nvar getConstructorName = (x) => {\n  try {\n    return x.constructor.name;\n  } catch (e) {\n    return \"\";\n  }\n};\nvar Protocol = class {\n  constructor(type, handleMessage, target) {\n    this.type = type;\n    this.handleMessage = handleMessage;\n    this.target = target;\n    this.outgoingMessages = new Set();\n    this._messageListener = async (e) => {\n      var _a;\n      const { data } = e;\n      if (data.$type !== this.getTypeId()) {\n        return;\n      }\n      if (this.outgoingMessages.has(data.$id)) {\n        return;\n      }\n      let returnMessage = {\n        $originId: this.internalId,\n        $type: this.getTypeId(),\n        $id: data.$id\n      };\n      try {\n        const result = await this.handleMessage(data.$data);\n        returnMessage.$data = result;\n      } catch (err) {\n        if (!err.message) {\n          console.error(err);\n        }\n        returnMessage.$error = { message: (_a = err.message) != null ? _a : \"Unknown error\" };\n      }\n      if (e.source) {\n        e.source.postMessage(returnMessage, \"*\");\n      } else {\n        this._postMessage(returnMessage);\n      }\n    };\n    this.createConnection();\n    this.internalId = generateId();\n    this.isWorker = getConstructorName(target) === \"Worker\";\n  }\n  getTypeId() {\n    return `p-${this.type}`;\n  }\n  createConnection() {\n    self.addEventListener(\"message\", this._messageListener);\n  }\n  dispose() {\n    self.removeEventListener(\"message\", this._messageListener);\n  }\n  sendMessage(data) {\n    return new Promise((resolve) => {\n      const messageId = generateId();\n      const message = {\n        $originId: this.internalId,\n        $type: this.getTypeId(),\n        $data: data,\n        $id: messageId\n      };\n      this.outgoingMessages.add(messageId);\n      const listenFunction = (e) => {\n        const { data: data2 } = e;\n        if (data2.$type === this.getTypeId() && data2.$id === messageId && data2.$originId !== this.internalId) {\n          resolve(data2.$data);\n          self.removeEventListener(\"message\", listenFunction);\n        }\n      };\n      self.addEventListener(\"message\", listenFunction);\n      this._postMessage(message);\n    });\n  }\n  _postMessage(m) {\n    if (this.isWorker || typeof DedicatedWorkerGlobalScope !== \"undefined\" && this.target instanceof DedicatedWorkerGlobalScope) {\n      this.target.postMessage(m);\n    } else {\n      this.target.postMessage(m, \"*\");\n    }\n  }\n};\n\n// src/iframe-protocol.ts\nvar IFrameProtocol = class {\n  constructor(iframe, origin) {\n    this.globalListeners = {};\n    this.globalListenersCount = 0;\n    this.channelListeners = {};\n    this.channelListenersCount = 0;\n    this.channelId = Math.floor(Math.random() * 1e6);\n    this.frameWindow = iframe.contentWindow;\n    this.origin = origin;\n    this.globalListeners = [];\n    this.channelListeners = [];\n    this.eventListener = this.eventListener.bind(this);\n    if (typeof window !== \"undefined\") {\n      window.addEventListener(\"message\", this.eventListener);\n    }\n  }\n  cleanup() {\n    window.removeEventListener(\"message\", this.eventListener);\n    this.globalListeners = {};\n    this.channelListeners = {};\n    this.globalListenersCount = 0;\n    this.channelListenersCount = 0;\n  }\n  register() {\n    if (!this.frameWindow) {\n      return;\n    }\n    this.frameWindow.postMessage({\n      type: \"register-frame\",\n      origin: document.location.origin,\n      id: this.channelId\n    }, this.origin);\n  }\n  dispatch(message) {\n    if (!this.frameWindow) {\n      return;\n    }\n    this.frameWindow.postMessage({\n      $id: this.channelId,\n      codesandbox: true,\n      ...message\n    }, this.origin);\n  }\n  globalListen(listener) {\n    if (typeof listener !== \"function\") {\n      return () => {\n        return;\n      };\n    }\n    const listenerId = this.globalListenersCount;\n    this.globalListeners[listenerId] = listener;\n    this.globalListenersCount++;\n    return () => {\n      delete this.globalListeners[listenerId];\n    };\n  }\n  channelListen(listener) {\n    if (typeof listener !== \"function\") {\n      return () => {\n        return;\n      };\n    }\n    const listenerId = this.channelListenersCount;\n    this.channelListeners[listenerId] = listener;\n    this.channelListenersCount++;\n    return () => {\n      delete this.channelListeners[listenerId];\n    };\n  }\n  eventListener(evt) {\n    if (evt.source !== this.frameWindow) {\n      return;\n    }\n    const message = evt.data;\n    if (!message.codesandbox) {\n      return;\n    }\n    Object.values(this.globalListeners).forEach((listener) => listener(message));\n    if (message.$id !== this.channelId) {\n      return;\n    }\n    Object.values(this.channelListeners).forEach((listener) => listener(message));\n  }\n};\n\n// src/utils.ts\nfunction createPackageJSON(dependencies = {}, devDependencies = {}, entry = \"/index.js\") {\n  return JSON.stringify({\n    name: \"sandpack-project\",\n    main: entry,\n    dependencies,\n    devDependencies\n  }, null, 2);\n}\nfunction addPackageJSONIfNeeded(files, dependencies, devDependencies, entry) {\n  const newFiles = { ...files };\n  if (!newFiles[\"/package.json\"]) {\n    if (!dependencies) {\n      throw new Error(\"No dependencies specified, please specify either a package.json or dependencies.\");\n    }\n    if (!entry) {\n      throw new Error(\"Missing 'entry' parameter. Either specify an entry point, or pass in a package.json with the 'main' field set.\");\n    }\n    newFiles[\"/package.json\"] = {\n      code: createPackageJSON(dependencies, devDependencies, entry)\n    };\n  }\n  return newFiles;\n}\nfunction extractErrorDetails(msg) {\n  if (msg.title === \"SyntaxError\") {\n    const { title, path, message, line, column } = msg;\n    return { title, path, message, line, column };\n  }\n  const relevantStackFrame = getRelevantStackFrame(msg.payload.frames);\n  if (!relevantStackFrame) {\n    return { message: msg.message };\n  }\n  const errorInCode = getErrorInOriginalCode(relevantStackFrame);\n  const errorLocation = getErrorLocation(relevantStackFrame);\n  const errorMessage = formatErrorMessage(relevantStackFrame._originalFileName, msg.message, errorLocation, errorInCode);\n  return {\n    message: errorMessage,\n    title: msg.title,\n    path: relevantStackFrame._originalFileName,\n    line: relevantStackFrame._originalLineNumber,\n    column: relevantStackFrame._originalColumnNumber\n  };\n}\nfunction getRelevantStackFrame(frames) {\n  if (!frames) {\n    return;\n  }\n  return frames.find((frame) => !!frame._originalFileName);\n}\nfunction getErrorLocation(errorFrame) {\n  return errorFrame ? ` (${errorFrame._originalLineNumber}:${errorFrame._originalColumnNumber})` : ``;\n}\nfunction getErrorInOriginalCode(errorFrame) {\n  const lastScriptLine = errorFrame._originalScriptCode[errorFrame._originalScriptCode.length - 1];\n  const numberOfLineNumberCharacters = lastScriptLine.lineNumber.toString().length;\n  const leadingCharacterOffset = 2;\n  const barSeparatorCharacterOffset = 3;\n  const extraLineLeadingSpaces = leadingCharacterOffset + numberOfLineNumberCharacters + barSeparatorCharacterOffset + errorFrame._originalColumnNumber;\n  return errorFrame._originalScriptCode.reduce((result, scriptLine) => {\n    const leadingChar = scriptLine.highlight ? \">\" : \" \";\n    const lineNumber = scriptLine.lineNumber.toString().length === numberOfLineNumberCharacters ? `${scriptLine.lineNumber}` : ` ${scriptLine.lineNumber}`;\n    const extraLine = scriptLine.highlight ? \"\\n\" + \" \".repeat(extraLineLeadingSpaces) + \"^\" : \"\";\n    return result + \"\\n\" + leadingChar + \" \" + lineNumber + \" | \" + scriptLine.content + extraLine;\n  }, \"\");\n}\nfunction formatErrorMessage(filePath, message, location, errorInCode) {\n  return `${filePath}: ${message}${location}\n${errorInCode}`;\n}\n\n// src/client.ts\nvar BUNDLER_URL = `https://${\"0.19.0\".replace(/\\./g, \"-\")}-sandpack.codesandbox.io/`;\nvar SandpackClient = class {\n  constructor(selector, sandboxInfo, options = {}) {\n    this.getTranspilerContext = () => new Promise((resolve) => {\n      const unsubscribe = this.listen((message) => {\n        if (message.type === \"transpiler-context\") {\n          resolve(message.data);\n          unsubscribe();\n        }\n      });\n      this.dispatch({ type: \"get-transpiler-context\" });\n    });\n    var _a;\n    this.options = options;\n    this.sandboxInfo = sandboxInfo;\n    this.bundlerURL = options.bundlerURL || BUNDLER_URL;\n    this.bundlerState = void 0;\n    this.errors = [];\n    this.status = \"initializing\";\n    if (typeof selector === \"string\") {\n      this.selector = selector;\n      const element = document.querySelector(selector);\n      if (!element) {\n        throw new Error(`No element found for selector '${selector}'`);\n      }\n      this.element = element;\n      this.iframe = document.createElement(\"iframe\");\n      this.initializeElement();\n    } else {\n      this.element = selector;\n      this.iframe = selector;\n    }\n    if (!this.iframe.getAttribute(\"sandbox\")) {\n      this.iframe.setAttribute(\"sandbox\", \"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\");\n    }\n    const urlSource = options.startRoute ? new URL(options.startRoute, this.bundlerURL).toString() : this.bundlerURL;\n    (_a = this.iframe.contentWindow) == null ? void 0 : _a.location.replace(urlSource);\n    this.iframeProtocol = new IFrameProtocol(this.iframe, this.bundlerURL);\n    this.unsubscribeGlobalListener = this.iframeProtocol.globalListen((mes) => {\n      if (mes.type !== \"initialized\" || !this.iframe.contentWindow) {\n        return;\n      }\n      this.iframeProtocol.register();\n      if (this.options.fileResolver) {\n        this.fileResolverProtocol = new Protocol(\"file-resolver\", async (data) => {\n          if (data.m === \"isFile\") {\n            return this.options.fileResolver.isFile(data.p);\n          }\n          return this.options.fileResolver.readFile(data.p);\n        }, this.iframe.contentWindow);\n      }\n      this.updatePreview(this.sandboxInfo, true);\n    });\n    this.unsubscribeChannelListener = this.iframeProtocol.channelListen((mes) => {\n      switch (mes.type) {\n        case \"start\": {\n          this.errors = [];\n          break;\n        }\n        case \"status\": {\n          this.status = mes.status;\n          break;\n        }\n        case \"action\": {\n          if (mes.action === \"show-error\") {\n            this.errors = [...this.errors, extractErrorDetails(mes)];\n          }\n          break;\n        }\n        case \"state\": {\n          this.bundlerState = mes.state;\n          break;\n        }\n      }\n    });\n  }\n  cleanup() {\n    this.unsubscribeChannelListener();\n    this.unsubscribeGlobalListener();\n    this.iframeProtocol.cleanup();\n  }\n  updateOptions(options) {\n    if (!isEqual(this.options, options)) {\n      this.options = options;\n      this.updatePreview();\n    }\n  }\n  updatePreview(sandboxInfo = this.sandboxInfo, isInitializationCompile) {\n    var _a, _b, _c, _d;\n    this.sandboxInfo = {\n      ...this.sandboxInfo,\n      ...sandboxInfo\n    };\n    const files = this.getFiles();\n    const modules = Object.keys(files).reduce((prev, next) => ({\n      ...prev,\n      [next]: {\n        code: files[next].code,\n        path: next\n      }\n    }), {});\n    let packageJSON = JSON.parse(createPackageJSON(this.sandboxInfo.dependencies, this.sandboxInfo.devDependencies, this.sandboxInfo.entry));\n    try {\n      packageJSON = JSON.parse(files[\"/package.json\"].code);\n    } catch (e) {\n      console.error(\"Could not parse package.json file: \" + e.message);\n    }\n    const normalizedModules = Object.keys(files).reduce((prev, next) => ({\n      ...prev,\n      [next]: {\n        content: files[next].code,\n        path: next\n      }\n    }), {});\n    this.dispatch({\n      type: \"compile\",\n      codesandbox: true,\n      version: 3,\n      isInitializationCompile,\n      modules,\n      reactDevTools: this.options.reactDevTools,\n      externalResources: this.options.externalResources || [],\n      hasFileResolver: Boolean(this.options.fileResolver),\n      disableDependencyPreprocessing: this.sandboxInfo.disableDependencyPreprocessing,\n      template: this.sandboxInfo.template || getTemplate_1(packageJSON, normalizedModules),\n      showOpenInCodeSandbox: (_a = this.options.showOpenInCodeSandbox) != null ? _a : true,\n      showErrorScreen: (_b = this.options.showErrorScreen) != null ? _b : true,\n      showLoadingScreen: (_c = this.options.showLoadingScreen) != null ? _c : true,\n      skipEval: this.options.skipEval || false,\n      clearConsoleDisabled: !this.options.clearConsoleOnFirstCompile,\n      logLevel: (_d = this.options.logLevel) != null ? _d : SandpackLogLevel.Info\n    });\n  }\n  dispatch(message) {\n    this.iframeProtocol.dispatch(message);\n  }\n  listen(listener) {\n    return this.iframeProtocol.channelListen(listener);\n  }\n  getCodeSandboxURL() {\n    const files = this.getFiles();\n    const paramFiles = Object.keys(files).reduce((prev, next) => ({\n      ...prev,\n      [next.replace(\"/\", \"\")]: {\n        content: files[next].code,\n        isBinary: false\n      }\n    }), {});\n    return fetch(\"https://codesandbox.io/api/v1/sandboxes/define?json=1\", {\n      method: \"POST\",\n      body: JSON.stringify({ files: paramFiles }),\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\"\n      }\n    }).then((x) => x.json()).then((res) => ({\n      sandboxId: res.sandbox_id,\n      editorUrl: `https://codesandbox.io/s/${res.sandbox_id}`,\n      embedUrl: `https://codesandbox.io/embed/${res.sandbox_id}`\n    }));\n  }\n  getFiles() {\n    const { sandboxInfo } = this;\n    if (sandboxInfo.files[\"/package.json\"] === void 0) {\n      return addPackageJSONIfNeeded(sandboxInfo.files, sandboxInfo.dependencies, sandboxInfo.devDependencies, sandboxInfo.entry);\n    }\n    return this.sandboxInfo.files;\n  }\n  initializeElement() {\n    this.iframe.style.border = \"0\";\n    this.iframe.style.width = this.options.width || \"100%\";\n    this.iframe.style.height = this.options.height || \"100%\";\n    this.iframe.style.overflow = \"hidden\";\n    if (!this.element.parentNode) {\n      throw new Error(\"Given element does not have a parent.\");\n    }\n    this.element.parentNode.replaceChild(this.iframe, this.element);\n  }\n};\n\n// src/types.ts\nvar SandpackLogLevel;\n(function(SandpackLogLevel2) {\n  SandpackLogLevel2[SandpackLogLevel2[\"None\"] = 0] = \"None\";\n  SandpackLogLevel2[SandpackLogLevel2[\"Error\"] = 10] = \"Error\";\n  SandpackLogLevel2[SandpackLogLevel2[\"Warning\"] = 20] = \"Warning\";\n  SandpackLogLevel2[SandpackLogLevel2[\"Info\"] = 30] = \"Info\";\n  SandpackLogLevel2[SandpackLogLevel2[\"Debug\"] = 40] = \"Debug\";\n})(SandpackLogLevel || (SandpackLogLevel = {}));\n\nfunction Preview(_a) {\r\n    var { className, files, presetConfig, show, children, style, frameless, codeConfig } = _a, rest = __rest(_a, [\"className\", \"files\", \"presetConfig\", \"show\", \"children\", \"style\", \"frameless\", \"codeConfig\"]);\r\n    const kids = presetConfig ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(SandpackPreview, { files: files, presetConfig: presetConfig })) : (children);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-preview\" + (className ? \" \" + className : \"\"), style: style, \"data-ch-theme\": codeConfig === null || codeConfig === void 0 ? void 0 : codeConfig.themeName }, frameless ? (kids) : (react__WEBPACK_IMPORTED_MODULE_0__.createElement(MiniBrowser, Object.assign({ loadUrl: show }, rest, { children: kids })))));\r\n}\r\nfunction SandpackPreview({ files, presetConfig, }) {\r\n    const iframeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\r\n    const clientRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        clientRef.current = new SandpackClient(iframeRef.current, Object.assign(Object.assign({}, presetConfig), { files: mergeFiles(presetConfig.files, files) }), {\r\n            showOpenInCodeSandbox: false,\r\n            // showErrorScreen: false,\r\n            // showLoadingScreen: false,\r\n        });\r\n    }, []);\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        if (clientRef.current) {\r\n            clientRef.current.updatePreview(Object.assign(Object.assign({}, presetConfig), { files: mergeFiles(presetConfig.files, files) }));\r\n        }\r\n    }, [files]);\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"iframe\", { ref: iframeRef });\r\n}\r\nfunction mergeFiles(csbFiles, chFiles) {\r\n    const result = Object.assign({}, csbFiles);\r\n    chFiles.forEach(file => {\r\n        result[\"/\" + file.name] = {\r\n            code: file.code.lines\r\n                .map(l => l.tokens.map(t => t.content).join(\"\"))\r\n                .join(\"\\n\"),\r\n        };\r\n    });\r\n    return result;\r\n}\n\nfunction extractPreviewSteps(children, hasPreviewSteps) {\r\n    const allChildren = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children);\r\n    const stepsChildren = hasPreviewSteps\r\n        ? allChildren.slice(0, allChildren.length / 2)\r\n        : allChildren;\r\n    const previewChildren = hasPreviewSteps\r\n        ? allChildren.slice(allChildren.length / 2)\r\n        : undefined;\r\n    return { stepsChildren, previewChildren };\r\n}\n\nfunction Spotlight(_a) {\r\n    var _b;\r\n    var { children, editorSteps, codeConfig, start = 0, presetConfig, className, style, hasPreviewSteps } = _a, rest = __rest(_a, [\"children\", \"editorSteps\", \"codeConfig\", \"start\", \"presetConfig\", \"className\", \"style\", \"hasPreviewSteps\"]);\r\n    const { stepsChildren, previewChildren } = extractPreviewSteps(children, hasPreviewSteps);\r\n    const withPreview = presetConfig || hasPreviewSteps;\r\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\r\n        stepIndex: start,\r\n        step: editorSteps[start],\r\n    });\r\n    const tab = state.step;\r\n    function onTabClick(filename) {\r\n        const newStep = updateEditorStep(state.step, filename, null);\r\n        setState(Object.assign(Object.assign({}, state), { step: newStep }));\r\n    }\r\n    const headerElement = stepsChildren[0];\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"section\", { className: `ch-spotlight ${withPreview ? \"ch-spotlight-with-preview\" : \"\"} ${className || \"\"}`, style: style, \"data-ch-theme\": codeConfig.themeName },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-spotlight-tabs\" },\r\n            ((_b = headerElement === null || headerElement === void 0 ? void 0 : headerElement.props) === null || _b === void 0 ? void 0 : _b.children) ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null, stepsChildren[0])) : null,\r\n            stepsChildren.map((children, i) => i === 0 ? null : (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: i, onClick: () => setState({\r\n                    stepIndex: i,\r\n                    step: editorSteps[i],\r\n                }), className: \"ch-spotlight-tab\", \"data-selected\": i === state.stepIndex ? \"true\" : undefined }, children)))),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-spotlight-sticker\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerCode, Object.assign({}, rest, tab, { codeConfig: codeConfig, onTabClick: onTabClick })),\r\n            presetConfig ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Preview, { className: \"ch-spotlight-preview\", files: tab.files, presetConfig: presetConfig })) : hasPreviewSteps ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Preview, Object.assign({ className: \"ch-spotlight-preview\" }, previewChildren[state.stepIndex][\"props\"]))) : null)));\r\n}\n\nfunction debugEntries(entries) {\r\n    entries.forEach(showEntry);\r\n}\r\nfunction showEntry(entry) {\r\n    var _a;\r\n    const rootHeight = ((_a = entry.rootBounds) === null || _a === void 0 ? void 0 : _a.height) || 0;\r\n    addFlashingRect(entry.rootBounds, {\r\n        border: `${Math.min(10, rootHeight / 2)}px solid ${iodOptions.rootColor}`,\r\n        overflow: \"hidden\",\r\n        boxSizing: \"border-box\",\r\n    });\r\n    addFlashingRect(entry.boundingClientRect, {\r\n        border: `${Math.min(10, entry.boundingClientRect.height / 2)}px solid ${entry.isIntersecting\r\n            ? iodOptions.enterColor\r\n            : iodOptions.exitColor}`,\r\n        overflow: \"hidden\",\r\n        boxSizing: \"border-box\",\r\n    });\r\n    addFlashingRect(entry.intersectionRect, {\r\n        backgroundColor: iodOptions.interColor,\r\n        zIndex: 2,\r\n    });\r\n}\r\nfunction addFlashingRect(bounds, style = {}) {\r\n    const { width, left, height, top } = bounds;\r\n    const div = document.createElement(\"div\");\r\n    div.style.position = \"fixed\";\r\n    div.style.width = width + \"px\";\r\n    div.style.left = left + \"px\";\r\n    div.style.top = top + \"px\";\r\n    div.style.height = height + \"px\";\r\n    div.style.pointerEvents = \"none\";\r\n    div.style.transition = \"opacity 2s ease-in\";\r\n    Object.assign(div.style, style);\r\n    requestAnimationFrame(() => requestAnimationFrame(() => {\r\n        div.style.opacity = \"0\";\r\n    }));\r\n    div.addEventListener(\"transitionend\", () => {\r\n        document.body.removeChild(div);\r\n    });\r\n    document.body.appendChild(div);\r\n    return div;\r\n}\r\nconst iodOptions = {\r\n    rootColor: \"#9428AB\",\r\n    enterColor: \"#B35C00\",\r\n    exitColor: \"#035570\",\r\n    interColor: \"#9CAF00BB\",\r\n};\n\nconst useLayoutEffect$1 = typeof window !== \"undefined\"\r\n    ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect\r\n    : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\r\nfunction useWindowHeight() {\r\n    const isClient = typeof window === \"object\";\r\n    function getHeight() {\r\n        return isClient\r\n            ? document.documentElement.clientHeight\r\n            : undefined;\r\n    }\r\n    const [windowHeight, setWindowHeight] = react__WEBPACK_IMPORTED_MODULE_0__.useState(getHeight);\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        function handleResize() {\r\n            setWindowHeight(getHeight());\r\n        }\r\n        window.addEventListener(\"resize\", handleResize);\r\n        return () => window.removeEventListener(\"resize\", handleResize);\r\n    }, []);\r\n    useLayoutEffect$1(() => {\r\n        // FIX when a horizontal scrollbar is added after the first layout\r\n        setWindowHeight(getHeight());\r\n    }, []);\r\n    return windowHeight;\r\n}\n\nconst ObserverContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(undefined);\r\nconst useLayoutEffect = typeof window !== \"undefined\"\r\n    ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect\r\n    : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\r\nfunction Scroller({ onStepChange, children, getRootMargin = defaultRootMargin, triggerPosition, debug = false, }) {\r\n    const [observer, setObserver] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\r\n    const vh = useWindowHeight();\r\n    useLayoutEffect(() => {\r\n        const windowHeight = vh || 0;\r\n        const handleIntersect = entries => {\r\n            if (debug || window.chDebugScroller) {\r\n                debugEntries(entries);\r\n            }\r\n            entries.forEach(entry => {\r\n                if (entry.intersectionRatio > 0) {\r\n                    const stepElement = entry.target;\r\n                    onStepChange(+stepElement.stepIndex);\r\n                }\r\n            });\r\n        };\r\n        const observer = newIntersectionObserver(handleIntersect, getRootMargin(windowHeight, triggerPosition));\r\n        setObserver(observer);\r\n        return () => observer.disconnect();\r\n    }, [vh]);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(ObserverContext.Provider, { value: observer }, children));\r\n}\r\nfunction Step(_a) {\r\n    var { as = \"section\", index } = _a, props = __rest(_a, [\"as\", \"index\"]);\r\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\r\n    const observer = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ObserverContext);\r\n    useLayoutEffect(() => {\r\n        if (observer) {\r\n            observer.observe(ref.current);\r\n        }\r\n        return () => observer && observer.unobserve(ref.current);\r\n    }, [observer]);\r\n    useLayoutEffect(() => {\r\n        const stepElement = ref.current;\r\n        stepElement.stepIndex = index;\r\n    }, [index]);\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(as, Object.assign(Object.assign({}, props), { ref }));\r\n}\r\nfunction newIntersectionObserver(handleIntersect, rootMargin) {\r\n    return new IntersectionObserver(handleIntersect, {\r\n        rootMargin,\r\n        threshold: 0.000001,\r\n        root: null,\r\n    });\r\n}\r\nfunction defaultRootMargin(vh, triggerPosition = \"50%\") {\r\n    let y = vh * 0.5;\r\n    if (triggerPosition.endsWith(\"%\")) {\r\n        const percent = parseFloat(triggerPosition.replace(\"%\", \"\"));\r\n        y = vh * (percent / 100);\r\n    }\r\n    else if (triggerPosition.endsWith(\"px\")) {\r\n        y = parseFloat(triggerPosition.replace(\"px\", \"\"));\r\n    }\r\n    if (y < 0) {\r\n        y = vh + y;\r\n    }\r\n    return `-${y - 2}px 0px -${vh - y - 2}px`;\r\n}\n\n// server-side-media-queries-for-react\r\nlet suffixCounter = 0;\r\n/**\r\n * @typedef SwapProps\r\n * @prop {[string, JSX.Element][]} match\r\n */\r\n/**\r\n * Swap between different components depending on the media queries\r\n * @param {SwapProps} props\r\n */\r\nfunction Swap({ match }) {\r\n    const queries = match.map(([q]) => q);\r\n    const { isServer, matchedIndex } = useMedia(queries);\r\n    const mainClassName = isServer\r\n        ? \"ssmq-\" + suffixCounter++\r\n        : \"\";\r\n    return isServer ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"style\", { className: mainClassName, dangerouslySetInnerHTML: {\r\n                __html: getStyle(queries, mainClassName),\r\n            } }),\r\n        match.map(([query, element]) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: query, className: `${mainClassName} ${getClassName(query)}` }, element))),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"script\", { className: mainClassName, dangerouslySetInnerHTML: {\r\n                __html: getScript(match, mainClassName),\r\n            } }))) : (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null, match[matchedIndex][1])));\r\n}\r\nfunction getStyle(queries, mainClass) {\r\n    const reversedQueries = queries.slice().reverse();\r\n    const style = reversedQueries\r\n        .map(query => {\r\n        const currentStyle = `.${mainClass}.${getClassName(query)}{display:block}`;\r\n        const otherStyle = `.${mainClass}:not(.${getClassName(query)}){display: none;}`;\r\n        if (query === \"default\") {\r\n            return `${currentStyle}${otherStyle}`;\r\n        }\r\n        else {\r\n            return `@media ${query}{${currentStyle}${otherStyle}}`;\r\n        }\r\n    })\r\n        .join(\"\\n\");\r\n    return style;\r\n}\r\nfunction getScript(match, mainClass) {\r\n    const queries = match.map(([query]) => query);\r\n    const classes = queries.map(getClassName);\r\n    return `(function() {\n  var qs = ${JSON.stringify(queries)};\n  var clss = ${JSON.stringify(classes)};\n  var mainCls = \"${mainClass}\";\n\n  var scrEls = document.getElementsByTagName(\"script\");\n  var scrEl = scrEls[scrEls.length - 1];\n  var parent = scrEl.parentNode;\n\n  var el = null;\n  for (var i = 0; i < qs.length - 1; i++) {\n    if (window.matchMedia(qs[i]).matches) {\n      el = parent.querySelector(\":scope > .\" + mainCls + \".\" + clss[i]);\n      break;\n    }\n  }\n  if (!el) {\n    var defaultClass = clss.pop();\n    el = parent.querySelector(\":scope > .\" + mainCls + \".\" + defaultClass);\n  }\n  el.removeAttribute(\"class\");\n\n  parent.querySelectorAll(\":scope > .\" + mainCls).forEach(function (e) {\n    parent.removeChild(e);\n  });\n})();`;\r\n}\r\nfunction getClassName(string) {\r\n    return (\"ssmq-\" +\r\n        string\r\n            .replace(/[!\\\"#$%&'\\(\\)\\*\\+,\\.\\/:;<=>\\?\\@\\[\\\\\\]\\^`\\{\\|\\}~\\s]/g, \"\")\r\n            .toLowerCase());\r\n}\r\nfunction useMedia(queries) {\r\n    const isServer = typeof window === \"undefined\";\r\n    const allQueries = queries.slice(0, -1);\r\n    if (queries[queries.length - 1] !== \"default\") {\r\n        console.warn(\"last media query should be 'default'\");\r\n    }\r\n    const [, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\r\n    const mediaQueryLists = isServer\r\n        ? []\r\n        : allQueries.map(q => window.matchMedia(q));\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        const handler = () => setValue(x => x + 1);\r\n        mediaQueryLists.forEach(mql => mql.addListener(handler));\r\n        return () => mediaQueryLists.forEach(mql => mql.removeListener(handler));\r\n    }, []);\r\n    const matchedIndex = mediaQueryLists.findIndex(mql => mql.matches);\r\n    return {\r\n        isServer,\r\n        matchedIndex: matchedIndex < 0 ? queries.length - 1 : matchedIndex,\r\n    };\r\n}\n\nfunction CodeSlot() {\r\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(StaticStepContext);\r\n    if (!context) {\r\n        return null;\r\n    }\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerCodeSlot, Object.assign({}, context));\r\n}\r\nfunction InnerCodeSlot({ editorStep, setFocus }) {\r\n    const onTabClick = (filename) => {\r\n        setFocus({ fileName: filename, focus: null, id: \"\" });\r\n    };\r\n    const props = __rest(editorStep, [\"preset\", \"presetConfig\"]);\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerCode, Object.assign({}, props, { onTabClick: onTabClick }));\r\n}\r\nfunction PreviewSlot() {\r\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(StaticStepContext);\r\n    if (!context) {\r\n        return null;\r\n    }\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerPreviewSlot, Object.assign({}, context));\r\n}\r\nfunction InnerPreviewSlot({ previewStep, allProps, editorStep, }) {\r\n    const props = __rest(allProps, [\"preset\"]);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Preview, Object.assign({ className: \"ch-scrollycoding-preview\" }, props, previewStep === null || previewStep === void 0 ? void 0 : previewStep.props, { files: editorStep.files })));\r\n}\r\nconst StaticStepContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\nfunction Scrollycoding(props) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Swap, { match: [\r\n            [\r\n                props.codeConfig.staticMediaQuery,\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(StaticScrollycoding, Object.assign({}, props)),\r\n            ],\r\n            [\"default\", react__WEBPACK_IMPORTED_MODULE_0__.createElement(DynamicScrollycoding, Object.assign({}, props))],\r\n        ] }));\r\n}\r\nfunction StaticScrollycoding(_a) {\r\n    var _b;\r\n    var { children, hasPreviewSteps, editorSteps } = _a, rest = __rest(_a, [\"children\", \"hasPreviewSteps\", \"editorSteps\"]);\r\n    const { stepsChildren, previewChildren } = extractPreviewSteps(children, hasPreviewSteps);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"section\", { className: \"ch-scrollycoding-static\", \"data-ch-theme\": (_b = rest === null || rest === void 0 ? void 0 : rest.codeConfig) === null || _b === void 0 ? void 0 : _b.themeName }, stepsChildren.map((children, i) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(StaticSection, { key: i, editorStep: editorSteps[i], previewStep: previewChildren && previewChildren[i], allProps: rest }, children)))));\r\n}\r\nfunction StaticSection({ editorStep, previewStep, allProps, children, }) {\r\n    const [step, setStep] = react__WEBPACK_IMPORTED_MODULE_0__.useState(Object.assign(Object.assign({}, editorStep), allProps));\r\n    const resetFocus = () => setStep(Object.assign(Object.assign({}, editorStep), allProps));\r\n    const setFocus = ({ fileName, focus, id, }) => {\r\n        const newStep = updateEditorStep(step, fileName, focus);\r\n        setStep(Object.assign(Object.assign(Object.assign({}, step), newStep), { selectedId: id }));\r\n    };\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(StaticStepContext.Provider, { value: {\r\n            editorStep: step,\r\n            previewStep: previewStep,\r\n            allProps,\r\n            setFocus,\r\n        } },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(LinkableSection, { onActivation: setFocus, onReset: resetFocus }, children)));\r\n}\r\nfunction DynamicScrollycoding(_a) {\r\n    var { children, editorSteps, codeConfig, presetConfig, start = 0, className, style, hasPreviewSteps } = _a, rest = __rest(_a, [\"children\", \"editorSteps\", \"codeConfig\", \"presetConfig\", \"start\", \"className\", \"style\", \"hasPreviewSteps\"]);\r\n    const { stepsChildren, previewChildren } = extractPreviewSteps(children, hasPreviewSteps);\r\n    const withPreview = presetConfig || hasPreviewSteps;\r\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\r\n        stepIndex: start,\r\n        step: editorSteps[start],\r\n    });\r\n    const tab = state.step;\r\n    function onStepChange(index) {\r\n        setState({ stepIndex: index, step: editorSteps[index] });\r\n    }\r\n    function onTabClick(filename) {\r\n        const newStep = updateEditorStep(state.step, filename, null);\r\n        setState(Object.assign(Object.assign({}, state), { step: newStep }));\r\n    }\r\n    function onLinkActivation(stepIndex, filename, focus) {\r\n        const newStep = updateEditorStep(editorSteps[stepIndex], filename, focus);\r\n        setState(Object.assign(Object.assign({}, state), { stepIndex, step: newStep }));\r\n    }\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"section\", { className: `ch-scrollycoding ${withPreview ? \"ch-scrollycoding-with-preview\" : \"\"} ${className || \"\"}`, style: style, \"data-ch-theme\": codeConfig === null || codeConfig === void 0 ? void 0 : codeConfig.themeName },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-scrollycoding-content\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(Scroller, { onStepChange: onStepChange, triggerPosition: codeConfig === null || codeConfig === void 0 ? void 0 : codeConfig.triggerPosition }, stepsChildren.map((children, i) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Step, { as: \"div\", key: i, index: i, onClick: () => onStepChange(i), className: \"ch-scrollycoding-step-content\", \"data-selected\": i === state.stepIndex ? \"true\" : undefined },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(LinkableSection, { onActivation: ({ fileName, focus }) => {\r\n                        onLinkActivation(i, fileName, focus);\r\n                    }, onReset: () => {\r\n                        onStepChange(i);\r\n                    } }, children)))))),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-scrollycoding-sticker\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerCode, Object.assign({ showExpandButton: true }, rest, tab, { codeConfig: codeConfig, onTabClick: onTabClick })),\r\n            presetConfig ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Preview, { className: \"ch-scrollycoding-preview\", files: tab.files, presetConfig: presetConfig })) : hasPreviewSteps ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Preview, Object.assign({ className: \"ch-scrollycoding-preview\" }, previewChildren[state.stepIndex][\"props\"]))) : null)));\r\n}\n\nfunction Slideshow(_a) {\r\n    var { children, className, code, codeConfig, editorSteps, autoFocus, hasPreviewSteps, \r\n    // Set the initial slide index\r\n    start = 0, \r\n    // Called when the slideshow state changes and returns the current state object\r\n    onChange: onSlideshowChange = () => { }, presetConfig, style, autoPlay, loop = false } = _a, rest = __rest(_a, [\"children\", \"className\", \"code\", \"codeConfig\", \"editorSteps\", \"autoFocus\", \"hasPreviewSteps\", \"start\", \"onChange\", \"presetConfig\", \"style\", \"autoPlay\", \"loop\"]);\r\n    const { stepsChildren, previewChildren } = extractPreviewSteps(children, hasPreviewSteps);\r\n    const withPreview = presetConfig || hasPreviewSteps;\r\n    const hasNotes = stepsChildren.some((child) => { var _a; return (_a = child.props) === null || _a === void 0 ? void 0 : _a.children; });\r\n    const maxSteps = editorSteps.length - 1;\r\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {\r\n        const startIndex = clamp$2(start, 0, maxSteps);\r\n        return {\r\n            stepIndex: startIndex,\r\n            step: editorSteps[startIndex],\r\n        };\r\n    });\r\n    const { stepIndex: currentIndex, step: tab } = state;\r\n    const atSlideshowEnd = currentIndex === maxSteps;\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        onSlideshowChange({ index: currentIndex });\r\n    }, [currentIndex]);\r\n    function onTabClick(filename) {\r\n        const newStep = updateEditorStep(tab, filename, null);\r\n        setState(Object.assign(Object.assign({}, state), { step: newStep }));\r\n    }\r\n    function setIndex(newIndex) {\r\n        const stepIndex = clamp$2(newIndex, 0, maxSteps);\r\n        setState({ stepIndex, step: editorSteps[stepIndex] });\r\n    }\r\n    function nextSlide() {\r\n        setState(s => {\r\n            const stepIndex = loop\r\n                ? (s.stepIndex + 1) % (maxSteps + 1)\r\n                : clamp$2(s.stepIndex + 1, 0, maxSteps);\r\n            return {\r\n                stepIndex,\r\n                step: editorSteps[stepIndex],\r\n            };\r\n        });\r\n    }\r\n    useInterval(nextSlide, autoPlay);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: `ch-slideshow ${withPreview ? \"ch-slideshow-with-preview\" : \"\"} ${className || \"\"}`, style: style, \"data-ch-theme\": codeConfig.themeName },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-slideshow-slide\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerCode, Object.assign({}, rest, tab, { codeConfig: Object.assign(Object.assign({}, codeConfig), code), onTabClick: onTabClick })),\r\n            presetConfig ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Preview, { className: \"ch-slideshow-preview\", files: tab.files, presetConfig: presetConfig })) : hasPreviewSteps ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Preview, Object.assign({ className: \"ch-slideshow-preview\" }, previewChildren[currentIndex][\"props\"]))) : null),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-slideshow-notes\" },\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-slideshow-range\" },\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { onClick: () => setIndex(currentIndex - 1), disabled: currentIndex === 0 }, \"Prev\"),\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"input\", { max: maxSteps, min: 0, step: 1, type: \"range\", value: currentIndex, onChange: e => setIndex(+e.target.value), ref: useAutoFocusRef(autoFocus), autoFocus: autoFocus }),\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { onClick: nextSlide, disabled: atSlideshowEnd }, \"Next\")),\r\n            hasNotes && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-slideshow-note\" }, stepsChildren[currentIndex])))));\r\n}\r\nfunction useAutoFocusRef(autoFocus) {\r\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        autoFocus && ref.current.focus();\r\n    }, []);\r\n    return ref;\r\n}\n\nfunction Annotation() {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null, \"\\\"error: code hike remark plugin not running or annotation isn't at the right place\\\"\"));\r\n}\r\nconst annotationsMap = {\r\n    box: Box,\r\n    bg: MultilineMark,\r\n    label: Label,\r\n    link: CodeLink,\r\n    mark: Mark,\r\n    withClass: WithClass,\r\n};\r\nfunction Mark(props) {\r\n    if (props.isInline) {\r\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(InlineMark, Object.assign({}, props));\r\n    }\r\n    else {\r\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MultilineMark, Object.assign({}, props));\r\n    }\r\n}\r\nfunction MultilineMark({ children, data, style, lines, }) {\r\n    const content = getContent(lines);\r\n    const className = `ch-code-multiline-mark ` + (data !== null && data !== void 0 ? data : \"\");\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: style, className: className },\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"ch-code-multiline-mark-border\" }),\r\n        children,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(CopyButton, { className: \"ch-code-button\", content: content })));\r\n}\r\nfunction getContent(lines) {\r\n    return lines\r\n        .map(l => l.annotatedGroups\r\n        .flatMap(ag => {\r\n        var _a;\r\n        return (_a = ag.prev) === null || _a === void 0 ? void 0 : _a.groups.flatMap(tg => tg.tokens.map(t => t.content));\r\n    })\r\n        .join(\"\"))\r\n        .join(\"\\n\");\r\n}\r\nfunction InlineMark({ children, data }) {\r\n    const className = \"ch-code-inline-mark \" + (data !== null && data !== void 0 ? data : \"\");\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: className, style: {\r\n            background: tryGuessColor(children) || undefined,\r\n        } }, children));\r\n}\r\nfunction tryGuessColor(children) {\r\n    var _a, _b, _c;\r\n    try {\r\n        const child = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children)[0];\r\n        const grandChild = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(((_a = child === null || child === void 0 ? void 0 : child.props) === null || _a === void 0 ? void 0 : _a.children) || [])[0];\r\n        const grandGrandChild = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(((_b = grandChild === null || grandChild === void 0 ? void 0 : grandChild.props) === null || _b === void 0 ? void 0 : _b.children) || [])[0];\r\n        const { color } = ((_c = grandGrandChild === null || grandGrandChild === void 0 ? void 0 : grandGrandChild.props) === null || _c === void 0 ? void 0 : _c.style) || {};\r\n        if (color) {\r\n            return transparent(color, 0.2);\r\n        }\r\n        return undefined;\r\n    }\r\n    catch (e) {\r\n        return undefined;\r\n    }\r\n}\r\nfunction Box({ children, data }) {\r\n    const outlineColor = typeof data === \"string\" ? data : undefined;\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"ch-code-box-annotation\", style: { outlineColor } }, children));\r\n}\r\nfunction WithClass({ children, data, style, }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { style: style, className: data }, children));\r\n}\r\nfunction Label({ children, data, style }) {\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-code-label-annotation\", style: style },\r\n        children,\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"ch-code-label-annotation-text\" }, (data === null || data === void 0 ? void 0 : data.children) || data)));\r\n}\r\nfunction CodeLink({ children, isInline, style, data, }) {\r\n    const url = (data === null || data === void 0 ? void 0 : data.url) || data;\r\n    const title = data === null || data === void 0 ? void 0 : data.title;\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", { href: url, title: title, className: isInline ? \"ch-code-inline-link\" : \"ch-code-link\", style: style }, children));\r\n}\n\nfunction InlineCode(_a) {\r\n    var { className, codeConfig, children, code } = _a, rest = __rest(_a, [\"className\", \"codeConfig\", \"children\", \"code\"]);\r\n    const { lines } = code;\r\n    const allTokens = lines.flatMap(line => line.tokens);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", Object.assign({ \"data-ch-theme\": codeConfig.themeName, className: \"ch-inline-code not-prose\" +\r\n            (className ? \" \" + className : \"\") }, rest),\r\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", null, allTokens.map((token, j) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", Object.assign({ key: j }, token.props), token.content))))));\r\n}\n\nconst CH = {\r\n    Code,\r\n    Section,\r\n    SectionLink,\r\n    SectionCode,\r\n    Spotlight,\r\n    Scrollycoding,\r\n    Preview,\r\n    annotations: annotationsMap,\r\n    Annotation,\r\n    Slideshow,\r\n    InlineCode,\r\n    CodeSlot,\r\n    PreviewSlot,\r\n};\r\nconst internal = {\r\n    MiniBrowser,\r\n    EditorSpring,\r\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGUtaGlrZS9tZHgvZGlzdC9jb21wb25lbnRzLmVzbS5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMwQjtBQUMwQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsSUFBSSxFQUFFLElBQUk7QUFDdEQsc0VBQXNFLEVBQUUsV0FBVztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBLGVBQWUsZ0NBQWdDLEVBQUU7QUFDakQ7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QjtBQUNBLDBCQUEwQixFQUFFO0FBQzVCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIseUJBQXlCLHlCQUF5QjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGtEQUFxQjtBQUMzQixNQUFNLDRDQUFlO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlDQUFZO0FBQ3RDLElBQUksNENBQWU7QUFDbkI7QUFDQSxLQUFLO0FBQ0wsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJDQUFjO0FBQ3REO0FBQ0Esd0NBQXdDLDJDQUFjO0FBQ3REO0FBQ0Esd0JBQXdCLHlDQUFZO0FBQ3BDO0FBQ0EsWUFBWSw0Q0FBNEMsRUFBRSwwQ0FBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdEQUFtQixXQUFXLG9DQUFvQztBQUMzRixZQUFZLGdEQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFtQixVQUFVLGtCQUFrQjtBQUN2RSxtQ0FBbUMsZ0RBQW1CLFdBQVcsa0NBQWtDO0FBQ25HO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQW1CLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLHdCQUF3QixnREFBbUI7QUFDM0MsYUFBYTtBQUNiLFlBQVksZ0RBQW1CO0FBQy9CLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJDQUFjO0FBQzVDLElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7O0FBR047QUFDQSwrQ0FBK0MsNEJBQTRCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQSxvRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw2QkFBNkI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsV0FBVzs7QUFFcEQsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSixrQkFBa0IsNkJBQTZCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEIsRUFBRTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsNkJBQTZCO0FBQzlFO0FBQ0EsaUJBQWlCLDBEQUEwRDtBQUMzRTtBQUNBO0FBQ0EsaURBQWlELDZCQUE2QjtBQUM5RTtBQUNBLGlCQUFpQiw0REFBNEQ7QUFDN0U7QUFDQSw2Q0FBNkMsNkJBQTZCO0FBQzFFO0FBQ0E7QUFDQSxhQUFhLG1EQUFtRDtBQUNoRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QywrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVHQUF1RztBQUN0SSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixlQUFlO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGdEQUFtQixDQUFDLDJDQUFjLDRCQUE0QixnQkFBZ0IsU0FBUyxnREFBbUIseUJBQXlCLFdBQVcsWUFBWTtBQUN0SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFlBQVksbUJBQW1CO0FBQzVGLDZEQUE2RCxZQUFZLG1CQUFtQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDZDQUE2QyxXQUFXO0FBQ3hELG9CQUFvQjtBQUNwQixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUxBQXlMLGlCQUFpQixhQUFhO0FBQ3ZOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVcsK0RBQStEO0FBQ3ZILEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JELDRCQUE0Qix5QkFBeUI7QUFDckQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDLFdBQVcsMENBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZDQUE2QztBQUNoRTtBQUNBO0FBQ0EsWUFBWSwwQ0FBMEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0EseUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsWUFBWSw4RkFBOEY7QUFDdE4seUNBQXlDLGVBQWU7QUFDeEQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQix1RkFBdUY7QUFDbEgsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFtQixjQUFjLDJGQUEyRjtBQUN4SSxRQUFRLGdEQUFtQixjQUFjLG9HQUFvRztBQUM3STtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQsWUFBWSxnREFBbUIsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0ZBQWdGO0FBQ3pGO0FBQ0EscUJBQXFCLHlDQUF5QztBQUM5RCxZQUFZLGdEQUFtQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1Q0FBdUM7QUFDaEQsUUFBUSxnREFBbUIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLE1BQU07QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw4QkFBOEIsNENBQTRDLHFDQUFxQztBQUMvRztBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLDJCQUEyQiw2RkFBNkY7QUFDeEgsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFlBQVksZ0RBQW1CLGtDQUFrQyxtQ0FBbUMsZ0RBQW1CLFVBQVUsd0xBQXdMO0FBQ3pUO0FBQ0EsaUJBQWlCLHNFQUFzRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFtQixDQUFDLDJDQUFjO0FBQzlDO0FBQ0Esb0JBQW9CLGdEQUFtQixjQUFjLDJJQUEySTtBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQW1CLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFvQjtBQUM3RCxhQUFhLDRFQUE0RTtBQUN6RixZQUFZLGdEQUFtQixjQUFjLG1KQUFtSjtBQUNoTSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsd0VBQXdFO0FBQzdGLFlBQVksZ0RBQW1CLENBQUMsMkNBQWM7QUFDOUMsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQW1CLENBQUMsMkNBQWMsSUFBSSxVQUFVO0FBQ2hFLCtCQUErQixnREFBbUIsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCLE1BQU0sMkJBQTJCO0FBQzdGO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLFlBQVksZ0RBQW1CLGtCQUFrQixtR0FBbUc7QUFDcEosZ0JBQWdCLGdEQUFtQixnQkFBZ0IsaUNBQWlDO0FBQ3BGLEtBQUs7QUFDTDtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUMsWUFBWSxnREFBbUIsVUFBVTtBQUN6QztBQUNBO0FBQ0EsV0FBVztBQUNYLHlEQUF5RCxnREFBbUIsb0JBQW9CLG9FQUFvRTtBQUNwSyxRQUFRLGdEQUFtQjtBQUMzQjtBQUNBLDJCQUEyQiwrQkFBK0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnREFBbUIsV0FBVyxTQUFTLFNBQVMsY0FBYztBQUM5RSxLQUFLO0FBQ0wsd0JBQXdCLGdEQUFtQixjQUFjLDBLQUEwSyxNQUFNLGdEQUFtQixDQUFDLDJDQUFjO0FBQzNRO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RCxZQUFZLGdEQUFtQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxHQUFHLE1BQU0sR0FBRztBQUNoRDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsc0JBQXNCLDRCQUE0QjtBQUNsRCxnQ0FBZ0MsMkNBQWM7QUFDOUMsWUFBWSxnREFBbUIsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsUUFBUSxnREFBbUIsVUFBVSxpR0FBaUcsWUFBWSxnREFBbUIsV0FBVyxzRkFBc0YsTUFBTSxnREFBbUIsV0FBVyxtTUFBbU07QUFDN2U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUSxzSEFBc0g7QUFDdkssS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMEJBQTBCO0FBQ3BDLG9DQUFvQyxPQUFPO0FBQzNDLFlBQVksc0JBQXNCO0FBQ2xDLDBDQUEwQyxnREFBbUIscUJBQXFCLDREQUE0RCxNQUFNLGdEQUFtQixvQkFBb0IscUdBQXFHO0FBQ2hTO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RCxZQUFZLGdEQUFtQixZQUFZLHVDQUF1QztBQUNsRjtBQUNBLDJCQUEyQixVQUFVLHFEQUFxRCxzREFBc0Q7QUFDaEo7QUFDQSxZQUFZLGdEQUFtQixZQUFZLHNDQUFzQztBQUNqRixRQUFRLGdEQUFtQixnQkFBZ0I7QUFDM0M7QUFDQSwwRUFBMEU7QUFDMUUsaUNBQWlDLGdEQUFtQixlQUFlLDZKQUE2SjtBQUNoTztBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBLElBQUksZ0RBQW1CLHdCQUF3QixlQUFlLDhCQUE4QixrRkFBa0YscURBQXFEO0FBQ25POztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHlDQUFZOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsa0VBQXVCO0FBQ3pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLHdEQUF3RCxrREFBcUIsR0FBRyw0Q0FBZTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsMkNBQWM7QUFDdEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZDQUE2Qzs7O0FBRzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QixZQUFZLFdBQVc7QUFDdkIsWUFBWSxnREFBbUIsNEJBQTRCLDJDQUEyQztBQUN0RztBQUNBO0FBQ0EsYUFBYSxzQkFBc0IsY0FBYywyQ0FBYztBQUMvRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWSxtQkFBbUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZLHlEQUF5RDtBQUNsSDtBQUNBOztBQUVBLGtCQUFrQiw2Q0FBZ0I7QUFDbEMsVUFBVSxnREFBZ0Q7QUFDMUQsNEJBQTRCLGdEQUFtQixvQkFBb0IsY0FBYztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQW1CLHdCQUF3QixXQUFXLFVBQVU7QUFDNUUsUUFBUSxnREFBbUIsVUFBVSx1QkFBdUI7QUFDNUQsWUFBWSxnREFBbUIsVUFBVSxpQ0FBaUM7QUFDMUUsWUFBWSxnREFBbUIsVUFBVSwrQkFBK0I7QUFDeEUsZ0JBQWdCLGdEQUFtQixVQUFVLDhDQUE4QztBQUMzRixDQUFDO0FBQ0QsNkNBQWdCO0FBQ2hCLFVBQVUsc0NBQXNDO0FBQ2hELDRCQUE0QixnREFBbUIsb0JBQW9CLGNBQWM7QUFDakYsWUFBWSxnREFBbUIsd0JBQXdCLFdBQVcsVUFBVTtBQUM1RSxRQUFRLGdEQUFtQixVQUFVLDhCQUE4QjtBQUNuRSxZQUFZLGdEQUFtQixVQUFVLGlDQUFpQztBQUMxRTtBQUNBLENBQUM7QUFDRCwyQkFBMkIsT0FBTztBQUNsQyxZQUFZLGdEQUFtQixDQUFDLDJDQUFjO0FBQzlDLFFBQVEsZ0RBQW1CLFVBQVUsZ0NBQWdDO0FBQ3JFLFlBQVksZ0RBQW1CO0FBQy9CLFFBQVEsZ0RBQW1CLFVBQVUsa0NBQWtDO0FBQ3ZFLFFBQVEsZ0RBQW1CLFVBQVUsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQSxZQUFZLGdEQUFtQixVQUFVLCtCQUErQjtBQUN4RSxRQUFRLGdEQUFtQixVQUFVLG1EQUFtRDtBQUN4RixRQUFRLGdEQUFtQixVQUFVLG9DQUFvQztBQUN6RSxRQUFRLGdEQUFtQixVQUFVLHFEQUFxRDtBQUMxRixRQUFRLGdEQUFtQixVQUFVLG9DQUFvQztBQUN6RSxRQUFRLGdEQUFtQixVQUFVLG9EQUFvRDtBQUN6Rjs7QUFFQSxvQkFBb0IsNkNBQWdCO0FBQ3BDO0FBQ0EsVUFBVSx3R0FBd0c7QUFDbEgsWUFBWSxnREFBbUIsd0JBQXdCLFVBQVUsVUFBVSw0Q0FBNEM7QUFDdkgsUUFBUSxnREFBbUIsVUFBVSxpQ0FBaUM7QUFDdEUsWUFBWSxnREFBbUIsa0JBQWtCLDRHQUE0RztBQUM3SixRQUFRLGdEQUFtQixVQUFVLGtGQUFrRjtBQUN2SCx1QkFBdUIsZ0RBQW1CLENBQUMsMkNBQWM7QUFDekQsWUFBWSxnREFBbUIsVUFBVTtBQUN6QztBQUNBLG1CQUFtQjtBQUNuQixnQkFBZ0IsZ0RBQW1CLGtCQUFrQiw4SEFBOEg7QUFDbkwsWUFBWSxnREFBbUIsVUFBVSxrRkFBa0Y7QUFDM0gsQ0FBQztBQUNELHlCQUF5QiwrREFBK0Q7QUFDeEYsWUFBWSxnREFBbUIsQ0FBQywyQ0FBYztBQUM5QyxzQkFBc0IsZ0RBQW1CLFVBQVUscUNBQXFDO0FBQ3hGLDJCQUEyQixnREFBbUIsdUJBQXVCLGdEQUFtQjtBQUN4RixvQkFBb0Isc0JBQXNCLE1BQU0sZ0RBQW1CLFVBQVUsbUtBQW1LO0FBQ2hQLFlBQVksZ0RBQW1CLGFBQWEsY0FBYztBQUMxRCxRQUFRLGdEQUFtQixVQUFVLFNBQVMsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLGVBQWUsZ0RBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBbUI7QUFDL0IsUUFBUSxnREFBbUIsV0FBVyxTQUFTLGdCQUFnQjtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsZ0RBQW1CLFdBQVcsaUNBQWlDO0FBQzlFLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQSxZQUFZLGdEQUFtQixVQUFVLGdEQUFnRCxrQkFBa0IsYUFBYSxTQUFTLGdEQUFtQixDQUFDLDJDQUFjLElBQUksUUFBUTtBQUMvSyxRQUFRLGdEQUFtQjtBQUMzQjtBQUNBO0FBQ0EsWUFBWSxnREFBbUI7QUFDL0IsbUJBQW1CLGdEQUFtQixVQUFVLGlDQUFpQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7O0FBRUEsbUNBQW1DLG1EQUFtRDtBQUN0RixZQUFZLGdEQUFtQixVQUFVLDBCQUEwQjtBQUNuRSxRQUFRLGdEQUFtQixVQUFVO0FBQ3JDO0FBQ0EsMENBQTBDLGVBQWU7QUFDekQsZUFBZTtBQUNmLFlBQVksZ0RBQW1CLG9CQUFvQix1Q0FBdUM7QUFDMUYsWUFBWSxnREFBbUIsb0JBQW9CLFNBQVMsc0JBQXNCLGdEQUFnRDtBQUNsSTs7QUFFQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBbUIsNEJBQTRCLDhIQUE4SDtBQUN6TDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsMEJBQTBCO0FBQ25ELCtCQUErQix5QkFBeUI7QUFDeEQsNkJBQTZCLGdEQUFtQixVQUFVLDBDQUEwQyxVQUFVO0FBQzlHLFFBQVEsZ0RBQW1CLFVBQVUscUNBQXFDO0FBQzFFLFlBQVksZ0RBQW1CO0FBQy9CLFFBQVEsZ0RBQW1CLFVBQVUseUNBQXlDO0FBQzlFLFlBQVksZ0RBQW1CLDZCQUE2QjtBQUM1RCxzQkFBc0Isa0JBQWtCO0FBQ3hDLHNCQUFzQixrQkFBa0I7QUFDeEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLGlCQUFpQiwwQkFBMEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUIsMEJBQTBCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4REFBOEQ7QUFDMUUsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnREFBbUIsbUJBQW1CO0FBQzdELDJDQUEyQztBQUMzQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQW1CLG1CQUFtQjtBQUM3RCxxR0FBcUc7QUFDckcsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQThEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QixnREFBbUIsbUJBQW1CLGdIQUFnSDtBQUM3SyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QixnREFBbUIsbUJBQW1CLGdIQUFnSDtBQUM3SyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhEQUE4RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix1QkFBdUIsZ0RBQW1CLG1CQUFtQixnSEFBZ0g7QUFDN0ssU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix1QkFBdUIsZ0RBQW1CLG1CQUFtQixnSEFBZ0g7QUFDN0ssU0FBUztBQUNUO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQWtEO0FBQzVFO0FBQ0Esb0RBQW9ELG1GQUFtRix1QkFBdUIsZ0JBQWdCLHNJQUFzSTtBQUNwVCxZQUFZLGdEQUFtQiw0QkFBNEIsc0JBQXNCLGdDQUFnQyx3Q0FBd0MsaUJBQWlCLGNBQWMsR0FBRztBQUMzTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdURBQXVEO0FBQ2hHLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVEQUF1RDtBQUNoRyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNqQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUNBQXFDO0FB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LFlBQVksZ0RBQW1CLFVBQVUscURBQXFEO0FBQzlGO0FBQ0EsUUFBUSxnREFBbUIsVUFBVSw0Q0FBNEM7QUFDakY7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQSxZQUFZLGdEQUFtQixRQUFRLHFHQUFxRztBQUM1STs7QUFFQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xELFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksZ0RBQW1CLHlCQUF5QjtBQUN4RCxnREFBZ0Q7QUFDaEQsUUFBUSxnREFBbUIsNENBQTRDLGdEQUFtQix5QkFBeUIsUUFBUTtBQUMzSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlLWhpa2UvbWR4L2Rpc3QvY29tcG9uZW50cy5lc20ubWpzPzg5ZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgfSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxuXG4vLyBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81MzkzNjYyMy8xMzI1NjQ2XHJcbmNvbnN0IGlzVmFsaWRIZXggPSAoaGV4KSA9PiAvXiMoW0EtRmEtZjAtOV17Myw0fSl7MSwyfSQvLnRlc3QoaGV4KTtcclxuY29uc3QgZ2V0Q2h1bmtzRnJvbVN0cmluZyA9IChzdCwgY2h1bmtTaXplKSA9PiBzdC5tYXRjaChuZXcgUmVnRXhwKGAueyR7Y2h1bmtTaXplfX1gLCBcImdcIikpO1xyXG5jb25zdCBjb252ZXJ0SGV4VW5pdFRvMjU2ID0gKGhleCkgPT4gcGFyc2VJbnQoaGV4LnJlcGVhdCgyIC8gaGV4Lmxlbmd0aCksIDE2KTtcclxuZnVuY3Rpb24gZ2V0QWxwaGFGbG9hdChhLCBhbHBoYSkge1xyXG4gICAgaWYgKHR5cGVvZiBhICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEgLyAyNTU7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGFscGhhICE9IFwibnVtYmVyXCIgfHwgYWxwaGEgPCAwIHx8IGFscGhhID4gMSkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFscGhhO1xyXG59XHJcbmZ1bmN0aW9uIGhleFRvT2JqZWN0KGhleCkge1xyXG4gICAgaWYgKCFoZXgpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1ZhbGlkSGV4KGhleCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbG9yIHN0cmluZywgbXVzdCBiZSBhIHZhbGlkIGhleCBjb2xvclwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGguZmxvb3IoKGhleC5sZW5ndGggLSAxKSAvIDMpO1xyXG4gICAgY29uc3QgaGV4QXJyID0gZ2V0Q2h1bmtzRnJvbVN0cmluZyhoZXguc2xpY2UoMSksIGNodW5rU2l6ZSk7XHJcbiAgICBjb25zdCBbciwgZywgYiwgYV0gPSBoZXhBcnIubWFwKGNvbnZlcnRIZXhVbml0VG8yNTYpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByLFxyXG4gICAgICAgIGcsXHJcbiAgICAgICAgYixcclxuICAgICAgICBhOiBnZXRBbHBoYUZsb2F0KGEsIDEpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBvYmplY3RUb0hleChvYmplY3QpIHtcclxuICAgIGlmICghb2JqZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgciwgZywgYiwgYSB9ID0gb2JqZWN0O1xyXG4gICAgY29uc3QgYWxwaGEgPSBNYXRoLnJvdW5kKGEgKiAyNTUpO1xyXG4gICAgcmV0dXJuIGAjJHtyLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIil9JHtnXHJcbiAgICAgICAgLnRvU3RyaW5nKDE2KVxyXG4gICAgICAgIC5wYWRTdGFydCgyLCBcIjBcIil9JHtiXHJcbiAgICAgICAgLnRvU3RyaW5nKDE2KVxyXG4gICAgICAgIC5wYWRTdGFydCgyLCBcIjBcIil9JHthbHBoYVxyXG4gICAgICAgIC50b1N0cmluZygxNilcclxuICAgICAgICAucGFkU3RhcnQoMiwgXCIwXCIpfWA7XHJcbn1cclxuZnVuY3Rpb24gdHJhbnNwYXJlbnQoY29sb3IsIG9wYWNpdHkpIHtcclxuICAgIGlmICghY29sb3IpIHtcclxuICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHIsIGcsIGIsIGEgfSA9IGhleFRvT2JqZWN0KGNvbG9yKTtcclxuICAgIHJldHVybiBvYmplY3RUb0hleCh7IHIsIGcsIGIsIGE6IGEgKiBvcGFjaXR5IH0pO1xyXG59XG5cbmZ1bmN0aW9uIG1hcCh0d2VlbiwgZm4pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJldjogZm4odHdlZW4ucHJldiwgXCJwcmV2XCIpLFxyXG4gICAgICAgIG5leHQ6IGZuKHR3ZWVuLm5leHQsIFwibmV4dFwiKSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gd2l0aERlZmF1bHQodCwgZGVmdCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcmV2OiAodCA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0LnByZXYpID09PSB1bmRlZmluZWQgPyBkZWZ0IDogdC5wcmV2LFxyXG4gICAgICAgIG5leHQ6ICh0ID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHQubmV4dCkgPT09IHVuZGVmaW5lZCA/IGRlZnQgOiB0Lm5leHQsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG1hcFdpdGhEZWZhdWx0KHR3ZWVuLCBkZWZ0LCBmbikge1xyXG4gICAgcmV0dXJuIG1hcCh3aXRoRGVmYXVsdCh0d2VlbiwgZGVmdCksIGZuKTtcclxufVxyXG5mdW5jdGlvbiBhbnlWYWx1ZSh0d2VlbiwgZm4pIHtcclxuICAgIHJldHVybiBmbih0d2Vlbi5wcmV2KSB8fCBmbih0d2Vlbi5uZXh0KTtcclxufVxuXG5mdW5jdGlvbiBjb2RlVG9UZXh0KGNvZGUpIHtcclxuICAgIHJldHVybiBjb2RlLmxpbmVzXHJcbiAgICAgICAgLm1hcChsaW5lID0+IGxpbmUudG9rZW5zLm1hcCh0b2tlbiA9PiB0b2tlbi5jb250ZW50KS5qb2luKFwiXCIpKVxyXG4gICAgICAgIC5qb2luKFwiXFxuXCIpO1xyXG59XG5cbmZ1bmN0aW9uIG1hcEZvY3VzVG9MaW5lTnVtYmVycyhmb2N1cywgbGluZXMpIHtcclxuICAgIGlmICghZm9jdXMpIHtcclxuICAgICAgICAvLyBmb2N1cyBhbGwgbGluZXNcclxuICAgICAgICByZXR1cm4gbWVyZ2VUb09iamVjdChbLi4ubGluZXMua2V5cygpXS5tYXAobGluZUluZGV4ID0+ICh7XHJcbiAgICAgICAgICAgIFtsaW5lSW5kZXggKyAxXTogdHJ1ZSxcclxuICAgICAgICB9KSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlVG9PYmplY3Qoc3BsaXRQYXJ0cyhmb2N1cykubWFwKHBhcnNlUGFydFRvT2JqZWN0KSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3BsaXRQYXJ0cyhmb2N1cykge1xyXG4gICAgcmV0dXJuIGZvY3VzLnNwbGl0KC8sKD8hW15cXFtdKlxcXSkvZyk7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VUb09iamVjdChlbnRyaWVzKSB7XHJcbiAgICByZXR1cm4gZW50cmllcy5yZWR1Y2UoKGFjYywgb2JqKSA9PiBPYmplY3QuYXNzaWduKGFjYywgb2JqKSwge30pO1xyXG59XHJcbmZ1bmN0aW9uIGhhc0NvbHVtbnMocGFydCkge1xyXG4gICAgcmV0dXJuICEhcGFydC5tYXRjaCgvKFxcZCspXFxbKC4rKVxcXS8pO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlUGFydFRvT2JqZWN0KHBhcnQpIHtcclxuICAgIC8vIGEgcGFydCBjb3VsZCBiZVxyXG4gICAgLy8gLSBhIGxpbmUgbnVtYmVyOiBcIjJcIlxyXG4gICAgLy8gLSBhIGxpbmUgcmFuZ2U6IFwiNTo5XCJcclxuICAgIC8vIC0gYSBsaW5lIG51bWJlciB3aXRoIGEgY29sdW1uIHNlbGVjdG9yOiBcIjJbMSwzOjUsOV1cIlxyXG4gICAgY29uc3QgY29sdW1uc01hdGNoID0gcGFydC5tYXRjaCgvKFxcZCspXFxbKC4rKVxcXS8pO1xyXG4gICAgaWYgKGNvbHVtbnNNYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IFssIGxpbmUsIGNvbHVtbnNdID0gY29sdW1uc01hdGNoO1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbnNMaXN0ID0gY29sdW1uc1xyXG4gICAgICAgICAgICAuc3BsaXQoXCIsXCIpXHJcbiAgICAgICAgICAgIC5tYXAocGFyc2VFeHRyZW1lcyk7XHJcbiAgICAgICAgY29uc3QgbGluZU51bWJlciA9IE51bWJlcihsaW5lKTtcclxuICAgICAgICByZXR1cm4geyBbbGluZU51bWJlcl06IGNvbHVtbnNMaXN0IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbWVyZ2VUb09iamVjdChleHBhbmRTdHJpbmcocGFydCkubWFwKGxpbmVOdW1iZXIgPT4gKHtcclxuICAgICAgICAgICAgW2xpbmVOdW1iZXJdOiB0cnVlLFxyXG4gICAgICAgIH0pKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VFeHRyZW1lcyhwYXJ0KSB7XHJcbiAgICAvLyBUcmFuc2Zvcm1zIHNvbWV0aGluZyBsaWtlXHJcbiAgICAvLyAtIFwiMTozXCIgdG8ge3N0YXJ0OjEsIGVuZDogM31cclxuICAgIC8vIC0gXCI0XCIgdG8ge3N0YXJ0OjQsIGVuZDo0fVxyXG4gICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gcGFydC5zcGxpdChcIjpcIik7XHJcbiAgICBpZiAoIWlzTmF0dXJhbE51bWJlcihzdGFydCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRm9jdXNOdW1iZXJFcnJvcihzdGFydCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGFydE51bWJlciA9IE51bWJlcihzdGFydCk7XHJcbiAgICBpZiAoc3RhcnROdW1iZXIgPCAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IExpbmVPckNvbHVtbk51bWJlckVycm9yKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWVuZCkge1xyXG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydE51bWJlciwgZW5kOiBzdGFydE51bWJlciB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCFpc05hdHVyYWxOdW1iZXIoZW5kKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9jdXNOdW1iZXJFcnJvcihlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnROdW1iZXIsIGVuZDogK2VuZCB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIGZpcnN0IGFuZCBsYXN0IGluZGV4ZXMgdG8gZm9jdXMsIGJvdGggaW5jbHVkZWRcclxuICovXHJcbmZ1bmN0aW9uIGdldEZvY3VzRXh0cmVtZXMoZm9jdXMsIGxpbmVzKSB7XHJcbiAgICBpZiAoIWZvY3VzKSB7XHJcbiAgICAgICAgcmV0dXJuIFswLCBsaW5lcy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRm9jdXMoZm9jdXMpO1xyXG4gICAgICAgIGNvbnN0IGZvY3VzZWRJbmRleGVzID0gT2JqZWN0LmtleXMocGFyc2VkKS5tYXAoaSA9PiBwYXJzZUludChpLCAxMCkpO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIE1hdGgubWluKC4uLmZvY3VzZWRJbmRleGVzKSxcclxuICAgICAgICAgICAgTWF0aC5tYXgoLi4uZm9jdXNlZEluZGV4ZXMpLFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Rm9jdXNJbmRleGVzKGZvY3VzLCBsaW5lcykge1xyXG4gICAgaWYgKCFmb2N1cykge1xyXG4gICAgICAgIHJldHVybiBbLi4ubGluZXMua2V5cygpXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRm9jdXMoZm9jdXMpO1xyXG4gICAgICAgIGNvbnN0IGZvY3VzZWRJbmRleGVzID0gT2JqZWN0LmtleXMocGFyc2VkKS5tYXAoaSA9PiBwYXJzZUludChpLCAxMCkpO1xyXG4gICAgICAgIHJldHVybiBmb2N1c2VkSW5kZXhlcztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZUZvY3VzKGZvY3VzKSB7XHJcbiAgICBpZiAoIWZvY3VzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9jdXMgY2Fubm90IGJlIGVtcHR5XCIpO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IGZvY3VzXHJcbiAgICAgICAgICAgIC5zcGxpdCgvLCg/IVteXFxbXSpcXF0pL2cpXHJcbiAgICAgICAgICAgIC5tYXAocGFyc2VQYXJ0KTtcclxuICAgICAgICByZXR1cm4gZnJvbUVudHJpZXMocGFydHMuZmxhdCgpKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIC8vIFRPRE8gZW5oYW5jZSBlcnJvclxyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlUGFydChwYXJ0KSB7XHJcbiAgICAvLyBhIHBhcnQgY291bGQgYmVcclxuICAgIC8vIC0gYSBsaW5lIG51bWJlcjogXCIyXCJcclxuICAgIC8vIC0gYSBsaW5lIHJhbmdlOiBcIjU6OVwiXHJcbiAgICAvLyAtIGEgbGluZSBudW1iZXIgd2l0aCBhIGNvbHVtbiBzZWxlY3RvcjogXCIyWzEsMzo1LDldXCJcclxuICAgIGNvbnN0IGNvbHVtbnNNYXRjaCA9IHBhcnQubWF0Y2goLyhcXGQrKVxcWyguKylcXF0vKTtcclxuICAgIGlmIChjb2x1bW5zTWF0Y2gpIHtcclxuICAgICAgICBjb25zdCBbLCBsaW5lLCBjb2x1bW5zXSA9IGNvbHVtbnNNYXRjaDtcclxuICAgICAgICBjb25zdCBjb2x1bW5zTGlzdCA9IGNvbHVtbnMuc3BsaXQoXCIsXCIpLm1hcChleHBhbmRTdHJpbmcpO1xyXG4gICAgICAgIGNvbnN0IGxpbmVJbmRleCA9IE51bWJlcihsaW5lKSAtIDE7XHJcbiAgICAgICAgY29uc3QgY29sdW1uSW5kZXhlcyA9IGNvbHVtbnNMaXN0LmZsYXQoKS5tYXAoYyA9PiBjIC0gMSk7XHJcbiAgICAgICAgcmV0dXJuIFtbbGluZUluZGV4LCBjb2x1bW5JbmRleGVzXV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZXhwYW5kU3RyaW5nKHBhcnQpLm1hcChsaW5lTnVtYmVyID0+IFtcclxuICAgICAgICAgICAgbGluZU51bWJlciAtIDEsXHJcbiAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZXhwYW5kU3RyaW5nKHBhcnQpIHtcclxuICAgIC8vIFRyYW5zZm9ybXMgc29tZXRoaW5nIGxpa2VcclxuICAgIC8vIC0gXCIxOjNcIiB0byBbMSwyLDNdXHJcbiAgICAvLyAtIFwiNFwiIHRvIFs0XVxyXG4gICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gcGFydC5zcGxpdChcIjpcIik7XHJcbiAgICBpZiAoIWlzTmF0dXJhbE51bWJlcihzdGFydCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRm9jdXNOdW1iZXJFcnJvcihzdGFydCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGFydE51bWJlciA9IE51bWJlcihzdGFydCk7XHJcbiAgICBpZiAoc3RhcnROdW1iZXIgPCAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IExpbmVPckNvbHVtbk51bWJlckVycm9yKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWVuZCkge1xyXG4gICAgICAgIHJldHVybiBbc3RhcnROdW1iZXJdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCFpc05hdHVyYWxOdW1iZXIoZW5kKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9jdXNOdW1iZXJFcnJvcihlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsaXN0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TnVtYmVyOyBpIDw9ICtlbmQ7IGkrKykge1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaXN0O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzTmF0dXJhbE51bWJlcihuKSB7XHJcbiAgICBuID0gbi50b1N0cmluZygpOyAvLyBmb3JjZSB0aGUgdmFsdWUgaW4gY2FzZSBpdCBpcyBub3RcclxuICAgIHZhciBuMSA9IE1hdGguYWJzKG4pLCBuMiA9IHBhcnNlSW50KG4sIDEwKTtcclxuICAgIHJldHVybiAhaXNOYU4objEpICYmIG4yID09PSBuMSAmJiBuMS50b1N0cmluZygpID09PSBuO1xyXG59XHJcbmNsYXNzIExpbmVPckNvbHVtbk51bWJlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoYEludmFsaWQgbGluZSBvciBjb2x1bW4gbnVtYmVyIGluIGZvY3VzIHN0cmluZ2ApO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRm9jdXNOdW1iZXJFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyKGBJbnZhbGlkIG51bWJlciBcIiR7bnVtYmVyfVwiIGluIGZvY3VzIHN0cmluZ2ApO1xyXG4gICAgICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZnJvbUVudHJpZXMocGFpcnMpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG4gICAgbGV0IGluZGV4ID0gLTEsIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcclxuICAgICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxuXG5jb25zdCB1c2VMYXlvdXRFZmZlY3QkNCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcclxuICAgID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0XHJcbiAgICA6IFJlYWN0LnVzZUVmZmVjdDtcclxuLy8gZm9yIGRlYnVnZ2luZzpcclxuLy8gZXhwb3J0IGNvbnN0IHVzZUxheW91dEVmZmVjdCA9IChcclxuLy8gICBlZmZlY3Q6IGFueSxcclxuLy8gICBkZXBzPzogYW55XHJcbi8vICkgPT4ge31cclxuLy8gZnJvbSBodHRwczovL292ZXJyZWFjdGVkLmlvL21ha2luZy1zZXRpbnRlcnZhbC1kZWNsYXJhdGl2ZS13aXRoLXJlYWN0LWhvb2tzL1xyXG5mdW5jdGlvbiB1c2VJbnRlcnZhbChjYWxsYmFjaywgZGVsYXkpIHtcclxuICAgIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSBSZWFjdC51c2VSZWYoY2FsbGJhY2spO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzYXZlZENhbGxiYWNrLmN1cnJlbnQgPSBjYWxsYmFjaztcclxuICAgIH0sIFtjYWxsYmFja10pO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWRlbGF5ICYmIGRlbGF5ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlkID0gc2V0SW50ZXJ2YWwoKCkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KCksIGRlbGF5KTtcclxuICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpZCk7XHJcbiAgICB9LCBbZGVsYXldKTtcclxufVxuXG5mdW5jdGlvbiBjbGFtcCQyKHgsIG1pbiwgbWF4KSB7XHJcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoeCwgbWluKSwgbWF4KTtcclxufVxuXG5jb25zdCBERUZBVUxUX1dJRFRIID0gMjAwO1xyXG4vLyB0eXBlIERpbWVuc2lvbnNSZXN1bHQgPSB7XHJcbi8vICAgd2lkdGg6IG51bWJlclxyXG4vLyAgIGhlaWdodDogbnVtYmVyXHJcbi8vICAgbGluZVdpZHRoczogeyBwcmV2OiBudW1iZXI7IG5leHQ6IG51bWJlciB9XHJcbi8vICAgbGluZUhlaWdodDogbnVtYmVyXHJcbi8vICAgY29sV2lkdGg6IG51bWJlclxyXG4vLyB9XHJcbmZ1bmN0aW9uIHVzZURpbWVuc2lvbnMoY29kZSwgZm9jdXMsIG1pbkNvbHVtbnMsIGxpbmVOdW1iZXJzLCByb3dzLCBkZXBzKSB7XHJcbiAgICBjb25zdCBbZGltZW5zaW9ucywgc2V0RGltZW5zaW9uc10gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcclxuICAgIC8vIGluIGNhc2UgdGhlIGVsZW1lbnQgc3RhcnRzIGhpZGRlbiBodHRwczovL2dpdGh1Yi5jb20vY29kZS1oaWtlL2NvZGVoaWtlL2lzc3Vlcy8zNzJcclxuICAgIGNvbnN0IFt2aXNpYmlsaXR5LCBtYXJrQXNWaXNpYmxlXSA9IFJlYWN0LnVzZVN0YXRlKDApO1xyXG4gICAgY29uc3Qgd2luZG93V2lkdGggPSB1c2VXaW5kb3dXaWR0aCgpO1xyXG4gICAgY29uc3QgcHJldkxpbmVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XHJcbiAgICAvLyB0aGUgZWxlbWVudCB0byByZW5kZXIgYmVmb3JlIGRpbWVuc2lvbnMgYXJlIGNhbGN1bGF0ZWRcclxuICAgIGNvbnN0IHsgcHJldkxvbmdlc3RMaW5lLCBuZXh0TG9uZ2VzdExpbmUsIGVsZW1lbnQgfSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHByZXZMb25nZXN0TGluZSA9IGdldExvbmdlc3RMaW5lKGNvZGUucHJldiwgZm9jdXMucHJldik7XHJcbiAgICAgICAgY29uc3QgbmV4dExvbmdlc3RMaW5lID0gZ2V0TG9uZ2VzdExpbmUoY29kZS5uZXh0LCBmb2N1cy5uZXh0KTtcclxuICAgICAgICBjb25zdCBsaW5lcyA9IChjb2RlLnByZXYgfHwgY29kZS5uZXh0KVxyXG4gICAgICAgICAgICAudHJpbUVuZCgpXHJcbiAgICAgICAgICAgIC5zcGxpdChuZXdsaW5lUmUpO1xyXG4gICAgICAgIGNvbnN0IGxhcmdlc3RMaW5lTnVtYmVyID0gTWF0aC5tYXgobGluZXMubGVuZ3RoLCAxMCk7XHJcbiAgICAgICAgaWYgKHJvd3MpIHtcclxuICAgICAgICAgICAgLy8gbWFrZSB0aGUgbGluZXMgbWF0Y2ggdGhlIHJlcXVlc3RlZCBudW1iZXIgb2Ygcm93c1xyXG4gICAgICAgICAgICBjb25zdCBoZWlnaHRJbkxpbmVzID0gcm93cyA9PT0gXCJmb2N1c1wiXHJcbiAgICAgICAgICAgICAgICA/IGZvY3VzSGVpZ2h0SW5MaW5lcyhmb2N1cywgbGluZXMpXHJcbiAgICAgICAgICAgICAgICA6IHJvd3M7XHJcbiAgICAgICAgICAgIGxldCBpID0gbGluZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGhlaWdodEluTGluZXMpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goXCJcIik7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGV4dHJhIGxpbmVzIHRvIG1hdGNoIHRoZSByZXF1ZXN0ZWQgcm93c1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA+IGhlaWdodEluTGluZXMpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHdlIHJlbW92ZWQgcHJldkxvbmdlc3RMaW5lLCBhZGQgaXQgYmFja1xyXG4gICAgICAgICAgICBpZiAocHJldkxvbmdlc3RMaW5lICYmXHJcbiAgICAgICAgICAgICAgICAhbGluZXMuaW5jbHVkZXMocHJldkxvbmdlc3RMaW5lKSkge1xyXG4gICAgICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gPSBwcmV2TG9uZ2VzdExpbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXZvZCBzZXR0aW5nIHRoZSByZWYgbW9yZSB0aGFuIG9uY2UgaHR0cHM6Ly9naXRodWIuY29tL2NvZGUtaGlrZS9jb2RlaGlrZS9pc3N1ZXMvMjMyXHJcbiAgICAgICAgbGV0IHByZXZMaW5lUmVmU2V0ID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7IGNsYXNzTmFtZTogXCJjaC1jb2RlLXNjcm9sbC1wYXJlbnRcIiB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnJcIiwgbnVsbCksXHJcbiAgICAgICAgICAgIGxpbmVzLm1hcCgobGluZSwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gIXByZXZMaW5lUmVmU2V0ICYmIGxpbmUgPT09IHByZXZMb25nZXN0TGluZVxyXG4gICAgICAgICAgICAgICAgICAgID8gcHJldkxpbmVSZWZcclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHByZXZMaW5lUmVmU2V0ID0gcHJldkxpbmVSZWZTZXQgfHwgcmVmICE9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHJlZiwga2V5OiBpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcnMgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwiY2gtY29kZS1saW5lLW51bWJlclwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiX1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXJnZXN0TGluZU51bWJlcikpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlZnRQYWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDE2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIGxpbmUpKSkpO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpKSk7XHJcbiAgICAgICAgcmV0dXJuIHsgcHJldkxvbmdlc3RMaW5lLCBuZXh0TG9uZ2VzdExpbmUsIGVsZW1lbnQgfTtcclxuICAgIH0sIFtjb2RlXSk7XHJcbiAgICBjb25zdCBhbGxEZXBzID0gW1xyXG4gICAgICAgIC4uLmRlcHMsXHJcbiAgICAgICAgd2luZG93V2lkdGgsXHJcbiAgICAgICAgcHJldkxvbmdlc3RMaW5lLFxyXG4gICAgICAgIG5leHRMb25nZXN0TGluZSxcclxuICAgICAgICBtaW5Db2x1bW5zLFxyXG4gICAgICAgIHZpc2liaWxpdHksXHJcbiAgICBdO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0JDQoKCkgPT4ge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAocHJldkxpbmVSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBwbGwgPSBwcmV2TGluZVJlZi5jdXJyZW50O1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IHBsbCA9PT0gbnVsbCB8fCBwbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBsbC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlRWxlbWVudCA9IGNvbnRlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IGNvZGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICBpZiAoIXdpZHRoICYmIHZpc2liaWxpdHkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChbZW50cnldKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gZW50cnkuY29udGVudFJlY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya0FzVmlzaWJsZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoY29kZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPIGlzIGl0IGNsaWVudFdpZHRoIG9yIGNsaWVudFJlY3Q/XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVDb250ZW50RGl2ID0gcGxsID09PSBudWxsIHx8IHBsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGxsLnF1ZXJ5U2VsZWN0b3IoXCI6c2NvcGUgPiBkaXZcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVOdW1iZXJTcGFuID0gcGxsID09PSBudWxsIHx8IHBsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGxsLnF1ZXJ5U2VsZWN0b3IoXCI6c2NvcGUgPiBzcGFuXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBsbncgPSBsaW5lTnVtYmVyU3BhblxyXG4gICAgICAgICAgICAgICAgPyBnZXRXaWR0aFdpdGhQYWRkaW5nKGxpbmVOdW1iZXJTcGFuKVxyXG4gICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBwbHcgPSBnZXRXaWR0aFdpdGhvdXRQYWRkaW5nKGxpbmVDb250ZW50RGl2KTtcclxuICAgICAgICAgICAgY29uc3QgY29sV2lkdGggPSBwbHcgLyBwcmV2TG9uZ2VzdExpbmUubGVuZ3RoIHx8IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IG5sdyA9IG5leHRMb25nZXN0TGluZS5sZW5ndGggKiBjb2xXaWR0aDtcclxuICAgICAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IChfYSA9IGdldEhlaWdodFdpdGhvdXRQYWRkaW5nKGxpbmVDb250ZW50RGl2KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMjA7XHJcbiAgICAgICAgICAgIGNvbnN0IGQgPSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJXaWR0aDogZ2V0V2lkdGhXaXRob3V0UGFkZGluZyhjb2RlRWxlbWVudC5wYXJlbnRFbGVtZW50KSxcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogZ2V0SGVpZ2h0V2l0aG91dFBhZGRpbmcoY29kZUVsZW1lbnQucGFyZW50RWxlbWVudCksXHJcbiAgICAgICAgICAgICAgICBjb250ZW50V2lkdGg6IGdldFdpZHRoV2l0aG91dFBhZGRpbmcoY29udGVudEVsZW1lbnQucGFyZW50RWxlbWVudCksXHJcbiAgICAgICAgICAgICAgICBjb250ZW50SGVpZ2h0OiBnZXRIZWlnaHRXaXRob3V0UGFkZGluZyhjb250ZW50RWxlbWVudC5wYXJlbnRFbGVtZW50KSxcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aHM6IFtcclxuICAgICAgICAgICAgICAgICAgICBwbHcgfHwgbmx3IHx8IERFRkFVTFRfV0lEVEgsXHJcbiAgICAgICAgICAgICAgICAgICAgbmx3IHx8IHBsdyB8fCBERUZBVUxUX1dJRFRILFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogW1xyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHBsdyB8fCBubHcgfHwgREVGQVVMVF9XSURUSCwgY29sV2lkdGggKiBtaW5Db2x1bW5zKSxcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChubHcgfHwgcGx3IHx8IERFRkFVTFRfV0lEVEgsIGNvbFdpZHRoICogbWluQ29sdW1ucyksXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodCxcclxuICAgICAgICAgICAgICAgIGNvbFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcldpZHRoOiBsbncsXHJcbiAgICAgICAgICAgICAgICBkZXBzOiBhbGxEZXBzLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzZXREaW1lbnNpb25zKGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xyXG4gICAgfSwgYWxsRGVwcyk7XHJcbiAgICBpZiAoIWRpbWVuc2lvbnMgfHxcclxuICAgICAgICBkZXBzQ2hhbmdlZChkaW1lbnNpb25zLmRlcHMsIGFsbERlcHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgZWxlbWVudCwgZGltZW5zaW9uczogbnVsbCB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHsgZWxlbWVudCwgZGltZW5zaW9ucyB9O1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IG5ld2xpbmVSZSA9IC9cXHJcXG58XFxyfFxcbi87XHJcbmZ1bmN0aW9uIGdldExvbmdlc3RMaW5lKGNvZGUsIGZvY3VzKSB7XHJcbiAgICBjb25zdCBsaW5lcyA9IGNvZGUgPyBjb2RlLnNwbGl0KG5ld2xpbmVSZSkgOiBbXCJcIl07XHJcbiAgICBjb25zdCBmb2N1c0luZGV4ZXMgPSBnZXRGb2N1c0luZGV4ZXMoZm9jdXMsIGxpbmVzKTtcclxuICAgIGxldCBsb25nZXN0TGluZSA9IFwiXCI7XHJcbiAgICBsaW5lcy5mb3JFYWNoKChsaW5lLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGlmIChmb2N1c0luZGV4ZXMuaW5jbHVkZXMoaW5kZXgpICYmXHJcbiAgICAgICAgICAgIGxpbmUubGVuZ3RoID4gbG9uZ2VzdExpbmUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxvbmdlc3RMaW5lID0gbGluZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBsb25nZXN0TGluZTtcclxufVxyXG5mdW5jdGlvbiBnZXRXaWR0aFdpdGhvdXRQYWRkaW5nKGVsZW1lbnQpIHtcclxuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xyXG4gICAgcmV0dXJuIChwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUud2lkdGgpIC1cclxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpIC1cclxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0KSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2lkdGhXaXRoUGFkZGluZyhlbGVtZW50KSB7XHJcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUud2lkdGgpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEhlaWdodFdpdGhvdXRQYWRkaW5nKGVsZW1lbnQpIHtcclxuICAgIGlmICghZWxlbWVudClcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xyXG4gICAgcmV0dXJuIChwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUuaGVpZ2h0KSAtXHJcbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3ApIC1cclxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSkpO1xyXG59XHJcbmZ1bmN0aW9uIGRlcHNDaGFuZ2VkKG9sZERlcHMsIG5ld0RlcHMpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2xkRGVwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChvbGREZXBzW2ldICE9PSBuZXdEZXBzW2ldKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiB1c2VXaW5kb3dXaWR0aCgpIHtcclxuICAgIGNvbnN0IFt3aWR0aCwgc2V0V2lkdGhdID0gUmVhY3QudXNlU3RhdGUodW5kZWZpbmVkKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKCkge1xyXG4gICAgICAgICAgICBzZXRXaWR0aCh3aW5kb3cuaW5uZXJXaWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4gd2lkdGg7XHJcbn1cclxuZnVuY3Rpb24gZm9jdXNIZWlnaHRJbkxpbmVzKGZvY3VzLCBsaW5lcykge1xyXG4gICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gZ2V0Rm9jdXNFeHRyZW1lcyhmb2N1cy5wcmV2LCBsaW5lcyk7XHJcbiAgICByZXR1cm4gZW5kIC0gc3RhcnQgKyAxO1xyXG59XG5cbmZ1bmN0aW9uIERpZmYoKSB7fVxuRGlmZi5wcm90b3R5cGUgPSB7XG4gIGRpZmY6IGZ1bmN0aW9uIGRpZmYob2xkU3RyaW5nLCBuZXdTdHJpbmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZG9uZSh2YWx1ZSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfSAvLyBBbGxvdyBzdWJjbGFzc2VzIHRvIG1hc3NhZ2UgdGhlIGlucHV0IHByaW9yIHRvIHJ1bm5pbmdcblxuXG4gICAgb2xkU3RyaW5nID0gdGhpcy5jYXN0SW5wdXQob2xkU3RyaW5nKTtcbiAgICBuZXdTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChuZXdTdHJpbmcpO1xuICAgIG9sZFN0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShvbGRTdHJpbmcpKTtcbiAgICBuZXdTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUobmV3U3RyaW5nKSk7XG4gICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXG4gICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGg7XG4gICAgdmFyIGVkaXRMZW5ndGggPSAxO1xuICAgIHZhciBtYXhFZGl0TGVuZ3RoID0gbmV3TGVuICsgb2xkTGVuO1xuICAgIHZhciBiZXN0UGF0aCA9IFt7XG4gICAgICBuZXdQb3M6IC0xLFxuICAgICAgY29tcG9uZW50czogW11cbiAgICB9XTsgLy8gU2VlZCBlZGl0TGVuZ3RoID0gMCwgaS5lLiB0aGUgY29udGVudCBzdGFydHMgd2l0aCB0aGUgc2FtZSB2YWx1ZXNcblxuICAgIHZhciBvbGRQb3MgPSB0aGlzLmV4dHJhY3RDb21tb24oYmVzdFBhdGhbMF0sIG5ld1N0cmluZywgb2xkU3RyaW5nLCAwKTtcblxuICAgIGlmIChiZXN0UGF0aFswXS5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgLy8gSWRlbnRpdHkgcGVyIHRoZSBlcXVhbGl0eSBhbmQgdG9rZW5pemVyXG4gICAgICByZXR1cm4gZG9uZShbe1xuICAgICAgICB2YWx1ZTogdGhpcy5qb2luKG5ld1N0cmluZyksXG4gICAgICAgIGNvdW50OiBuZXdTdHJpbmcubGVuZ3RoXG4gICAgICB9XSk7XG4gICAgfSAvLyBNYWluIHdvcmtlciBtZXRob2QuIGNoZWNrcyBhbGwgcGVybXV0YXRpb25zIG9mIGEgZ2l2ZW4gZWRpdCBsZW5ndGggZm9yIGFjY2VwdGFuY2UuXG5cblxuICAgIGZ1bmN0aW9uIGV4ZWNFZGl0TGVuZ3RoKCkge1xuICAgICAgZm9yICh2YXIgZGlhZ29uYWxQYXRoID0gLTEgKiBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggPD0gZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoICs9IDIpIHtcbiAgICAgICAgdmFyIGJhc2VQYXRoID0gdm9pZCAwO1xuXG4gICAgICAgIHZhciBhZGRQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0sXG4gICAgICAgICAgICByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoICsgMV0sXG4gICAgICAgICAgICBfb2xkUG9zID0gKHJlbW92ZVBhdGggPyByZW1vdmVQYXRoLm5ld1BvcyA6IDApIC0gZGlhZ29uYWxQYXRoO1xuXG4gICAgICAgIGlmIChhZGRQYXRoKSB7XG4gICAgICAgICAgLy8gTm8gb25lIGVsc2UgaXMgZ29pbmcgdG8gYXR0ZW1wdCB0byB1c2UgdGhpcyB2YWx1ZSwgY2xlYXIgaXRcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW5BZGQgPSBhZGRQYXRoICYmIGFkZFBhdGgubmV3UG9zICsgMSA8IG5ld0xlbixcbiAgICAgICAgICAgIGNhblJlbW92ZSA9IHJlbW92ZVBhdGggJiYgMCA8PSBfb2xkUG9zICYmIF9vbGRQb3MgPCBvbGRMZW47XG5cbiAgICAgICAgaWYgKCFjYW5BZGQgJiYgIWNhblJlbW92ZSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgcGF0aCBpcyBhIHRlcm1pbmFsIHRoZW4gcHJ1bmVcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIFNlbGVjdCB0aGUgZGlhZ29uYWwgdGhhdCB3ZSB3YW50IHRvIGJyYW5jaCBmcm9tLiBXZSBzZWxlY3QgdGhlIHByaW9yXG4gICAgICAgIC8vIHBhdGggd2hvc2UgcG9zaXRpb24gaW4gdGhlIG5ldyBzdHJpbmcgaXMgdGhlIGZhcnRoZXN0IGZyb20gdGhlIG9yaWdpblxuICAgICAgICAvLyBhbmQgZG9lcyBub3QgcGFzcyB0aGUgYm91bmRzIG9mIHRoZSBkaWZmIGdyYXBoXG5cblxuICAgICAgICBpZiAoIWNhbkFkZCB8fCBjYW5SZW1vdmUgJiYgYWRkUGF0aC5uZXdQb3MgPCByZW1vdmVQYXRoLm5ld1Bvcykge1xuICAgICAgICAgIGJhc2VQYXRoID0gY2xvbmVQYXRoKHJlbW92ZVBhdGgpO1xuICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VQYXRoID0gYWRkUGF0aDsgLy8gTm8gbmVlZCB0byBjbG9uZSwgd2UndmUgcHVsbGVkIGl0IGZyb20gdGhlIGxpc3RcblxuICAgICAgICAgIGJhc2VQYXRoLm5ld1BvcysrO1xuICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB0cnVlLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgX29sZFBvcyA9IHNlbGYuZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCk7IC8vIElmIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgYm90aCBzdHJpbmdzLCB0aGVuIHdlIGFyZSBkb25lXG5cbiAgICAgICAgaWYgKGJhc2VQYXRoLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIF9vbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgICAgIHJldHVybiBkb25lKGJ1aWxkVmFsdWVzKHNlbGYsIGJhc2VQYXRoLmNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBzZWxmLnVzZUxvbmdlc3RUb2tlbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSB0cmFjayB0aGlzIHBhdGggYXMgYSBwb3RlbnRpYWwgY2FuZGlkYXRlIGFuZCBjb250aW51ZS5cbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gYmFzZVBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWRpdExlbmd0aCsrO1xuICAgIH0gLy8gUGVyZm9ybXMgdGhlIGxlbmd0aCBvZiBlZGl0IGl0ZXJhdGlvbi4gSXMgYSBiaXQgZnVnbHkgYXMgdGhpcyBoYXMgdG8gc3VwcG9ydCB0aGVcbiAgICAvLyBzeW5jIGFuZCBhc3luYyBtb2RlIHdoaWNoIGlzIG5ldmVyIGZ1bi4gTG9vcHMgb3ZlciBleGVjRWRpdExlbmd0aCB1bnRpbCBhIHZhbHVlXG4gICAgLy8gaXMgcHJvZHVjZWQuXG5cblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgKGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4sIGJ1dCB3ZSB3YW50IHRvIGJlIHNhZmUuXG5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGlmIChlZGl0TGVuZ3RoID4gbWF4RWRpdExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFleGVjRWRpdExlbmd0aCgpKSB7XG4gICAgICAgICAgICBleGVjKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0pKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChlZGl0TGVuZ3RoIDw9IG1heEVkaXRMZW5ndGgpIHtcbiAgICAgICAgdmFyIHJldCA9IGV4ZWNFZGl0TGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHB1c2hDb21wb25lbnQ6IGZ1bmN0aW9uIHB1c2hDb21wb25lbnQoY29tcG9uZW50cywgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICB2YXIgbGFzdCA9IGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChsYXN0ICYmIGxhc3QuYWRkZWQgPT09IGFkZGVkICYmIGxhc3QucmVtb3ZlZCA9PT0gcmVtb3ZlZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjbG9uZSBoZXJlIGFzIHRoZSBjb21wb25lbnQgY2xvbmUgb3BlcmF0aW9uIGlzIGp1c3RcbiAgICAgIC8vIGFzIHNoYWxsb3cgYXJyYXkgY2xvbmVcbiAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXSA9IHtcbiAgICAgICAgY291bnQ6IGxhc3QuY291bnQgKyAxLFxuICAgICAgICBhZGRlZDogYWRkZWQsXG4gICAgICAgIHJlbW92ZWQ6IHJlbW92ZWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgICBhZGRlZDogYWRkZWQsXG4gICAgICAgIHJlbW92ZWQ6IHJlbW92ZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZXh0cmFjdENvbW1vbjogZnVuY3Rpb24gZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCkge1xuICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxuICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoLFxuICAgICAgICBuZXdQb3MgPSBiYXNlUGF0aC5uZXdQb3MsXG4gICAgICAgIG9sZFBvcyA9IG5ld1BvcyAtIGRpYWdvbmFsUGF0aCxcbiAgICAgICAgY29tbW9uQ291bnQgPSAwO1xuXG4gICAgd2hpbGUgKG5ld1BvcyArIDEgPCBuZXdMZW4gJiYgb2xkUG9zICsgMSA8IG9sZExlbiAmJiB0aGlzLmVxdWFscyhuZXdTdHJpbmdbbmV3UG9zICsgMV0sIG9sZFN0cmluZ1tvbGRQb3MgKyAxXSkpIHtcbiAgICAgIG5ld1BvcysrO1xuICAgICAgb2xkUG9zKys7XG4gICAgICBjb21tb25Db3VudCsrO1xuICAgIH1cblxuICAgIGlmIChjb21tb25Db3VudCkge1xuICAgICAgYmFzZVBhdGguY29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgY291bnQ6IGNvbW1vbkNvdW50XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBiYXNlUGF0aC5uZXdQb3MgPSBuZXdQb3M7XG4gICAgcmV0dXJuIG9sZFBvcztcbiAgfSxcbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY29tcGFyYXRvcihsZWZ0LCByaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCB0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSAmJiBsZWZ0LnRvTG93ZXJDYXNlKCkgPT09IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9LFxuICByZW1vdmVFbXB0eTogZnVuY3Rpb24gcmVtb3ZlRW1wdHkoYXJyYXkpIHtcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0pIHtcbiAgICAgICAgcmV0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIGNhc3RJbnB1dDogZnVuY3Rpb24gY2FzdElucHV0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICB0b2tlbml6ZTogZnVuY3Rpb24gdG9rZW5pemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJycpO1xuICB9LFxuICBqb2luOiBmdW5jdGlvbiBqb2luKGNoYXJzKSB7XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBidWlsZFZhbHVlcyhkaWZmLCBjb21wb25lbnRzLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgdXNlTG9uZ2VzdFRva2VuKSB7XG4gIHZhciBjb21wb25lbnRQb3MgPSAwLFxuICAgICAgY29tcG9uZW50TGVuID0gY29tcG9uZW50cy5sZW5ndGgsXG4gICAgICBuZXdQb3MgPSAwLFxuICAgICAgb2xkUG9zID0gMDtcblxuICBmb3IgKDsgY29tcG9uZW50UG9zIDwgY29tcG9uZW50TGVuOyBjb21wb25lbnRQb3MrKykge1xuICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG5cbiAgICBpZiAoIWNvbXBvbmVudC5yZW1vdmVkKSB7XG4gICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCAmJiB1c2VMb25nZXN0VG9rZW4pIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgdmFyIG9sZFZhbHVlID0gb2xkU3RyaW5nW29sZFBvcyArIGldO1xuICAgICAgICAgIHJldHVybiBvbGRWYWx1ZS5sZW5ndGggPiB2YWx1ZS5sZW5ndGggPyBvbGRWYWx1ZSA6IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihuZXdTdHJpbmcuc2xpY2UobmV3UG9zLCBuZXdQb3MgKyBjb21wb25lbnQuY291bnQpKTtcbiAgICAgIH1cblxuICAgICAgbmV3UG9zICs9IGNvbXBvbmVudC5jb3VudDsgLy8gQ29tbW9uIGNhc2VcblxuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcbiAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG9sZFN0cmluZy5zbGljZShvbGRQb3MsIG9sZFBvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDsgLy8gUmV2ZXJzZSBhZGQgYW5kIHJlbW92ZSBzbyByZW1vdmVzIGFyZSBvdXRwdXQgZmlyc3QgdG8gbWF0Y2ggY29tbW9uIGNvbnZlbnRpb25cbiAgICAgIC8vIFRoZSBkaWZmaW5nIGFsZ29yaXRobSBpcyB0aWVkIHRvIGFkZCB0aGVuIHJlbW92ZSBvdXRwdXQgYW5kIHRoaXMgaXMgdGhlIHNpbXBsZXN0XG4gICAgICAvLyByb3V0ZSB0byBnZXQgdGhlIGRlc2lyZWQgb3V0cHV0IHdpdGggbWluaW1hbCBvdmVyaGVhZC5cblxuICAgICAgaWYgKGNvbXBvbmVudFBvcyAmJiBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdLmFkZGVkKSB7XG4gICAgICAgIHZhciB0bXAgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdO1xuICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xuICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvc10gPSB0bXA7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFNwZWNpYWwgY2FzZSBoYW5kbGUgZm9yIHdoZW4gb25lIHRlcm1pbmFsIGlzIGlnbm9yZWQgKGkuZS4gd2hpdGVzcGFjZSkuXG4gIC8vIEZvciB0aGlzIGNhc2Ugd2UgbWVyZ2UgdGhlIHRlcm1pbmFsIGludG8gdGhlIHByaW9yIHN0cmluZyBhbmQgZHJvcCB0aGUgY2hhbmdlLlxuICAvLyBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBzdHJpbmcgbW9kZS5cblxuXG4gIHZhciBsYXN0Q29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAxXTtcblxuICBpZiAoY29tcG9uZW50TGVuID4gMSAmJiB0eXBlb2YgbGFzdENvbXBvbmVudC52YWx1ZSA9PT0gJ3N0cmluZycgJiYgKGxhc3RDb21wb25lbnQuYWRkZWQgfHwgbGFzdENvbXBvbmVudC5yZW1vdmVkKSAmJiBkaWZmLmVxdWFscygnJywgbGFzdENvbXBvbmVudC52YWx1ZSkpIHtcbiAgICBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDJdLnZhbHVlICs9IGxhc3RDb21wb25lbnQudmFsdWU7XG4gICAgY29tcG9uZW50cy5wb3AoKTtcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBjbG9uZVBhdGgocGF0aCkge1xuICByZXR1cm4ge1xuICAgIG5ld1BvczogcGF0aC5uZXdQb3MsXG4gICAgY29tcG9uZW50czogcGF0aC5jb21wb25lbnRzLnNsaWNlKDApXG4gIH07XG59XG5cbi8vXG4vLyBSYW5nZXMgYW5kIGV4Y2VwdGlvbnM6XG4vLyBMYXRpbi0xIFN1cHBsZW1lbnQsIDAwODDigJMwMEZGXG4vLyAgLSBVKzAwRDcgIMOXIE11bHRpcGxpY2F0aW9uIHNpZ25cbi8vICAtIFUrMDBGNyAgw7cgRGl2aXNpb24gc2lnblxuLy8gTGF0aW4gRXh0ZW5kZWQtQSwgMDEwMOKAkzAxN0Zcbi8vIExhdGluIEV4dGVuZGVkLUIsIDAxODDigJMwMjRGXG4vLyBJUEEgRXh0ZW5zaW9ucywgMDI1MOKAkzAyQUZcbi8vIFNwYWNpbmcgTW9kaWZpZXIgTGV0dGVycywgMDJCMOKAkzAyRkZcbi8vICAtIFUrMDJDNyAgy4cgJiM3MTE7ICBDYXJvblxuLy8gIC0gVSswMkQ4ICDLmCAmIzcyODsgIEJyZXZlXG4vLyAgLSBVKzAyRDkgIMuZICYjNzI5OyAgRG90IEFib3ZlXG4vLyAgLSBVKzAyREEgIMuaICYjNzMwOyAgUmluZyBBYm92ZVxuLy8gIC0gVSswMkRCICDLmyAmIzczMTsgIE9nb25la1xuLy8gIC0gVSswMkRDICDLnCAmIzczMjsgIFNtYWxsIFRpbGRlXG4vLyAgLSBVKzAyREQgIMudICYjNzMzOyAgRG91YmxlIEFjdXRlIEFjY2VudFxuLy8gTGF0aW4gRXh0ZW5kZWQgQWRkaXRpb25hbCwgMUUwMOKAkzFFRkZcblxudmFyIGV4dGVuZGVkV29yZENoYXJzID0gL15bQS1aYS16XFx4QzAtXFx1MDJDNlxcdTAyQzgtXFx1MDJEN1xcdTAyREUtXFx1MDJGRlxcdTFFMDAtXFx1MUVGRl0rJC87XG52YXIgcmVXaGl0ZXNwYWNlID0gL1xcUy87XG52YXIgd29yZERpZmYgPSBuZXcgRGlmZigpO1xuXG53b3JkRGlmZi5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVDYXNlKSB7XG4gICAgbGVmdCA9IGxlZnQudG9Mb3dlckNhc2UoKTtcbiAgICByaWdodCA9IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgdGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KGxlZnQpICYmICFyZVdoaXRlc3BhY2UudGVzdChyaWdodCk7XG59O1xuXG53b3JkRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgdG9rZW5zID0gdmFsdWUuc3BsaXQoLyhcXHMrfFsoKVtcXF17fSdcIl18XFxiKS8pOyAvLyBKb2luIHRoZSBib3VuZGFyeSBzcGxpdHMgdGhhdCB3ZSBkbyBub3QgY29uc2lkZXIgdG8gYmUgYm91bmRhcmllcy4gVGhpcyBpcyBwcmltYXJpbHkgdGhlIGV4dGVuZGVkIExhdGluIGNoYXJhY3RlciBzZXQuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBlbXB0eSBzdHJpbmcgaW4gdGhlIG5leHQgZmllbGQgYW5kIHdlIGhhdmUgb25seSB3b3JkIGNoYXJzIGJlZm9yZSBhbmQgYWZ0ZXIsIG1lcmdlXG4gICAgaWYgKCF0b2tlbnNbaSArIDFdICYmIHRva2Vuc1tpICsgMl0gJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaV0pICYmIGV4dGVuZGVkV29yZENoYXJzLnRlc3QodG9rZW5zW2kgKyAyXSkpIHtcbiAgICAgIHRva2Vuc1tpXSArPSB0b2tlbnNbaSArIDJdO1xuICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMik7XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn07XG5cbnZhciBsaW5lRGlmZiA9IG5ldyBEaWZmKCk7XG5cbmxpbmVEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciByZXRMaW5lcyA9IFtdLFxuICAgICAgbGluZXNBbmROZXdsaW5lcyA9IHZhbHVlLnNwbGl0KC8oXFxufFxcclxcbikvKTsgLy8gSWdub3JlIHRoZSBmaW5hbCBlbXB0eSB0b2tlbiB0aGF0IG9jY3VycyBpZiB0aGUgc3RyaW5nIGVuZHMgd2l0aCBhIG5ldyBsaW5lXG5cbiAgaWYgKCFsaW5lc0FuZE5ld2xpbmVzW2xpbmVzQW5kTmV3bGluZXMubGVuZ3RoIC0gMV0pIHtcbiAgICBsaW5lc0FuZE5ld2xpbmVzLnBvcCgpO1xuICB9IC8vIE1lcmdlIHRoZSBjb250ZW50IGFuZCBsaW5lIHNlcGFyYXRvcnMgaW50byBzaW5nbGUgdG9rZW5zXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzQW5kTmV3bGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGxpbmVzQW5kTmV3bGluZXNbaV07XG5cbiAgICBpZiAoaSAlIDIgJiYgIXRoaXMub3B0aW9ucy5uZXdsaW5lSXNUb2tlbikge1xuICAgICAgcmV0TGluZXNbcmV0TGluZXMubGVuZ3RoIC0gMV0gKz0gbGluZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgcmV0TGluZXMucHVzaChsaW5lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0TGluZXM7XG59O1xuXG5mdW5jdGlvbiBkaWZmTGluZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XG59XG5cbnZhciBzZW50ZW5jZURpZmYgPSBuZXcgRGlmZigpO1xuXG5zZW50ZW5jZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oXFxTLis/Wy4hP10pKD89XFxzK3wkKS8pO1xufTtcblxudmFyIGNzc0RpZmYgPSBuZXcgRGlmZigpO1xuXG5jc3NEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zcGxpdCgvKFt7fTo7LF18XFxzKykvKTtcbn07XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxudmFyIG9iamVjdFByb3RvdHlwZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBqc29uRGlmZiA9IG5ldyBEaWZmKCk7IC8vIERpc2NyaW1pbmF0ZSBiZXR3ZWVuIHR3byBsaW5lcyBvZiBwcmV0dHktcHJpbnRlZCwgc2VyaWFsaXplZCBKU09OIHdoZXJlIG9uZSBvZiB0aGVtIGhhcyBhXG4vLyBkYW5nbGluZyBjb21tYSBhbmQgdGhlIG90aGVyIGRvZXNuJ3QuIFR1cm5zIG91dCBpbmNsdWRpbmcgdGhlIGRhbmdsaW5nIGNvbW1hIHlpZWxkcyB0aGUgbmljZXN0IG91dHB1dDpcblxuanNvbkRpZmYudXNlTG9uZ2VzdFRva2VuID0gdHJ1ZTtcbmpzb25EaWZmLnRva2VuaXplID0gbGluZURpZmYudG9rZW5pemU7XG5cbmpzb25EaWZmLmNhc3RJbnB1dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgX3RoaXMkb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIHVuZGVmaW5lZFJlcGxhY2VtZW50ID0gX3RoaXMkb3B0aW9ucy51bmRlZmluZWRSZXBsYWNlbWVudCxcbiAgICAgIF90aGlzJG9wdGlvbnMkc3RyaW5naSA9IF90aGlzJG9wdGlvbnMuc3RyaW5naWZ5UmVwbGFjZXIsXG4gICAgICBzdHJpbmdpZnlSZXBsYWNlciA9IF90aGlzJG9wdGlvbnMkc3RyaW5naSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGssIHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkUmVwbGFjZW1lbnQgOiB2O1xuICB9IDogX3RoaXMkb3B0aW9ucyRzdHJpbmdpO1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsaXplKHZhbHVlLCBudWxsLCBudWxsLCBzdHJpbmdpZnlSZXBsYWNlciksIHN0cmluZ2lmeVJlcGxhY2VyLCAnICAnKTtcbn07XG5cbmpzb25EaWZmLmVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gRGlmZi5wcm90b3R5cGUuZXF1YWxzLmNhbGwoanNvbkRpZmYsIGxlZnQucmVwbGFjZSgvLChbXFxyXFxuXSkvZywgJyQxJyksIHJpZ2h0LnJlcGxhY2UoLywoW1xcclxcbl0pL2csICckMScpKTtcbn07XG4vLyBvYmplY3QgdGhhdCBpcyBhbHJlYWR5IG9uIHRoZSBcInN0YWNrXCIgb2YgaXRlbXMgYmVpbmcgcHJvY2Vzc2VkLiBBY2NlcHRzIGFuIG9wdGlvbmFsIHJlcGxhY2VyXG5cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZShvYmosIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwga2V5KSB7XG4gIHN0YWNrID0gc3RhY2sgfHwgW107XG4gIHJlcGxhY2VtZW50U3RhY2sgPSByZXBsYWNlbWVudFN0YWNrIHx8IFtdO1xuXG4gIGlmIChyZXBsYWNlcikge1xuICAgIG9iaiA9IHJlcGxhY2VyKGtleSwgb2JqKTtcbiAgfVxuXG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChzdGFja1tpXSA9PT0gb2JqKSB7XG4gICAgICByZXR1cm4gcmVwbGFjZW1lbnRTdGFja1tpXTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2Fub25pY2FsaXplZE9iajtcblxuICBpZiAoJ1tvYmplY3QgQXJyYXldJyA9PT0gb2JqZWN0UHJvdG90eXBlVG9TdHJpbmcuY2FsbChvYmopKSB7XG4gICAgc3RhY2sucHVzaChvYmopO1xuICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBuZXcgQXJyYXkob2JqLmxlbmd0aCk7XG4gICAgcmVwbGFjZW1lbnRTdGFjay5wdXNoKGNhbm9uaWNhbGl6ZWRPYmopO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2Fub25pY2FsaXplZE9ialtpXSA9IGNhbm9uaWNhbGl6ZShvYmpbaV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwga2V5KTtcbiAgICB9XG5cbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xuICAgIHJldHVybiBjYW5vbmljYWxpemVkT2JqO1xuICB9XG5cbiAgaWYgKG9iaiAmJiBvYmoudG9KU09OKSB7XG4gICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICB9XG5cbiAgaWYgKF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgc3RhY2sucHVzaChvYmopO1xuICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB7fTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XG5cbiAgICB2YXIgc29ydGVkS2V5cyA9IFtdLFxuICAgICAgICBfa2V5O1xuXG4gICAgZm9yIChfa2V5IGluIG9iaikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoX2tleSkpIHtcbiAgICAgICAgc29ydGVkS2V5cy5wdXNoKF9rZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNvcnRlZEtleXMuc29ydCgpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvcnRlZEtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIF9rZXkgPSBzb3J0ZWRLZXlzW2ldO1xuICAgICAgY2Fub25pY2FsaXplZE9ialtfa2V5XSA9IGNhbm9uaWNhbGl6ZShvYmpbX2tleV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwgX2tleSk7XG4gICAgfVxuXG4gICAgc3RhY2sucG9wKCk7XG4gICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBjYW5vbmljYWxpemVkT2JqID0gb2JqO1xuICB9XG5cbiAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XG59XG5cbnZhciBhcnJheURpZmYgPSBuZXcgRGlmZigpO1xuXG5hcnJheURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG59O1xuXG5hcnJheURpZmYuam9pbiA9IGFycmF5RGlmZi5yZW1vdmVFbXB0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG5mdW5jdGlvbiBtZXJnZUxpbmVzKGNvZGUsIGxpbmVzKSB7XHJcbiAgICBsZXQgZW50ZXJJbmRleCA9IDA7XHJcbiAgICBsZXQgZXhpdEluZGV4ID0gMDtcclxuICAgIGNvbnN0IGluZGV4ZXMgPSBkaWZmKGNvZGUpO1xyXG4gICAgY29uc3QgbmV3TGluZXMgPSBpbmRleGVzLm1hcChpbmRleCA9PiB7XHJcbiAgICAgICAgaWYgKGluZGV4Lm5leHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsaW5lcy5wcmV2W2luZGV4LnByZXZdKSwgeyBsaW5lTnVtYmVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldjogaW5kZXgucHJldiArIDEsXHJcbiAgICAgICAgICAgICAgICB9LCBtb3ZlOiBcImV4aXRcIiwgZW50ZXJJbmRleDogbnVsbCwgZXhpdEluZGV4OiBleGl0SW5kZXgrKyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluZGV4LnByZXYgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsaW5lcy5uZXh0W2luZGV4Lm5leHRdKSwgeyBsaW5lTnVtYmVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogaW5kZXgubmV4dCArIDEsXHJcbiAgICAgICAgICAgICAgICB9LCBtb3ZlOiBcImVudGVyXCIsIGVudGVySW5kZXg6IGVudGVySW5kZXgrKywgZXhpdEluZGV4OiBudWxsIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsaW5lcy5wcmV2W2luZGV4LnByZXZdKSwgeyBsaW5lTnVtYmVyOiB7XHJcbiAgICAgICAgICAgICAgICBwcmV2OiBpbmRleC5wcmV2ICsgMSxcclxuICAgICAgICAgICAgICAgIG5leHQ6IGluZGV4Lm5leHQgKyAxLFxyXG4gICAgICAgICAgICB9LCBtb3ZlOiBcInN0YXlcIiwgZW50ZXJJbmRleDogbnVsbCwgZXhpdEluZGV4OiBudWxsIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxpbmVzOiBuZXdMaW5lcyxcclxuICAgICAgICBlbnRlckNvdW50OiBlbnRlckluZGV4LFxyXG4gICAgICAgIGV4aXRDb3VudDogZXhpdEluZGV4LFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGxpc3Qgb2YgcGFpcnMgb2YgbGluZSBpbmRleGVzOlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSBpZiBsaW5lcyAyIGFuZCAzIHdlcmUgcmVtb3ZlZFxyXG4gKiBhbmQgdHdvIGxpbmVzIHdoZXJlIGFkZGVkIGF0IHRoZSBlbmQ6XHJcbiAqICAwIDBcclxuICogIDEgLVxyXG4gKiAgMiAtXHJcbiAqICAzIDFcclxuICogIC0gMlxyXG4gKiAgLSAzXHJcbiAqL1xyXG5mdW5jdGlvbiBkaWZmKGNvZGUpIHtcclxuICAgIGNvbnN0IGNoYW5nZXMgPSBkaWZmTGluZXMoY29kZS5wcmV2LCBjb2RlLm5leHQpO1xyXG4gICAgbGV0IGluZGV4ZXMgPSBbXTtcclxuICAgIGxldCBwcmV2SW5kZXggPSAwO1xyXG4gICAgbGV0IG5leHRJbmRleCA9IDA7XHJcbiAgICBjaGFuZ2VzLmZvckVhY2goY2hhbmdlID0+IHtcclxuICAgICAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlLmNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaCh7IG5leHQ6IG5leHRJbmRleCsrIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlLmNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaCh7IHByZXY6IHByZXZJbmRleCsrIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZS5jb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXY6IHByZXZJbmRleCsrLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG5leHRJbmRleCsrLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBpbmRleGVzO1xyXG59XG5cbmZ1bmN0aW9uIHNwbGl0QnlGb2N1cyhtZXJnZWRDb2RlLCBmb2N1cywgYW5ub3RhdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgbGluZXMgfSA9IG1lcmdlZENvZGUsIG1lcmdlZENvZGVSZXN0ID0gX19yZXN0KG1lcmdlZENvZGUsIFtcImxpbmVzXCJdKTtcclxuICAgIGNvbnN0IGZvY3VzQnlMaW5lTnVtYmVyID0gbWFwKGZvY3VzLCAoZm9jdXMsIGtleSkgPT4ge1xyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZmlsdGVyIHRoZSBsaW5lcyB0aGF0IGRvbid0IGJlbG9uZyB0byB0aGUgc3RlcFxyXG4gICAgICAgIC8vIGZvciB0aGUgY2FzZSB3aGVyZSBmb2N1cyA9PSBcIlwiXHJcbiAgICAgICAgY29uc3Qgc3RlcExpbmVzID0ga2V5ID09PSBcInByZXZcIlxyXG4gICAgICAgICAgICA/IGxpbmVzLmZpbHRlcihsID0+IGwubW92ZSAhPT0gXCJlbnRlclwiKVxyXG4gICAgICAgICAgICA6IGxpbmVzLmZpbHRlcihsID0+IGwubW92ZSAhPT0gXCJleGl0XCIpO1xyXG4gICAgICAgIHJldHVybiBtYXBGb2N1c1RvTGluZU51bWJlcnMoZm9jdXMsIHN0ZXBMaW5lcyk7XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHNwbGl0dGVkTGluZXMgPSBsaW5lcy5tYXAobGluZSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0b2tlbnMgfSA9IGxpbmUsIHJlc3QgPSBfX3Jlc3QobGluZSwgW1widG9rZW5zXCJdKTtcclxuICAgICAgICBjb25zdCBsaW5lRm9jdXMgPSB7XHJcbiAgICAgICAgICAgIHByZXY6IGxpbmUubGluZU51bWJlci5wcmV2XHJcbiAgICAgICAgICAgICAgICA/IGZvY3VzQnlMaW5lTnVtYmVyLnByZXZbbGluZS5saW5lTnVtYmVyLnByZXZdXHJcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxyXG4gICAgICAgICAgICBuZXh0OiBsaW5lLmxpbmVOdW1iZXIubmV4dFxyXG4gICAgICAgICAgICAgICAgPyBmb2N1c0J5TGluZU51bWJlci5uZXh0W2xpbmUubGluZU51bWJlci5uZXh0XVxyXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGxpbmVBbm5vdGF0aW9ucyA9IHtcclxuICAgICAgICAgICAgcHJldjogbGluZS5saW5lTnVtYmVyLnByZXZcclxuICAgICAgICAgICAgICAgID8gYW5ub3RhdGlvbnMucHJldltsaW5lLmxpbmVOdW1iZXIucHJldl0gfHwgW11cclxuICAgICAgICAgICAgICAgIDogW10sXHJcbiAgICAgICAgICAgIG5leHQ6IGxpbmUubGluZU51bWJlci5uZXh0XHJcbiAgICAgICAgICAgICAgICA/IGFubm90YXRpb25zLm5leHRbbGluZS5saW5lTnVtYmVyLm5leHRdIHx8IFtdXHJcbiAgICAgICAgICAgICAgICA6IFtdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBmb2N1c2VkOiBtYXAobGluZUZvY3VzLCBmb2N1cyA9PiAhIWZvY3VzKSwgZ3JvdXBzOiBnZXRUb2tlbkdyb3Vwcyh0b2tlbnMsIGxpbmVGb2N1cywgbGluZUFubm90YXRpb25zKSB9LCByZXN0KTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZm9jdXNlZExpbmVOdW1iZXJzID0gbWFwKGZvY3VzQnlMaW5lTnVtYmVyLCBmb2N1c0J5TGluZU51bWJlciA9PiBPYmplY3Qua2V5cyhmb2N1c0J5TGluZU51bWJlcikubWFwKGsgPT4gTnVtYmVyKGspKSk7XHJcbiAgICBjb25zdCBmaXJzdEZvY3VzZWRMaW5lTnVtYmVyID0gbWFwKGZvY3VzZWRMaW5lTnVtYmVycywgZm9jdXNlZExpbmVOdW1iZXJzID0+IE1hdGgubWluKC4uLmZvY3VzZWRMaW5lTnVtYmVycykpO1xyXG4gICAgY29uc3QgbGFzdEZvY3VzZWRMaW5lTnVtYmVyID0gbWFwKGZvY3VzZWRMaW5lTnVtYmVycywgZm9jdXNlZExpbmVOdW1iZXJzID0+IE1hdGgubWF4KC4uLmZvY3VzZWRMaW5lTnVtYmVycykpO1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBsaW5lczogc3BsaXR0ZWRMaW5lcywgZmlyc3RGb2N1c2VkTGluZU51bWJlcixcclxuICAgICAgICBsYXN0Rm9jdXNlZExpbmVOdW1iZXIgfSwgbWVyZ2VkQ29kZVJlc3QpO1xyXG59XHJcbi8qKlxyXG4gKiBHZXQgdGhlIGxlYXN0IGFtb3VudCBvZiBncm91cHMgd2hlcmUgbm8gY29uc2VjdXRpdmUgZ3JvdXBzIGhhdmVcclxuICogdGhlIHNhbWUgY29tYmluYXRpb24gb2YgcHJldkZvY3VzLCBuZXh0Rm9jdXMsIHByZXZBbm5vdGF0aW9uLCBuZXh0QW5ub3RhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGdldFRva2VuR3JvdXBzKHRva2VucywgZm9jdXMsIGFubm90YXRpb25zKSB7XHJcbiAgICBjb25zdCBmb2N1c0V4dHJlbWVzID0gbWFwKGZvY3VzLCBmb2N1cyA9PiBBcnJheS5pc0FycmF5KGZvY3VzKSA/IGZvY3VzIDogW10pO1xyXG4gICAgY29uc3QgYW5ub3RhdGlvbkV4dHJlbWVzID0gbWFwKGFubm90YXRpb25zLCBhbm5vdGF0aW9ucyA9PiBhbm5vdGF0aW9ucy5tYXAoKHsgY29sdW1uTnVtYmVycyB9KSA9PiBjb2x1bW5OdW1iZXJzKSk7XHJcbiAgICBjb25zdCBhbGxFeHRyZW1lcyA9IFtcclxuICAgICAgICAuLi5mb2N1c0V4dHJlbWVzLnByZXYsXHJcbiAgICAgICAgLi4uZm9jdXNFeHRyZW1lcy5uZXh0LFxyXG4gICAgICAgIC4uLmFubm90YXRpb25FeHRyZW1lcy5wcmV2LFxyXG4gICAgICAgIC4uLmFubm90YXRpb25FeHRyZW1lcy5uZXh0LFxyXG4gICAgXTtcclxuICAgIGNvbnN0IHNwbGl0dGVkVG9rZW5zID0gc3BsaXRUb2tlbnModG9rZW5zLCBhbGxFeHRyZW1lcyk7XHJcbiAgICBsZXQgc3RhcnRJbmRleCA9IDA7XHJcbiAgICBsZXQgY3VycmVudEdyb3VwID0gbnVsbDtcclxuICAgIGNvbnN0IGdyb3VwcyA9IFtdO1xyXG4gICAgc3BsaXR0ZWRUb2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XHJcbiAgICAgICAgY29uc3QgbmV3UHJldkZvY3VzID0gaXNJbihzdGFydEluZGV4LCBmb2N1cy5wcmV2KTtcclxuICAgICAgICBjb25zdCBuZXdOZXh0Rm9jdXMgPSBpc0luKHN0YXJ0SW5kZXgsIGZvY3VzLm5leHQpO1xyXG4gICAgICAgIGNvbnN0IG5ld1ByZXZBbm5vdGF0aW9uID0gZ2V0QW5ub3RhdGlvbihzdGFydEluZGV4LCBhbm5vdGF0aW9ucy5wcmV2KTtcclxuICAgICAgICBjb25zdCBuZXdOZXh0QW5ub3RhdGlvbiA9IGdldEFubm90YXRpb24oc3RhcnRJbmRleCwgYW5ub3RhdGlvbnMubmV4dCk7XHJcbiAgICAgICAgaWYgKCFjdXJyZW50R3JvdXAgfHxcclxuICAgICAgICAgICAgY3VycmVudEdyb3VwLmZvY3VzZWQucHJldiAhPT0gbmV3UHJldkZvY3VzIHx8XHJcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC5mb2N1c2VkLm5leHQgIT09IG5ld05leHRGb2N1cyB8fFxyXG4gICAgICAgICAgICBjdXJyZW50R3JvdXAuYW5ub3RhdGlvbi5wcmV2ICE9PSBuZXdQcmV2QW5ub3RhdGlvbiB8fFxyXG4gICAgICAgICAgICBjdXJyZW50R3JvdXAuYW5ub3RhdGlvbi5uZXh0ICE9PSBuZXdOZXh0QW5ub3RhdGlvbikge1xyXG4gICAgICAgICAgICBjdXJyZW50R3JvdXAgPSB7XHJcbiAgICAgICAgICAgICAgICBmb2N1c2VkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldjogbmV3UHJldkZvY3VzLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG5ld05leHRGb2N1cyxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0b2tlbnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXY6IG5ld1ByZXZBbm5vdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG5ld05leHRBbm5vdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZ3JvdXBzLnB1c2goY3VycmVudEdyb3VwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEdyb3VwID09PSBudWxsIHx8IGN1cnJlbnRHcm91cCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEdyb3VwLnRva2Vucy5wdXNoKHRva2VuKTtcclxuICAgICAgICBzdGFydEluZGV4ICs9IHRva2VuLmNvbnRlbnQubGVuZ3RoO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZ3JvdXBzLm1hcChncm91cCA9PiAoe1xyXG4gICAgICAgIGZvY3VzZWQ6IGdyb3VwLmZvY3VzZWQsXHJcbiAgICAgICAgdG9rZW5zOiBncm91cC50b2tlbnMsXHJcbiAgICAgICAgZWxlbWVudDogZ2V0R3JvdXBFbGVtZW50KGdyb3VwKSxcclxuICAgIH0pKTtcclxufVxyXG5mdW5jdGlvbiBnZXRHcm91cEVsZW1lbnQoZ3JvdXApIHtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgZ3JvdXAudG9rZW5zLm1hcCgoeyBjb250ZW50LCBwcm9wcyB9LCBpKSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsga2V5OiBpICsgMSB9KSwgY29udGVudCkpKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBTcGxpdCBhIGxpc3Qgb2YgdG9rZW5zIGludG8gYSBtb3JlIGZpbmUtZ3JhbmVkIGxpc3Qgb2YgdG9rZW5zXHJcbiAqXHJcbiAqIHRva2VuczogW2FiY11bZGVmZ11cclxuICogZXh0cmVtZXM6IFsxOjIsMjo1XVxyXG4gKiByZXN1bHQgdG9rZW5zOiBbYWJdW2NdW2RlXVtmZ11cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHNwbGl0VG9rZW5zKHRva2VucywgZXh0cmVtZXMpIHtcclxuICAgIGNvbnN0IHNwbGl0SW5kZXhlcyA9IFtcclxuICAgICAgICAuLi5leHRyZW1lcy5tYXAoZSA9PiBlLnN0YXJ0IC0gMSksXHJcbiAgICAgICAgLi4uZXh0cmVtZXMubWFwKGUgPT4gZS5lbmQpLFxyXG4gICAgXTtcclxuICAgIGxldCBvbGRUb2tlbnMgPSB0b2tlbnM7XHJcbiAgICBzcGxpdEluZGV4ZXMuZm9yRWFjaChzcGxpdEluZGV4ID0+IHtcclxuICAgICAgICBjb25zdCBuZXdUb2tlbnMgPSBbXTtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgb2xkVG9rZW5zLmZvckVhY2godG9rZW4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gaTtcclxuICAgICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBpICsgdG9rZW4uY29udGVudC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNwbGl0ID0gc3RhcnRJbmRleCA8IHNwbGl0SW5kZXggJiYgc3BsaXRJbmRleCA8IGVuZEluZGV4O1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkU3BsaXQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNsaWNlSW5kZXggPSBzcGxpdEluZGV4IC0gc3RhcnRJbmRleDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQwID0gdG9rZW4uY29udGVudC5zbGljZSgwLCBzbGljZUluZGV4KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQxID0gdG9rZW4uY29udGVudC5zbGljZShzbGljZUluZGV4KTtcclxuICAgICAgICAgICAgICAgIG5ld1Rva2Vucy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG9rZW4pLCB7IGNvbnRlbnQ6IGNvbnRlbnQwIH0pKTtcclxuICAgICAgICAgICAgICAgIG5ld1Rva2Vucy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG9rZW4pLCB7IGNvbnRlbnQ6IGNvbnRlbnQxIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld1Rva2Vucy5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gZW5kSW5kZXg7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb2xkVG9rZW5zID0gbmV3VG9rZW5zO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gb2xkVG9rZW5zO1xyXG59XHJcbmZ1bmN0aW9uIGlzSW4oaW5kZXgsIGludGVydmFscykge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGludGVydmFscykpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJ2YWxzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGludGVydmFscy5zb21lKCh7IHN0YXJ0LCBlbmQgfSkgPT4gc3RhcnQgLSAxIDw9IGluZGV4ICYmIGluZGV4IDwgZW5kKTtcclxufVxyXG5mdW5jdGlvbiBnZXRBbm5vdGF0aW9uKGluZGV4LCBhbm5vdGF0aW9ucykge1xyXG4gICAgcmV0dXJuIGFubm90YXRpb25zLmZpbmQoKHsgY29sdW1uTnVtYmVycyB9KSA9PiBjb2x1bW5OdW1iZXJzLnN0YXJ0IC0gMSA8PSBpbmRleCAmJlxyXG4gICAgICAgIGluZGV4IDwgY29sdW1uTnVtYmVycy5lbmQpO1xyXG59XG5cbmZ1bmN0aW9uIHR3ZWVuJDEocGFyYW1zLCB0KSB7XHJcbiAgICAvLyBuZWVkcyA9PT0gdHJ1ZSBmb3IgdHlwZXNjcmlwdC4uLlxyXG4gICAgaWYgKHBhcmFtcy5maXhlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBwYXJhbXMudmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBwYXJhbXMuaW50ZXJ2YWw7XHJcbiAgICAgICAgY29uc3QgW2Zyb20sIHRvXSA9IHBhcmFtcy5leHRyZW1lcztcclxuICAgICAgICBpZiAodCA8IHN0YXJ0KVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbTtcclxuICAgICAgICBpZiAodCA+IGVuZClcclxuICAgICAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgICAgIGNvbnN0IHggPSAodCAtIHN0YXJ0KSAvIChlbmQgLSBzdGFydCk7XHJcbiAgICAgICAgY29uc3QgZWFzZSA9IHBhcmFtcy5lYXNlIHx8IGVhc2luZy5saW5lYXI7XHJcbiAgICAgICAgcmV0dXJuIGZyb20gKyBlYXNlKHgpICogKHRvIC0gZnJvbSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3RhZ2dlcihbc3RhcnQsIGVuZF0sIGluZGV4LCBjb3VudCkge1xyXG4gICAgaWYgKGNvdW50IDw9IDEpXHJcbiAgICAgICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcclxuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBlbmQgLSBzdGFydDtcclxuICAgIGNvbnN0IHN0ZXBEdXJhdGlvbiA9IHRvdGFsRHVyYXRpb24gLyBNYXRoLnBvdyhjb3VudCwgMSAvIDgpO1xyXG4gICAgY29uc3QgdGljayA9ICh0b3RhbER1cmF0aW9uIC0gc3RlcER1cmF0aW9uKSAvIChjb3VudCAtIDEpO1xyXG4gICAgY29uc3Qgc3RlcFN0YXJ0ID0gc3RhcnQgKyB0aWNrICogaW5kZXg7XHJcbiAgICBjb25zdCBzdGVwRW5kID0gc3RlcFN0YXJ0ICsgc3RlcER1cmF0aW9uO1xyXG4gICAgcmV0dXJuIFtzdGVwU3RhcnQsIHN0ZXBFbmRdO1xyXG59XHJcbmNvbnN0IGVhc2luZyA9IHtcclxuICAgIGxpbmVhcjogZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH0sXHJcbiAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIHJldHVybiB0ICogdDtcclxuICAgIH0sXHJcbiAgICBlYXNlT3V0UXVhZDogZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICByZXR1cm4gdCAqICgyIC0gdCk7XHJcbiAgICB9LFxyXG4gICAgZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHQgPCAwLjVcclxuICAgICAgICAgICAgPyA0ICogdCAqIHQgKiB0XHJcbiAgICAgICAgICAgIDogKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxO1xyXG4gICAgfSxcclxufTtcblxuZnVuY3Rpb24gZ2V0TGluZXNXaXRoRWxlbWVudHMobGluZXMsIHZlcnRpY2FsSW50ZXJ2YWwsIGVudGVyQ291bnQsIGV4aXRDb3VudCkge1xyXG4gICAgLy8gc3RhcnRZIGlzIHRoZSBwcm9ncmVzcyB3aGVuIHdlIHN0YXJ0IG1vdmluZyB2ZXJ0aWNhbGx5XHJcbiAgICAvLyBlbmRZIGlzIHdoZW4gd2Ugc3RvcFxyXG4gICAgY29uc3QgW3N0YXJ0WSwgZW5kWV0gPSB2ZXJ0aWNhbEludGVydmFsO1xyXG4gICAgcmV0dXJuIGxpbmVzLm1hcChsaW5lID0+IHtcclxuICAgICAgICBjb25zdCBsaW5lSW5kZXggPSBtYXAobGluZS5saW5lTnVtYmVyLCBsbiA9PiBsbiAmJiBsbiAtIDEpO1xyXG4gICAgICAgIGNvbnN0IHsgZW50ZXJJbmRleCwgZXhpdEluZGV4IH0gPSBsaW5lO1xyXG4gICAgICAgIGNvbnN0IHR3ZWVuWSA9IGxpbmUubW92ZSA9PT0gXCJleGl0XCJcclxuICAgICAgICAgICAgPyB7IGZpeGVkOiB0cnVlLCB2YWx1ZTogbGluZUluZGV4LnByZXYgfVxyXG4gICAgICAgICAgICA6IGxpbmUubW92ZSA9PT0gXCJlbnRlclwiXHJcbiAgICAgICAgICAgICAgICA/IHsgZml4ZWQ6IHRydWUsIHZhbHVlOiBsaW5lSW5kZXgubmV4dCB9XHJcbiAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICBmaXhlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtZXM6IFtsaW5lSW5kZXgucHJldiwgbGluZUluZGV4Lm5leHRdLFxyXG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsOiBbc3RhcnRZLCBlbmRZXSxcclxuICAgICAgICAgICAgICAgICAgICBlYXNlOiBlYXNpbmcuZWFzZUluT3V0Q3ViaWMsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHR3ZWVuWCA9IGxpbmUubW92ZSA9PT0gXCJleGl0XCJcclxuICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICBmaXhlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBleHRyZW1lczogWzAsIC0xXSxcclxuICAgICAgICAgICAgICAgIGVhc2U6IGVhc2luZy5lYXNlSW5RdWFkLFxyXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IHN0YWdnZXIoWzAsIHN0YXJ0WV0sIGV4aXRJbmRleCwgZXhpdENvdW50KSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IGxpbmUubW92ZSA9PT0gXCJlbnRlclwiXHJcbiAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICBmaXhlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtZXM6IFsxLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBlYXNlOiBlYXNpbmcuZWFzZU91dFF1YWQsXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWw6IHN0YWdnZXIoW2VuZFksIDFdLCBlbnRlckluZGV4LCBlbnRlckNvdW50KSxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDogeyBmaXhlZDogdHJ1ZSwgdmFsdWU6IDAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsaW5lKSwgeyB0d2VlblgsXHJcbiAgICAgICAgICAgIHR3ZWVuWSB9KTtcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIHBhcnNlQW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMpIHtcclxuICAgIC8vIHNwbGl0IGFubm90YXRpb25zIHdpdGggbXVsdGlwbGUgcGFydHMgaW4gdGhlIGZvY3VzIHN0cmluZ1xyXG4gICAgLy8gXCIxOjIsM1s0OjVdXCIgYmVjb21lcyAgdHdvIGFubm90YXRpb25zIFwiMToyXCIgYW5kIFwiM1s0OjVdXCJcclxuICAgIGNvbnN0IGV4cGFuZGVkQW5ub3RhdGlvbnMgPSBtYXBXaXRoRGVmYXVsdChhbm5vdGF0aW9ucywgW10sIGFubm90YXRpb25zID0+IGFubm90YXRpb25zLmZsYXRNYXAoYW5ub3RhdGlvbiA9PiBzcGxpdFBhcnRzKGFubm90YXRpb24uZm9jdXMpLm1hcChwYXJ0ID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFubm90YXRpb24pLCB7IGZvY3VzOiBwYXJ0IH0pKSkpKTtcclxuICAgIGNvbnN0IGlubGluZUNvZGVBbm5vdGF0aW9ucyA9IG1hcFdpdGhEZWZhdWx0KGV4cGFuZGVkQW5ub3RhdGlvbnMsIFtdLCBhbm5vdGF0aW9ucyA9PiBhbm5vdGF0aW9ucy5maWx0ZXIoaXNJbmxpbmUpKTtcclxuICAgIGNvbnN0IG11bHRpbGluZUNvZGVBbm5vdGF0aW9ucyA9IG1hcFdpdGhEZWZhdWx0KGV4cGFuZGVkQW5ub3RhdGlvbnMsIFtdLCBhbm5vdGF0aW9ucyA9PiBhbm5vdGF0aW9ucy5maWx0ZXIoYSA9PiAhaXNJbmxpbmUoYSkpKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaW5saW5lQW5ub3RhdGlvbnM6IG1hcChpbmxpbmVDb2RlQW5ub3RhdGlvbnMsIGFubm90YXRpb25zID0+IHBhcnNlSW5saW5lQW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMpKSxcclxuICAgICAgICBtdWx0aWxpbmVBbm5vdGF0aW9uczogbWFwKG11bHRpbGluZUNvZGVBbm5vdGF0aW9ucywgYW5ub3RhdGlvbnMgPT4gcGFyc2VNdWx0aWxpbmVBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucykpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc0lubGluZShhbm5vdGF0aW9uKSB7XHJcbiAgICByZXR1cm4gaGFzQ29sdW1ucyhhbm5vdGF0aW9uLmZvY3VzKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUlubGluZUFubm90YXRpb25zKGFubm90YXRpb25zKSB7XHJcbiAgICBjb25zdCBhbm5vdGF0aW9uTWFwID0ge307XHJcbiAgICBhbm5vdGF0aW9ucy5mb3JFYWNoKGFubm90YXRpb24gPT4ge1xyXG4gICAgICAgIGNvbnN0IGZvY3VzTWFwID0gcGFyc2VQYXJ0VG9PYmplY3QoYW5ub3RhdGlvbi5mb2N1cyk7XHJcbiAgICAgICAgY29uc3QgbGluZU51bWJlciA9ICtPYmplY3Qua2V5cyhmb2N1c01hcClbMF07XHJcbiAgICAgICAgY29uc3QgY29sdW1uTnVtYmVyc0xpc3QgPSBmb2N1c01hcFtsaW5lTnVtYmVyXTtcclxuICAgICAgICBjb25zdCBsaW5lQW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9uTWFwW2xpbmVOdW1iZXJdIHx8IFtdO1xyXG4gICAgICAgIGxpbmVBbm5vdGF0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgY29sdW1uTnVtYmVyczogY29sdW1uTnVtYmVyc0xpc3RbMF0sXHJcbiAgICAgICAgICAgIGRhdGE6IGFubm90YXRpb24uZGF0YSxcclxuICAgICAgICAgICAgQ29tcG9uZW50OiBhbm5vdGF0aW9uLkNvbXBvbmVudCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBhbm5vdGF0aW9uTWFwW2xpbmVOdW1iZXJdID0gbGluZUFubm90YXRpb25zO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYW5ub3RhdGlvbk1hcDtcclxufVxyXG5mdW5jdGlvbiBwYXJzZU11bHRpbGluZUFubm90YXRpb25zKGFubm90YXRpb25zKSB7XHJcbiAgICByZXR1cm4gYW5ub3RhdGlvbnMubWFwKGFubm90YXRpb24gPT4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiBwYXJzZUV4dHJlbWVzKGFubm90YXRpb24uZm9jdXMpLFxyXG4gICAgICAgICAgICBkYXRhOiBhbm5vdGF0aW9uLmRhdGEsXHJcbiAgICAgICAgICAgIENvbXBvbmVudDogYW5ub3RhdGlvbi5Db21wb25lbnQsXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcbi8vIC0tLSBtdWx0aWxpbmVcclxuZnVuY3Rpb24gYW5ub3RhdGVNdWx0aWxpbmUobGluZXMsIGFubm90YXRpb25zKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByZXY6IGFubm90YXRlTXVsdGlsaW5lU2lkZShsaW5lcywgYW5ub3RhdGlvbnMucHJldiwgbGluZSA9PiBsaW5lLmxpbmVOdW1iZXIucHJldiksXHJcbiAgICAgICAgbmV4dDogYW5ub3RhdGVNdWx0aWxpbmVTaWRlKGxpbmVzLCBhbm5vdGF0aW9ucy5uZXh0LCBsaW5lID0+IGxpbmUubGluZU51bWJlci5uZXh0KSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gYW5ub3RhdGVNdWx0aWxpbmVTaWRlKGxpbmVzLCBvZ0Fubm90YXRpb25zLCBnZXRMaW5lTnVtYmVyKSB7XHJcbiAgICBjb25zdCBhbm5vdGF0aW9ucyA9IFsuLi5vZ0Fubm90YXRpb25zXTtcclxuICAgIGFubm90YXRpb25zLnNvcnQoKGEsIGIpID0+IGEubGluZU51bWJlcnMuc3RhcnQgLSBiLmxpbmVOdW1iZXJzLnN0YXJ0KTtcclxuICAgIGxldCBsaW5lSW5kZXggPSAwO1xyXG4gICAgY29uc3QgZ3JvdXBzID0gW107XHJcbiAgICB3aGlsZSAobGluZUluZGV4IDwgbGluZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zWzBdO1xyXG4gICAgICAgIGxldCBsaW5lID0gbGluZXNbbGluZUluZGV4XTtcclxuICAgICAgICBpZiAoYW5ub3RhdGlvbiAmJlxyXG4gICAgICAgICAgICBnZXRMaW5lTnVtYmVyKGxpbmUpID4gYW5ub3RhdGlvbi5saW5lTnVtYmVycy5zdGFydCkge1xyXG4gICAgICAgICAgICB0aHJvdyBcIkNvZGUgSGlrZSBjYW4ndCBoYW5kbGUgdHdvIGFubm90YXRpb25zIGZvciB0aGUgc2FtZSBsaW5lXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhbm5vdGF0aW9uICYmXHJcbiAgICAgICAgICAgIGdldExpbmVOdW1iZXIobGluZSkgPT09IGFubm90YXRpb24ubGluZU51bWJlcnMuc3RhcnQpIHtcclxuICAgICAgICAgICAgLy8gY3JlYXRlIGFubm90YXRpb24gZ3JvdXBcclxuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lczogW10sXHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB3aGlsZSAobGluZSAmJlxyXG4gICAgICAgICAgICAgICAgKCFnZXRMaW5lTnVtYmVyKGxpbmUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0TGluZU51bWJlcihsaW5lKSA8PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLmxpbmVOdW1iZXJzLmVuZCkpIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwLmxpbmVzLnB1c2gobGluZSk7XHJcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZXNbKytsaW5lSW5kZXhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGdyb3VwKTtcclxuICAgICAgICAgICAgYW5ub3RhdGlvbnMuc2hpZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWFubm90YXRpb24pIHtcclxuICAgICAgICAgICAgLy8gY3JlYXRlIHVuYW5ub3RhdGVkIGdyb3VwIHVudGlsIHRoZSBlbmRcclxuICAgICAgICAgICAgZ3JvdXBzLnB1c2goeyBsaW5lczogbGluZXMuc2xpY2UobGluZUluZGV4KSB9KTtcclxuICAgICAgICAgICAgbGluZUluZGV4ID0gbGluZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gY3JlYXRlIHVuYW5ub3RhdGVkIGdyb3VwIHVudGlsIG5leHQgYW5ub3RhdGlvblxyXG4gICAgICAgICAgICBjb25zdCBncm91cCA9IHtcclxuICAgICAgICAgICAgICAgIGxpbmVzOiBbXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2hpbGUgKGxpbmUgJiZcclxuICAgICAgICAgICAgICAgICghZ2V0TGluZU51bWJlcihsaW5lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGdldExpbmVOdW1iZXIobGluZSkgPFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLmxpbmVOdW1iZXJzLnN0YXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXAubGluZXMucHVzaChsaW5lKTtcclxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lc1srK2xpbmVJbmRleF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBncm91cHM7XHJcbn1cclxuLy8gLS0tIGlubGluZVxyXG5mdW5jdGlvbiBhbm5vdGF0ZUlubGluZShsaW5lcywgaW5saW5lQW5ub3RhdGlvbnMpIHtcclxuICAgIHJldHVybiBsaW5lcy5tYXAoKF9hKSA9PiB7XHJcbiAgICAgICAgdmFyIHsgZ3JvdXBzIH0gPSBfYSwgbGluZSA9IF9fcmVzdChfYSwgW1wiZ3JvdXBzXCJdKTtcclxuICAgICAgICBjb25zdCB7IGxpbmVOdW1iZXIgfSA9IGxpbmU7XHJcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHByZXY6IGxpbmVOdW1iZXIucHJldlxyXG4gICAgICAgICAgICAgICAgPyBpbmxpbmVBbm5vdGF0aW9ucy5wcmV2W2xpbmVOdW1iZXIucHJldl0gfHwgW11cclxuICAgICAgICAgICAgICAgIDogW10sXHJcbiAgICAgICAgICAgIG5leHQ6IGxpbmVOdW1iZXIubmV4dFxyXG4gICAgICAgICAgICAgICAgPyBpbmxpbmVBbm5vdGF0aW9ucy5uZXh0W2xpbmVOdW1iZXIubmV4dF0gfHwgW11cclxuICAgICAgICAgICAgICAgIDogW10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsaW5lKSwgeyBhbm5vdGF0ZWRHcm91cHM6IGFubm90YXRlTGluZVRva2VuR3JvdXBzKGdyb3VwcywgYW5ub3RhdGlvbnMpIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgbGlzdCBvZiBhbm5vdGF0ZWQgZ3JvdXBzIHR3ZWVuc1xyXG4gKiBlYWNoIGFubm90YXRlZCBncm91cCBjb250YWlucyBhIGxpc3Qgb2YgdG9rZW4gZ3JvdXBzIGFuZCBtYXliZSBhbiBhbm5vdGF0aW9uLlxyXG4gKiBUaGUgdHdvIGFubm90YXRlZCBncm91cHMgaW4gYSB0d2VlbiBkb2Vzbid0IG5lZWQgdG8gaGF2ZSB0aGUgc2FtZSB0b2tlbiBncm91cHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBhbm5vdGF0ZUxpbmVUb2tlbkdyb3Vwcyh0b2tlbkdyb3VwcywgYW5ub3RhdGlvbnMpIHtcclxuICAgIGxldCBwcmV2VG9rZW5Hcm91cHMgPSBbLi4udG9rZW5Hcm91cHNdO1xyXG4gICAgbGV0IG5leHRUb2tlbkdyb3VwcyA9IFsuLi50b2tlbkdyb3Vwc107XHJcbiAgICBjb25zdCBwcmV2QW5ub3RhdGlvbnMgPSBbLi4uYW5ub3RhdGlvbnMucHJldl07XHJcbiAgICBjb25zdCBuZXh0QW5ub3RhdGlvbnMgPSBbLi4uYW5ub3RhdGlvbnMubmV4dF07XHJcbiAgICBjb25zdCBhbm5vdGF0ZWRHcm91cHMgPSBbXTtcclxuICAgIGxldCBwcmV2Q29sdW1uID0gMTtcclxuICAgIGxldCBuZXh0Q29sdW1uID0gMTtcclxuICAgIC8vIGl0ZXJhdGUgdW50aWwgd2UgY29uc3VtZSBib3RoIGxpc3RzIG9mIHRva2VuIGdyb3Vwc1xyXG4gICAgd2hpbGUgKHByZXZUb2tlbkdyb3Vwcy5sZW5ndGggPiAwIHx8XHJcbiAgICAgICAgbmV4dFRva2VuR3JvdXBzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBwcmV2QW5ub3RhdGlvbiA9IHByZXZBbm5vdGF0aW9uc1swXTtcclxuICAgICAgICBjb25zdCBuZXh0QW5ub3RhdGlvbiA9IG5leHRBbm5vdGF0aW9uc1swXTtcclxuICAgICAgICBjb25zdCBpc1ByZXZBbm5vdGF0aW9uU3RhcnRpbmcgPSBwcmV2QW5ub3RhdGlvbiAmJlxyXG4gICAgICAgICAgICBwcmV2QW5ub3RhdGlvbi5jb2x1bW5OdW1iZXJzLnN0YXJ0ID09PSBwcmV2Q29sdW1uO1xyXG4gICAgICAgIGNvbnN0IGlzTmV4dEFubm90YXRpb25TdGFydGluZyA9IG5leHRBbm5vdGF0aW9uICYmXHJcbiAgICAgICAgICAgIG5leHRBbm5vdGF0aW9uLmNvbHVtbk51bWJlcnMuc3RhcnQgPT09IG5leHRDb2x1bW47XHJcbiAgICAgICAgaWYgKHByZXZDb2x1bW4gPCBuZXh0Q29sdW1uKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwcmV2IGxpc3QgaXMgYmVoaW5kIHdlIGNvbnN1bWUgZnJvbSBwcmV2VG9rZW5Hcm91cHNcclxuICAgICAgICAgICAgaWYgKGlzUHJldkFubm90YXRpb25TdGFydGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gYW5ub3RhdGlvbiBzdGFydGluZyBhdCB0aGlzIHBvaW50IHdlIGNvbnN1bWUgdW50aWwgdGhlIGFubm90YXRpb24gZW5kc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcHJldkFubm90YXRpb24uY29sdW1uTnVtYmVycy5lbmQgKyAxO1xyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGVkR3JvdXBzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXY6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbjogcHJldkFubm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwczogc2hpZnRHcm91cHMocHJldlRva2VuR3JvdXBzLCBwcmV2Q29sdW1uLCBlbmQpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHByZXZDb2x1bW4gPSBlbmQ7XHJcbiAgICAgICAgICAgICAgICBwcmV2QW5ub3RhdGlvbnMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzbid0IHdlIGNvbnN1bWUgdW50aWwgd2Ugc3luYyB3aXRoIHRoZSBuZXh0IGxpc3Qgb3IgYW4gYW5ub3RhdGlvbiBzdGFydHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKG5leHRDb2x1bW4sIChwcmV2QW5ub3RhdGlvbiA9PT0gbnVsbCB8fCBwcmV2QW5ub3RhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldkFubm90YXRpb24uY29sdW1uTnVtYmVycy5zdGFydCkgfHwgbmV4dENvbHVtbik7XHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0ZWRHcm91cHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHM6IHNoaWZ0R3JvdXBzKHByZXZUb2tlbkdyb3VwcywgcHJldkNvbHVtbiwgZW5kKSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBwcmV2Q29sdW1uID0gZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByZXZDb2x1bW4gPiBuZXh0Q29sdW1uKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBuZXh0IGxpc3QgaXMgYmVoaW5kIHdlIGNvbnN1bWUgZnJvbSBuZXh0VG9rZW5Hcm91cHNcclxuICAgICAgICAgICAgaWYgKGlzTmV4dEFubm90YXRpb25TdGFydGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gYW5ub3RhdGlvbiBzdGFydGluZyBhdCB0aGlzIHBvaW50IHdlIGNvbnN1bWUgdW50aWwgdGhlIGFubm90YXRpb24gZW5kc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gbmV4dEFubm90YXRpb24uY29sdW1uTnVtYmVycy5lbmQgKyAxO1xyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGVkR3JvdXBzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbjogbmV4dEFubm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwczogc2hpZnRHcm91cHMobmV4dFRva2VuR3JvdXBzLCBuZXh0Q29sdW1uLCBlbmQpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG5leHRDb2x1bW4gPSBlbmQ7XHJcbiAgICAgICAgICAgICAgICBuZXh0QW5ub3RhdGlvbnMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzbid0IHdlIGNvbnN1bWUgdW50aWwgd2Ugc3luYyB3aXRoIHRoZSBwcmV2IGxpc3Qgb3IgYW4gYW5ub3RhdGlvbiBzdGFydHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHByZXZDb2x1bW4sIChuZXh0QW5ub3RhdGlvbiA9PT0gbnVsbCB8fCBuZXh0QW5ub3RhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dEFubm90YXRpb24uY29sdW1uTnVtYmVycy5zdGFydCkgfHwgcHJldkNvbHVtbik7XHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0ZWRHcm91cHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHM6IHNoaWZ0R3JvdXBzKG5leHRUb2tlbkdyb3VwcywgbmV4dENvbHVtbiwgZW5kKSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBuZXh0Q29sdW1uID0gZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByZXZDb2x1bW4gPT0gbmV4dENvbHVtbikge1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgYXQgdGhlIHNhbWUgY29sdW1uIGluIGJvdGggbGlzdHMgd2UgaGF2ZSA1IGRpZmZlcmVudCBjYXNlc1xyXG4gICAgICAgICAgICBpZiAoaXNQcmV2QW5ub3RhdGlvblN0YXJ0aW5nICYmXHJcbiAgICAgICAgICAgICAgICBpc05leHRBbm5vdGF0aW9uU3RhcnRpbmcgJiZcclxuICAgICAgICAgICAgICAgIHByZXZBbm5vdGF0aW9uLmNvbHVtbk51bWJlcnMuZW5kID09PVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRBbm5vdGF0aW9uLmNvbHVtbk51bWJlcnMuZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBib3RoIGFubm90YXRpb25zIHN0YXJ0cyBoZXJlIGFuZCBlbmQgYXQgdGhlIHNhbWUgcGxhY2UsIHNvIHdlIHB1dGggYm90aCBpbiBvbmUgdHdlZW4gYW5ub3RhdGVkIGdyb3VwXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBuZXh0QW5ub3RhdGlvbi5jb2x1bW5OdW1iZXJzLmVuZCArIDE7XHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0ZWRHcm91cHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uOiBwcmV2QW5ub3RhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzOiBzaGlmdEdyb3VwcyhwcmV2VG9rZW5Hcm91cHMsIHByZXZDb2x1bW4sIGVuZCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBuZXh0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRpb246IG5leHRBbm5vdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHM6IHNoaWZ0R3JvdXBzKG5leHRUb2tlbkdyb3VwcywgbmV4dENvbHVtbiwgZW5kKSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBwcmV2Q29sdW1uID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgbmV4dENvbHVtbiA9IGVuZDtcclxuICAgICAgICAgICAgICAgIHByZXZBbm5vdGF0aW9ucy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgbmV4dEFubm90YXRpb25zLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmV2QW5ub3RhdGlvblN0YXJ0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBvbmx5IHRoZSBwcmV2IGFubm90YXRpb24gc3RhcnRpbmcgYXQgdGhpcyBwb2ludCB3ZSBjb25zdW1lIHVudGlsIHRoZSBhbm5vdGF0aW9uIGVuZHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHByZXZBbm5vdGF0aW9uLmNvbHVtbk51bWJlcnMuZW5kICsgMTtcclxuICAgICAgICAgICAgICAgIGFubm90YXRlZEdyb3Vwcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRpb246IHByZXZBbm5vdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHM6IHNoaWZ0R3JvdXBzKHByZXZUb2tlbkdyb3VwcywgcHJldkNvbHVtbiwgZW5kKSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBwcmV2Q29sdW1uID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgcHJldkFubm90YXRpb25zLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOZXh0QW5ub3RhdGlvblN0YXJ0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGZvciB0aGUgbmV4dCBhbm5vdGF0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBuZXh0QW5ub3RhdGlvbi5jb2x1bW5OdW1iZXJzLmVuZCArIDE7XHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0ZWRHcm91cHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uOiBuZXh0QW5ub3RhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzOiBzaGlmdEdyb3VwcyhuZXh0VG9rZW5Hcm91cHMsIG5leHRDb2x1bW4sIGVuZCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbmV4dENvbHVtbiA9IGVuZDtcclxuICAgICAgICAgICAgICAgIG5leHRBbm5vdGF0aW9ucy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFwcmV2QW5ub3RhdGlvbiAmJiAhbmV4dEFubm90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZW4ndCBhbnkgcmVtYWluaW5nIGFubm90YXRpb24gd2UgYWRkIGEgbGFzdCBncm91cFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGVkR3JvdXBzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXY6IHsgZ3JvdXBzOiBwcmV2VG9rZW5Hcm91cHMgfSxcclxuICAgICAgICAgICAgICAgICAgICBuZXh0OiB7IGdyb3VwczogbmV4dFRva2VuR3JvdXBzIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGxhc3QgaXRlcmF0aW9uXHJcbiAgICAgICAgICAgICAgICBwcmV2VG9rZW5Hcm91cHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIG5leHRUb2tlbkdyb3VwcyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBhbm5vdGF0aW9ucyBsZWZ0IHdlIGNvbnN1bWUgdW50aWwgdGhlIG5leHQgb25lXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbigocHJldkFubm90YXRpb24gPT09IG51bGwgfHwgcHJldkFubm90YXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZBbm5vdGF0aW9uLmNvbHVtbk51bWJlcnMuc3RhcnQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyLk1BWF9WQUxVRSwgKG5leHRBbm5vdGF0aW9uID09PSBudWxsIHx8IG5leHRBbm5vdGF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXh0QW5ub3RhdGlvbi5jb2x1bW5OdW1iZXJzLnN0YXJ0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIE51bWJlci5NQVhfVkFMVUUpO1xyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGVkR3JvdXBzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXY6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzOiBzaGlmdEdyb3VwcyhwcmV2VG9rZW5Hcm91cHMsIHByZXZDb2x1bW4sIGVuZCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBuZXh0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwczogc2hpZnRHcm91cHMobmV4dFRva2VuR3JvdXBzLCBuZXh0Q29sdW1uLCBlbmQpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHByZXZDb2x1bW4gPSBlbmQ7XHJcbiAgICAgICAgICAgICAgICBuZXh0Q29sdW1uID0gZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFubm90YXRlZEdyb3VwcztcclxufVxyXG4vKipcclxuICogUmVtb3ZlIGFuZCByZXR1cm4gc29tZSBncm91cHMgZnJvbSB0aGUgYmVnZ2luaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBzdGFydENvbHVtbiBpcyB0aGUgY29sdW1uIGF0IHdoaWNoIHRoZSBhcnJheSBpcyBzdGFydGluZ1xyXG4gKiAoYmVjYXVzZSBvdGhlciBncm91cHMgaGFzIGJlZW4gYWxyZWFkeSByZW1vdmVkKVxyXG4gKiBuZXdTdGFydENvbHVtbiBpcyB0aGUgZmlyc3QgY29sdW1uIHRoYXQgc2hvdWxkIHN0YXkgaW4gdGhlIGFycmF5XHJcbiAqL1xyXG5mdW5jdGlvbiBzaGlmdEdyb3Vwcyh0b2tlbkdyb3Vwcywgc3RhcnRDb2x1bW4sIG5ld1N0YXJ0Q29sdW1uKSB7XHJcbiAgICBjb25zdCByZW1vdmVkR3JvdXBzID0gW107XHJcbiAgICBsZXQgY3VycmVudFN0YXJ0Q29sdW1uID0gc3RhcnRDb2x1bW47XHJcbiAgICB3aGlsZSAoY3VycmVudFN0YXJ0Q29sdW1uIDwgbmV3U3RhcnRDb2x1bW4gJiZcclxuICAgICAgICB0b2tlbkdyb3Vwcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFRva2VuR3JvdXAgPSB0b2tlbkdyb3Vwcy5zaGlmdCgpO1xyXG4gICAgICAgIHJlbW92ZWRHcm91cHMucHVzaChjdXJyZW50VG9rZW5Hcm91cCk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY3VycmVudFRva2VuR3JvdXAudG9rZW5zLnJlZHVjZSgoYSwgdCkgPT4gYSArIHQuY29udGVudC5sZW5ndGgsIDApO1xyXG4gICAgICAgIGN1cnJlbnRTdGFydENvbHVtbiArPSBsZW5ndGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVtb3ZlZEdyb3VwcztcclxufVxuXG5mdW5jdGlvbiB1c2VTdGVwUGFyc2VyKGlucHV0KSB7XHJcbiAgICBjb25zdCB7IGhpZ2hsaWdodGVkTGluZXMsIGZvY3VzIH0gPSBpbnB1dDtcclxuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHBhcnNlJDEoaW5wdXQpLCBbXHJcbiAgICAgICAgaGlnaGxpZ2h0ZWRMaW5lcy5wcmV2LFxyXG4gICAgICAgIGhpZ2hsaWdodGVkTGluZXMubmV4dCxcclxuICAgICAgICBmb2N1cy5wcmV2LFxyXG4gICAgICAgIGZvY3VzLm5leHQsXHJcbiAgICBdKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZSQxKHsgZm9jdXMsIGFubm90YXRpb25zLCBoaWdobGlnaHRlZExpbmVzLCBsYW5nLCB9KSB7XHJcbiAgICBjb25zdCBub3JtYWxDb2RlID0gZ2V0Q29kZShoaWdobGlnaHRlZExpbmVzKTtcclxuICAgIGNvbnN0IG1lcmdlZENvZGUgPSBtZXJnZShub3JtYWxDb2RlLCBoaWdobGlnaHRlZExpbmVzKTtcclxuICAgIGNvbnN0IHsgaW5saW5lQW5ub3RhdGlvbnMsIG11bHRpbGluZUFubm90YXRpb25zIH0gPSBwYXJzZUFsbEFubm90YXRpb25zKGFubm90YXRpb25zKTtcclxuICAgIGNvbnN0IGZvY3VzZWRDb2RlID0gc3BsaXRMaW5lc0J5Rm9jdXMobWVyZ2VkQ29kZSwgd2l0aERlZmF1bHQoZm9jdXMsIG51bGwpLCBpbmxpbmVBbm5vdGF0aW9ucyk7XHJcbiAgICBjb25zdCBhbm5vdGF0ZWRDb2RlID0gYWRkQW5ub3RhdGlvbnMoZm9jdXNlZENvZGUsIGlubGluZUFubm90YXRpb25zLCBtdWx0aWxpbmVBbm5vdGF0aW9ucyk7XHJcbiAgICBjb25zdCBjb2RlU3RlcCA9IGFkZEV4dHJhU3R1ZmYoYW5ub3RhdGVkQ29kZSwgbm9ybWFsQ29kZSwgbGFuZyk7XHJcbiAgICAvLyBjb25zb2xlLmxvZyh7IGNvZGVTdGVwIH0pXHJcbiAgICByZXR1cm4gY29kZVN0ZXA7XHJcbn1cclxuLy8gMCAtIG5vcm1hbGl6ZVxyXG5mdW5jdGlvbiBnZXRDb2RlKGhpZ2hsaWdodGVkTGluZXMpIHtcclxuICAgIHJldHVybiBtYXAoaGlnaGxpZ2h0ZWRMaW5lcywgbGluZXMgPT4gbGluZXNcclxuICAgICAgICAubWFwKGxpbmUgPT4gbGluZS50b2tlbnMubWFwKHQgPT4gdC5jb250ZW50KS5qb2luKFwiXCIpKVxyXG4gICAgICAgIC5qb2luKFwiXFxuXCIpXHJcbiAgICAgICAgLnRyaW1FbmQoKVxyXG4gICAgICAgIC5jb25jYXQoXCJcXG5cIikpO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlKGNvZGUsIGhpZ2hsaWdodGVkTGluZXMpIHtcclxuICAgIHJldHVybiBtZXJnZUxpbmVzKGNvZGUsIGhpZ2hsaWdodGVkTGluZXMpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQWxsQW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMpIHtcclxuICAgIHJldHVybiBwYXJzZUFubm90YXRpb25zKGFubm90YXRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBzcGxpdExpbmVzQnlGb2N1cyhtZXJnZWRDb2RlLCBmb2N1cywgYW5ub3RhdGlvbnMpIHtcclxuICAgIHJldHVybiBzcGxpdEJ5Rm9jdXMobWVyZ2VkQ29kZSwgZm9jdXMsIGFubm90YXRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBhZGRBbm5vdGF0aW9ucyhfYSwgaW5saW5lQW5ub3RhdGlvbnMsIGFubm90YXRpb25zKSB7XHJcbiAgICB2YXIgeyBsaW5lcyB9ID0gX2EsIGZvY3VzZWRDb2RlID0gX19yZXN0KF9hLCBbXCJsaW5lc1wiXSk7XHJcbiAgICBjb25zdCBhbm5vdGF0ZWRMaW5lcyA9IGFubm90YXRlSW5saW5lKGxpbmVzLCBpbmxpbmVBbm5vdGF0aW9ucyk7XHJcbiAgICBjb25zdCBsaW5lR3JvdXBzID0gYW5ub3RhdGVNdWx0aWxpbmUoYW5ub3RhdGVkTGluZXMsIGFubm90YXRpb25zKTtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZvY3VzZWRDb2RlKSwgeyBsaW5lR3JvdXBzOiBsaW5lR3JvdXBzLCBsaW5lQ291bnQ6IHtcclxuICAgICAgICAgICAgcHJldjogbGluZXMuZmlsdGVyKGwgPT4gbC5saW5lTnVtYmVyLnByZXYgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIC5sZW5ndGgsXHJcbiAgICAgICAgICAgIG5leHQ6IGxpbmVzLmZpbHRlcihsID0+IGwubGluZU51bWJlci5uZXh0ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAubGVuZ3RoLFxyXG4gICAgICAgIH0gfSk7XHJcbn1cclxuZnVuY3Rpb24gYWRkRXh0cmFTdHVmZihjb2RlU3RlcCwgY29kZSwgbGFuZykge1xyXG4gICAgY29uc3QgdkludGVydmFsID0gdmVydGljYWxJbnRlcnZhbChjb2RlU3RlcC5lbnRlckNvdW50LCBjb2RlU3RlcC5leGl0Q291bnQpO1xyXG4gICAgY29uc3QgbmV3R3JvdXBzID0gbWFwKGNvZGVTdGVwLmxpbmVHcm91cHMsIGdyb3VwcyA9PiBncm91cHMubWFwKGdyb3VwID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdyb3VwKSwgeyBsaW5lczogZ2V0TGluZXNXaXRoRWxlbWVudHMoZ3JvdXAubGluZXMsIHZJbnRlcnZhbCwgY29kZVN0ZXAuZW50ZXJDb3VudCwgY29kZVN0ZXAuZXhpdENvdW50KSB9KSkpKTtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvZGVTdGVwKSwgeyBncm91cHM6IG5ld0dyb3VwcywgdmVydGljYWxJbnRlcnZhbDogdkludGVydmFsLCBjb2RlLFxyXG4gICAgICAgIGxhbmcgfSk7XHJcbn1cclxuZnVuY3Rpb24gdmVydGljYWxJbnRlcnZhbChlbnRlckNvdW50LCBleGl0Q291bnQpIHtcclxuICAgIGlmIChlbnRlckNvdW50IDw9IDAgJiYgZXhpdENvdW50IDw9IDApXHJcbiAgICAgICAgcmV0dXJuIFswLCAxXTtcclxuICAgIGlmIChlbnRlckNvdW50IDw9IDAgJiYgZXhpdENvdW50ID49IDEpXHJcbiAgICAgICAgcmV0dXJuIFswLjMzLCAxXTtcclxuICAgIGlmIChlbnRlckNvdW50ID49IDEgJiYgZXhpdENvdW50IDw9IDApXHJcbiAgICAgICAgcmV0dXJuIFswLCAwLjY3XTtcclxuICAgIHJldHVybiBbMC4yNSwgMC43NV07XHJcbn1cblxuZnVuY3Rpb24gU21vb3RoQ29udGFpbmVyKHsgZGltZW5zaW9ucywgY29kZVN0ZXAsIGNoaWxkcmVuLCBtaW5ab29tID0gMCwgbWF4Wm9vbSA9IDEuMiwgY2VudGVyID0gZmFsc2UsIHByb2dyZXNzLCB9KSB7XHJcbiAgICBjb25zdCB7IHByZXYsIG5leHQgfSA9IGdldFR3ZWVuQ29udGVudFByb3BzKHtcclxuICAgICAgICBjb2RlU3RlcCxcclxuICAgICAgICBkaW1lbnNpb25zLFxyXG4gICAgICAgIG1pblpvb20sXHJcbiAgICAgICAgbWF4Wm9vbSxcclxuICAgICAgICBob3Jpem9udGFsQ2VudGVyOiBjZW50ZXIsXHJcbiAgICB9KTtcclxuICAgIC8vIGFsbCB0aGVzZSB0d2VlbnMgZGVwZW5kcyBvbiBhbm5vdGF0aW9ucyBub3cgKHQgaW5zdGVhZCBvZiBwcm9ncmVzcylcclxuICAgIGNvbnN0IHpvb20gPSB0d2VlblByb3AocHJldi56b29tLCBuZXh0Lnpvb20sIHByb2dyZXNzKTtcclxuICAgIGNvbnN0IGR4ID0gdHdlZW5Qcm9wKHByZXYuZHgsIG5leHQuZHgsIHByb2dyZXNzKTtcclxuICAgIGNvbnN0IGR5ID0gdHdlZW5Qcm9wKHByZXYuZHksIG5leHQuZHksIHByb2dyZXNzLCBjb2RlU3RlcC52ZXJ0aWNhbEludGVydmFsKTtcclxuICAgIGNvbnN0IGZvY3VzSGVpZ2h0ID0gdHdlZW5Qcm9wKHByZXYuZm9jdXNIZWlnaHQsIG5leHQuZm9jdXNIZWlnaHQsIHByb2dyZXNzKTtcclxuICAgIGNvbnN0IGZvY3VzV2lkdGggPSB0d2VlblByb3AocHJldi5mb2N1c1dpZHRoLCBuZXh0LmZvY3VzV2lkdGgsIHByb2dyZXNzKTtcclxuICAgIGNvbnN0IGxpbmVOdW1iZXJQYWQgPSAoKGRpbWVuc2lvbnMgPT09IG51bGwgfHwgZGltZW5zaW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGltZW5zaW9ucy5saW5lTnVtYmVyV2lkdGgpIHx8IDApICogem9vbTtcclxuICAgIGNvbnN0IGxlZnRQYWQgPSBsaW5lTnVtYmVyUGFkIHx8IDE2O1xyXG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heChmb2N1c1dpZHRoICsgbGVmdFBhZCwgZGltZW5zaW9ucy5jb250ZW50V2lkdGgpO1xyXG4gICAgY29uc3Qgc3RhcnRYID0gbGVmdFBhZCAvIHpvb207XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGFpbmVyLCB7IHdpZHRoOiBkaW1lbnNpb25zLmNvbnRhaW5lcldpZHRoLCBoZWlnaHQ6IGRpbWVuc2lvbnMuY29udGFpbmVySGVpZ2h0LCBsYW5nOiBjb2RlU3RlcC5sYW5nIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZW50JDEsIHsgZHg6IGR4LCBkeTogZHksIHNjYWxlOiB6b29tLCBoZWlnaHQ6IE1hdGgubWF4KGZvY3VzSGVpZ2h0LCBkaW1lbnNpb25zLmNvbnRlbnRIZWlnaHQpLCB3aWR0aDogd2lkdGggfSwgY2hpbGRyZW4oZm9jdXNXaWR0aCwgc3RhcnRYKSkpKTtcclxufVxyXG5mdW5jdGlvbiBDb250YWluZXIoeyB3aWR0aCwgaGVpZ2h0LCBjaGlsZHJlbiwgbGFuZywgfSkge1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiBcImF1dG9cIixcclxuICAgICAgICB9LCBjbGFzc05hbWU6IFwiY2gtY29kZS1zY3JvbGwtcGFyZW50XCIsIGNoaWxkcmVuOiBjaGlsZHJlbiwgXCJkYXRhLWNoLWxhbmdcIjogbGFuZyB9KSk7XHJcbn1cclxuZnVuY3Rpb24gQ29udGVudCQxKHsgZHgsIGR5LCBzY2FsZSwgaGVpZ2h0LCB3aWR0aCwgY2hpbGRyZW4sIH0pIHtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcInRvcCBsZWZ0XCIsXHJcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxyXG4gICAgICAgIH0sIGNsYXNzTmFtZTogXCJjaC1jb2RlLXNjcm9sbC1jb250ZW50XCIgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2R4fXB4KSB0cmFuc2xhdGVZKCR7ZHl9cHgpIHNjYWxlKCR7c2NhbGV9KWAsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFwibGVmdCB0b3BcIixcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIHNjYWxlLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAoaGVpZ2h0IC0gMiAqIGR5KSAvIHNjYWxlLFxyXG4gICAgICAgICAgICAgICAgLy8gb3V0bGluZTogXCIxcHggc29saWQgeWVsbG93XCIsXHJcbiAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFR3ZWVuQ29udGVudFByb3BzKF9hKSB7XHJcbiAgICB2YXIgeyBjb2RlU3RlcCB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImNvZGVTdGVwXCJdKTtcclxuICAgIGNvbnN0IHsgbGluZUhlaWdodCwgbGluZVdpZHRoIH0gPSByZXN0LmRpbWVuc2lvbnM7XHJcbiAgICBjb25zdCBwYXJhbVR3ZWVuID0ge1xyXG4gICAgICAgIHByZXY6IHtcclxuICAgICAgICAgICAgZXh0cmVtZXM6IFtcclxuICAgICAgICAgICAgICAgIGNvZGVTdGVwLmZpcnN0Rm9jdXNlZExpbmVOdW1iZXIucHJldiAtIDEsXHJcbiAgICAgICAgICAgICAgICBjb2RlU3RlcC5sYXN0Rm9jdXNlZExpbmVOdW1iZXIucHJldiAtIDEsXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIG9yaWdpbmFsQ29udGVudEhlaWdodDogY29kZVN0ZXAubGluZUNvdW50LnByZXYgKiBsaW5lSGVpZ2h0LFxyXG4gICAgICAgICAgICBsaW5lV2lkdGg6IGxpbmVXaWR0aFswXSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHQ6IHtcclxuICAgICAgICAgICAgZXh0cmVtZXM6IFtcclxuICAgICAgICAgICAgICAgIGNvZGVTdGVwLmZpcnN0Rm9jdXNlZExpbmVOdW1iZXIubmV4dCAtIDEsXHJcbiAgICAgICAgICAgICAgICBjb2RlU3RlcC5sYXN0Rm9jdXNlZExpbmVOdW1iZXIubmV4dCAtIDEsXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIG9yaWdpbmFsQ29udGVudEhlaWdodDogY29kZVN0ZXAubGluZUNvdW50Lm5leHQgKiBsaW5lSGVpZ2h0LFxyXG4gICAgICAgICAgICBsaW5lV2lkdGg6IGxpbmVXaWR0aFsxXSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIHJldHVybiBtYXAocGFyYW1Ud2VlbiwgKHsgZXh0cmVtZXMsIG9yaWdpbmFsQ29udGVudEhlaWdodCwgbGluZVdpZHRoIH0pID0+IGdldENvbnRlbnRQcm9wcyhPYmplY3QuYXNzaWduKHsgZXh0cmVtZXMsXHJcbiAgICAgICAgb3JpZ2luYWxDb250ZW50SGVpZ2h0LFxyXG4gICAgICAgIGxpbmVXaWR0aCB9LCByZXN0KSkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbnRlbnRQcm9wcyh7IGRpbWVuc2lvbnMsIGxpbmVXaWR0aCwgbWluWm9vbSwgbWF4Wm9vbSwgZXh0cmVtZXMsIG9yaWdpbmFsQ29udGVudEhlaWdodCwgaG9yaXpvbnRhbENlbnRlciwgfSkge1xyXG4gICAgY29uc3QgeyBsaW5lSGVpZ2h0IH0gPSBkaW1lbnNpb25zO1xyXG4gICAgY29uc3QgY29udGFpbmVySGVpZ2h0ID0gZGltZW5zaW9ucyA9PT0gbnVsbCB8fCBkaW1lbnNpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaW1lbnNpb25zLmNvbnRlbnRIZWlnaHQ7XHJcbiAgICBjb25zdCBjb250YWluZXJXaWR0aCA9IGRpbWVuc2lvbnMgPT09IG51bGwgfHwgZGltZW5zaW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGltZW5zaW9ucy5jb250ZW50V2lkdGg7XHJcbiAgICBjb25zdCBvcmlnaW5hbEZvY3VzSGVpZ2h0ID0gKGV4dHJlbWVzWzFdIC0gZXh0cmVtZXNbMF0gKyAzKSAqIGxpbmVIZWlnaHQ7XHJcbiAgICBjb25zdCBsZWZ0UGFkZGluZyA9IChkaW1lbnNpb25zID09PSBudWxsIHx8IGRpbWVuc2lvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpbWVuc2lvbnMubGluZU51bWJlcldpZHRoKSB8fCAxNjtcclxuICAgIGNvbnN0IHJpZ2h0UGFkZGluZyA9IDE2O1xyXG4gICAgY29uc3Qgem9vbSA9IE1hdGgubWF4KE1hdGgubWluKChjb250YWluZXJXaWR0aCAtIGxlZnRQYWRkaW5nIC0gcmlnaHRQYWRkaW5nKSAvXHJcbiAgICAgICAgbGluZVdpZHRoLCBjb250YWluZXJIZWlnaHQgLyBvcmlnaW5hbEZvY3VzSGVpZ2h0LCBtYXhab29tKSwgbWluWm9vbSk7XHJcbiAgICBjb25zdCBjb250ZW50SGVpZ2h0ID0gb3JpZ2luYWxDb250ZW50SGVpZ2h0ICogem9vbTtcclxuICAgIGNvbnN0IGZvY3VzU3RhcnQgPSAoZXh0cmVtZXNbMF0gLSAxKSAqIGxpbmVIZWlnaHQgKiB6b29tO1xyXG4gICAgY29uc3QgZm9jdXNFbmQgPSAoZXh0cmVtZXNbMV0gKyAyKSAqIGxpbmVIZWlnaHQgKiB6b29tO1xyXG4gICAgY29uc3QgZm9jdXNDZW50ZXIgPSAoZm9jdXNFbmQgKyBmb2N1c1N0YXJ0KSAvIDI7XHJcbiAgICBjb25zdCBmb2N1c0hlaWdodCA9IGZvY3VzRW5kIC0gZm9jdXNTdGFydDtcclxuICAgIGNvbnN0IGR5ID0gY29udGFpbmVySGVpZ2h0ID4gY29udGVudEhlaWdodFxyXG4gICAgICAgID8gKGNvbnRhaW5lckhlaWdodCAtIGNvbnRlbnRIZWlnaHQpIC8gMlxyXG4gICAgICAgIDogY2xhbXAkMShjb250YWluZXJIZWlnaHQgLyAyIC0gZm9jdXNDZW50ZXIsIE1hdGgubWF4KGNvbnRhaW5lckhlaWdodCAtIGNvbnRlbnRIZWlnaHQsIC1mb2N1c1N0YXJ0IC8vIHRvIGVuc3VyZSBmaXJzdCBmb2N1cyBsaW5lIGlzIHNob3duIHdoZW4gZm9jdXMgaXMgYmlnZ2VyIHRoYW4gY29udGFpbmVyXHJcbiAgICAgICAgKSwgMCk7XHJcbiAgICBjb25zdCBkeCA9IGhvcml6b250YWxDZW50ZXJcclxuICAgICAgICA/IE1hdGgubWF4KGNvbnRhaW5lcldpZHRoIC8gMiAtIChsaW5lV2lkdGggKiB6b29tKSAvIDIsIDApXHJcbiAgICAgICAgOiAwO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB6b29tLFxyXG4gICAgICAgIGR4LFxyXG4gICAgICAgIGR5LFxyXG4gICAgICAgIGZvY3VzSGVpZ2h0OiBmb2N1c0hlaWdodCxcclxuICAgICAgICBmb2N1c1dpZHRoOiBsaW5lV2lkdGggKiB6b29tLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjbGFtcCQxKG51bSwgbWluLCBtYXgpIHtcclxuICAgIHJldHVybiBudW0gPD0gbWluID8gbWluIDogbnVtID49IG1heCA/IG1heCA6IG51bTtcclxufVxyXG5mdW5jdGlvbiB0d2VlblByb3Aoc3RhcnQsIGVuZCwgcHJvZ3Jlc3MsIGludGVydmFsID0gWzAsIDFdKSB7XHJcbiAgICByZXR1cm4gdHdlZW4kMSh7XHJcbiAgICAgICAgZml4ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGludGVydmFsLFxyXG4gICAgICAgIGV4dHJlbWVzOiBbc3RhcnQsIGVuZF0sXHJcbiAgICAgICAgZWFzZTogZWFzaW5nLmVhc2VJbk91dEN1YmljLFxyXG4gICAgfSwgcHJvZ3Jlc3MpO1xyXG59XG5cbmZ1bmN0aW9uIFNtb290aExpbmVzKHByb3BzKSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU21vb3RoQ29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIChmb2N1c1dpZHRoLCBzdGFydFgpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KExpbmVzLCB7IGNvZGVTdGVwOiBwcm9wcy5jb2RlU3RlcCwgZm9jdXNXaWR0aDogZm9jdXNXaWR0aCwgbGluZUhlaWdodDogcHJvcHMuZGltZW5zaW9ucy5saW5lSGVpZ2h0LCBwcm9ncmVzczogcHJvcHMucHJvZ3Jlc3MsIHN0YXJ0WDogc3RhcnRYLCBsaW5lTnVtYmVyV2lkdGg6IHByb3BzLmRpbWVuc2lvbnMubGluZU51bWJlcldpZHRoIH0pKSkpO1xyXG59XHJcbmZ1bmN0aW9uIExpbmVzKHsgY29kZVN0ZXAsIHByb2dyZXNzLCBmb2N1c1dpZHRoLCBsaW5lSGVpZ2h0LCBzdGFydFgsIGxpbmVOdW1iZXJXaWR0aCwgfSkge1xyXG4gICAgY29uc3QgZ3JvdXBzID0gcHJvZ3Jlc3MgPCAwLjVcclxuICAgICAgICA/IGNvZGVTdGVwLmdyb3Vwcy5wcmV2XHJcbiAgICAgICAgOiBjb2RlU3RlcC5ncm91cHMubmV4dDtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgZ3JvdXBzLm1hcCgoZ3JvdXAsIGkpID0+IHtcclxuICAgICAgICBpZiAoIWdyb3VwLmFubm90YXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KExpbmVHcm91cCwgeyBsaW5lczogZ3JvdXAubGluZXMsIHQ6IHByb2dyZXNzLCBmb2N1c1dpZHRoOiBmb2N1c1dpZHRoLCBsaW5lSGVpZ2h0OiBsaW5lSGVpZ2h0LCBzdGFydFg6IHN0YXJ0WCwga2V5OiBpLCBsaW5lTnVtYmVyV2lkdGg6IGxpbmVOdW1iZXJXaWR0aCB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YXJ0WSA9IHR3ZWVuJDEoZ3JvdXAubGluZXNbMF0udHdlZW5ZLCBwcm9ncmVzcyk7XHJcbiAgICAgICAgY29uc3QgbGluZUNvdW50ID0gZ3JvdXAuYW5ub3RhdGlvbi5saW5lTnVtYmVycy5lbmQgLVxyXG4gICAgICAgICAgICBncm91cC5hbm5vdGF0aW9uLmxpbmVOdW1iZXJzLnN0YXJ0ICtcclxuICAgICAgICAgICAgMTtcclxuICAgICAgICBjb25zdCBDb21wb25lbnQgPSBncm91cC5hbm5vdGF0aW9uLkNvbXBvbmVudDtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBsaW5lQ291bnQgKiBsaW5lSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWSgke3N0YXJ0WSAqIGxpbmVIZWlnaHR9cHgpYCxcclxuICAgICAgICAgICAgfSwga2V5OiBpLCBkYXRhOiBncm91cC5hbm5vdGF0aW9uLmRhdGEsIGlzSW5saW5lOiBmYWxzZSwgbGluZXM6IGdyb3VwLmxpbmVzIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluZUdyb3VwLCB7IGxpbmVzOiBncm91cC5saW5lcywgdDogcHJvZ3Jlc3MsIGZvY3VzV2lkdGg6IGZvY3VzV2lkdGgsIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHQsIHN0YXJ0WTogc3RhcnRZLCBzdGFydFg6IHN0YXJ0WCwgbGluZU51bWJlcldpZHRoOiBsaW5lTnVtYmVyV2lkdGggfSkpKTtcclxuICAgIH0pKSk7XHJcbn1cclxuZnVuY3Rpb24gTGluZUdyb3VwKHsgbGluZXMsIGZvY3VzV2lkdGgsIGxpbmVIZWlnaHQsIHQsIHN0YXJ0WCwgc3RhcnRZID0gMCwgbGluZU51bWJlcldpZHRoLCB9KSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGxpbmVzLm1hcCgobGluZSwga2V5KSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0d2VlblgsIHR3ZWVuWSwgZm9jdXNlZCB9ID0gbGluZTtcclxuICAgICAgICBjb25zdCBkeCA9IHR3ZWVuJDEodHdlZW5YLCB0KTtcclxuICAgICAgICBjb25zdCBkeSA9IHR3ZWVuJDEodHdlZW5ZLCB0KTtcclxuICAgICAgICBjb25zdCBvcGFjaXR5ID0gZ2V0T3BhY2l0eShmb2N1c2VkLCB0LCBkeCk7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCB7IGtleToga2V5IH0sXHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXJXaWR0aCA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJjaC1jb2RlLWxpbmUtbnVtYmVyXCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtkeCAqIGZvY3VzV2lkdGh9cHgsICR7KGR5IC0gc3RhcnRZKSAqIGxpbmVIZWlnaHR9cHgpYCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbGluZU51bWJlcldpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICB9IH0sIHQgPCAwLjVcclxuICAgICAgICAgICAgICAgID8gbGluZS5saW5lTnVtYmVyLnByZXZcclxuICAgICAgICAgICAgICAgIDogbGluZS5saW5lTnVtYmVyLm5leHQpKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lQ29udGFpbmVyLCB7IGR4OiBzdGFydFggKyBkeCAqIGZvY3VzV2lkdGgsIGR5OiAoZHkgLSBzdGFydFkpICogbGluZUhlaWdodCwgd2lkdGg6IGZvY3VzV2lkdGgsIG9wYWNpdHk6IG9wYWNpdHkgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluZUNvbnRlbnQsIHsgbGluZTogbGluZSwgcHJvZ3Jlc3M6IHQsIGR4OiBkeCB9KSkpKTtcclxuICAgIH0pKSk7XHJcbn1cclxuZnVuY3Rpb24gTGluZUNvbnRlbnQoeyBsaW5lLCBwcm9ncmVzcywgZHgsIH0pIHtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXHJcbiAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcclxuICAgICAgICB9IH0sXHJcbiAgICAgICAgbGluZS5hbm5vdGF0ZWRHcm91cHMubWFwKChhbm5vdGF0ZWRHcm91cCwgaSkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGVkVG9rZW5zLCB7IGFubm90YXRlZEdyb3VwOiBhbm5vdGF0ZWRHcm91cCwgcHJvZ3Jlc3M6IHByb2dyZXNzLCBkeDogZHgsIGtleTogaSB9KSkpLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKSkpO1xyXG59XHJcbmZ1bmN0aW9uIEFubm90YXRlZFRva2Vucyh7IGFubm90YXRlZEdyb3VwLCBwcm9ncmVzcywgZHgsIH0pIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBjb25zdCBhbm5vdGF0ZWQgPSBwcm9ncmVzcyA8IDAuNVxyXG4gICAgICAgID8gYW5ub3RhdGVkR3JvdXAucHJldlxyXG4gICAgICAgIDogYW5ub3RhdGVkR3JvdXAubmV4dDtcclxuICAgIGNvbnN0IHRva2VuR3JvdXBzID0gKGFubm90YXRlZCA9PT0gbnVsbCB8fCBhbm5vdGF0ZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFubm90YXRlZC5ncm91cHMpIHx8IFtdO1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gKF9hID0gYW5ub3RhdGVkID09PSBudWxsIHx8IGFubm90YXRlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5ub3RhdGVkLmFubm90YXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5Db21wb25lbnQ7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRva2VuR3JvdXBzLm1hcCgoZ3JvdXAsIGkpID0+IHtcclxuICAgICAgICBjb25zdCBvcGFjaXR5ID0gZ2V0T3BhY2l0eShncm91cC5mb2N1c2VkLCBwcm9ncmVzcywgZHgpO1xyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBzdHlsZTogeyBvcGFjaXR5IH0sIGtleTogaSArIDEgfSwgZ3JvdXAuZWxlbWVudCkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQ29tcG9uZW50ID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgZGF0YTogKF9iID0gYW5ub3RhdGVkID09PSBudWxsIHx8IGFubm90YXRlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5ub3RhdGVkLmFubm90YXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kYXRhLCBpc0lubGluZTogdHJ1ZSB9KSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pKTtcclxufVxyXG5mdW5jdGlvbiBMaW5lQ29udGFpbmVyKHsgY2hpbGRyZW4sIGR4LCBkeSwgb3BhY2l0eSwgd2lkdGgsIH0pIHtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7ZHh9cHgsICR7ZHl9cHgpYCxcclxuICAgICAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6IG9wYWNpdHkgPD0gMCA/IFwibm9uZVwiIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIH0gfSwgY2hpbGRyZW4pKTtcclxufVxyXG5jb25zdCBPRkZfT1BBQ0lUWSA9IDAuMzM7XHJcbmZ1bmN0aW9uIGdldE9wYWNpdHkoZm9jdXNlZCwgcHJvZ3Jlc3MsIGR4KSB7XHJcbiAgICByZXR1cm4gKHR3ZWVuJDEoe1xyXG4gICAgICAgIGZpeGVkOiBmYWxzZSxcclxuICAgICAgICBleHRyZW1lczogW1xyXG4gICAgICAgICAgICBmb2N1c2VkLnByZXYgPyAwLjk5IDogT0ZGX09QQUNJVFksXHJcbiAgICAgICAgICAgIGZvY3VzZWQubmV4dCA/IDAuOTkgOiBPRkZfT1BBQ0lUWSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIGludGVydmFsOiBbMCwgMV0sXHJcbiAgICB9LCBwcm9ncmVzcykgLVxyXG4gICAgICAgIE1hdGguYWJzKGR4KSAqIDEpO1xyXG59XG5cbmZ1bmN0aW9uIENvcHlCdXR0b24oeyBjb250ZW50LCBzdHlsZSwgY2xhc3NOYW1lLCB9KSB7XHJcbiAgICBjb25zdCBbY29waWVkLCBzZXRDb3BpZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgdGl0bGU6IFwiQ29weSBjb2RlXCIsIGNsYXNzTmFtZTogY2xhc3NOYW1lLCBzdHlsZTogc3R5bGUsIG9uQ2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgY29weVRvQ2xpcGJvYXJkKGNvbnRlbnQpO1xyXG4gICAgICAgICAgICBzZXRDb3BpZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0Q29waWVkKGZhbHNlKTtcclxuICAgICAgICAgICAgfSwgMTIwMCk7XHJcbiAgICAgICAgfSB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIH0sIGNvcGllZCA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgc3Ryb2tlV2lkdGg6IDIsIGQ6IFwiTTUgMTNsNCA0TDE5IDdcIiB9KSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIHN0cm9rZVdpZHRoOiBcIjEuNnB4XCIsIGQ6IFwiTTggMTZINmEyIDIgMCAwMS0yLTJWNmEyIDIgMCAwMTItMmg4YTIgMiAwIDAxMiAydjJtLTYgMTJoOGEyIDIgMCAwMDItMnYtOGEyIDIgMCAwMC0yLTJoLThhMiAyIDAgMDAtMiAydjhhMiAyIDAgMDAyIDJ6XCIgfSkpKSkpO1xyXG59XHJcbmZ1bmN0aW9uIGNvcHlUb0NsaXBib2FyZCh0ZXh0KSB7XHJcbiAgICBpZiAoIW5hdmlnYXRvci5jbGlwYm9hcmQpIHtcclxuICAgICAgICBmYWxsYmFja0NvcHlUZXh0VG9DbGlwYm9hcmQodGV4dCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gZmFsbGJhY2tDb3B5VGV4dFRvQ2xpcGJvYXJkKHRleHQpIHtcclxuICAgIHZhciB0ZXh0QXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcclxuICAgIHRleHRBcmVhLnZhbHVlID0gdGV4dDtcclxuICAgIC8vIEF2b2lkIHNjcm9sbGluZyB0byBib3R0b21cclxuICAgIHRleHRBcmVhLnN0eWxlLnRvcCA9IFwiMFwiO1xyXG4gICAgdGV4dEFyZWEuc3R5bGUubGVmdCA9IFwiMFwiO1xyXG4gICAgdGV4dEFyZWEuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRleHRBcmVhKTtcclxuICAgIHRleHRBcmVhLmZvY3VzKCk7XHJcbiAgICB0ZXh0QXJlYS5zZWxlY3QoKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIHN1Y2Nlc3NmdWwgPSBkb2N1bWVudC5leGVjQ29tbWFuZChcImNvcHlcIik7XHJcbiAgICAgICAgLy8gdmFyIG1zZyA9IHN1Y2Nlc3NmdWwgPyBcInN1Y2Nlc3NmdWxcIiA6IFwidW5zdWNjZXNzZnVsXCJcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkZhbGxiYWNrOiBDb3B5aW5nIHRleHQgY29tbWFuZCB3YXMgXCIgKyBtc2cpXHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcihcIkZhbGxiYWNrOiBPb3BzLCB1bmFibGUgdG8gY29weVwiLCBlcnIpXHJcbiAgICB9XHJcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRleHRBcmVhKTtcclxufVxuXG5mdW5jdGlvbiB1c2VDb2RlU2hpZnQoeyB0d2VlbiwgfSkge1xyXG4gICAgcmV0dXJuIHVzZVN0ZXBQYXJzZXIoe1xyXG4gICAgICAgIGhpZ2hsaWdodGVkTGluZXM6IG1hcCh0d2VlbiwgdHdlZW4gPT4gdHdlZW4uY29kZS5saW5lcyksXHJcbiAgICAgICAgZm9jdXM6IG1hcCh0d2VlbiwgdHdlZW4gPT4gdHdlZW4uZm9jdXMpLFxyXG4gICAgICAgIGFubm90YXRpb25zOiBtYXAodHdlZW4sIHR3ZWVuID0+IHR3ZWVuLmFubm90YXRpb25zKSxcclxuICAgICAgICBsYW5nOiBhbnlWYWx1ZSh0d2VlbiwgdHdlZW4gPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0d2VlbiA9PT0gbnVsbCB8fCB0d2VlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHdlZW4uY29kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhbmc7IH0pLFxyXG4gICAgfSk7XHJcbn1cclxuY29uc3QgREVGQVVMVF9NSU5fQ09MVU1OUyA9IDEwO1xyXG5mdW5jdGlvbiBDb2RlVHdlZW4oX2EpIHtcclxuICAgIHZhciB7IHR3ZWVuLCBwcm9ncmVzcywgY29uZmlnIH0gPSBfYSwgcHJlUHJvcHMgPSBfX3Jlc3QoX2EsIFtcInR3ZWVuXCIsIFwicHJvZ3Jlc3NcIiwgXCJjb25maWdcIl0pO1xyXG4gICAgY29uc3Qgc3RlcEluZm8gPSB1c2VDb2RlU2hpZnQoeyB0d2VlbiB9KTtcclxuICAgIGNvbnN0IHsgZWxlbWVudCwgZGltZW5zaW9ucyB9ID0gdXNlRGltZW5zaW9ucyhzdGVwSW5mby5jb2RlLCBtYXAodHdlZW4sIHR3ZWVuID0+IHR3ZWVuLmZvY3VzKSwgY29uZmlnLm1pbkNvbHVtbnMgfHwgREVGQVVMVF9NSU5fQ09MVU1OUywgY29uZmlnLmxpbmVOdW1iZXJzIHx8IGZhbHNlLCBjb25maWcucm93cywgW2NvbmZpZy5wYXJlbnRIZWlnaHRdKTtcclxuICAgIHJldHVybiAhZGltZW5zaW9ucyB8fCBjb25maWcuZGVidWcgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChCZWZvcmVEaW1lbnNpb25zLCB7IGVsZW1lbnQ6IGVsZW1lbnQsIGh0bWxQcm9wczogcHJlUHJvcHMsIGRlYnVnOiBjb25maWcuZGVidWcgfSkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQWZ0ZXJEaW1lbnNpb25zLCB7IGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsIHN0ZXBJbmZvOiBzdGVwSW5mbywgY29uZmlnOiBjb25maWcsIHByb2dyZXNzOiBwcm9ncmVzcywgaHRtbFByb3BzOiBwcmVQcm9wcyB9KSk7XHJcbn1cclxuZnVuY3Rpb24gQmVmb3JlRGltZW5zaW9ucyh7IGVsZW1lbnQsIGh0bWxQcm9wcywgZGVidWcsIH0pIHtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVyLCB7IGh0bWxQcm9wczogaHRtbFByb3BzLCBtZWFzdXJlZDogZmFsc2UgfSwgZWxlbWVudCkpO1xyXG59XHJcbmZ1bmN0aW9uIEFmdGVyRGltZW5zaW9ucyh7IGNvbmZpZzogeyBtaW5ab29tID0gMSwgbWF4Wm9vbSA9IDEsIGhvcml6b250YWxDZW50ZXIgPSBmYWxzZSwgfSwgZGltZW5zaW9ucywgc3RlcEluZm8sIHByb2dyZXNzLCBodG1sUHJvcHMsIGNvbmZpZywgfSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZXIsIHsgaHRtbFByb3BzOiBodG1sUHJvcHMsIG1lYXN1cmVkOiB0cnVlIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTbW9vdGhMaW5lcywgeyBjb2RlU3RlcDogc3RlcEluZm8sIHByb2dyZXNzOiBwcm9ncmVzcywgZGltZW5zaW9uczogZGltZW5zaW9ucywgXHJcbiAgICAgICAgICAgIC8vIFRPRE8gbW92ZSB0byBkaW1lbnNpb25zP1xyXG4gICAgICAgICAgICBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBjZW50ZXI6IGhvcml6b250YWxDZW50ZXIgfSksXHJcbiAgICAgICAgY29uZmlnLnNob3dDb3B5QnV0dG9uID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29weUJ1dHRvbiwgeyBjbGFzc05hbWU6IFwiY2gtY29kZS1idXR0b25cIiwgY29udGVudDogKF9hID0gc3RlcEluZm8gPT09IG51bGwgfHwgc3RlcEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0ZXBJbmZvLmNvZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmV2IH0pKSA6IHVuZGVmaW5lZCkpO1xyXG59XHJcbmZ1bmN0aW9uIFdyYXBwZXIoeyBodG1sUHJvcHMsIGNoaWxkcmVuLCBtZWFzdXJlZCwgfSkge1xyXG4gICAgcmV0dXJuIChcclxuICAgIC8vIG5vdCB1c2luZyA8cHJlPiBiZWNhdXNlIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlLWhpa2UvY29kZWhpa2UvaXNzdWVzLzEyMFxyXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCBodG1sUHJvcHMsIHsgY2xhc3NOYW1lOiBgY2gtY29kZS13cmFwcGVyICR7KGh0bWxQcm9wcyA9PT0gbnVsbCB8fCBodG1sUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0bWxQcm9wcy5jbGFzc05hbWUpIHx8IFwiXCJ9YCwgXCJkYXRhLWNoLW1lYXN1cmVkXCI6IG1lYXN1cmVkLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpKTtcclxufVxuXG5mdW5jdGlvbiBjdXJyZW50VGltZSgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlU3ByaW5nSW5zdGFuY2UodGFyZ2V0LCBjb25maWcpIHtcbiAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcblxuICBpZiAocmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJlZi5jdXJyZW50ID0ge1xuICAgICAgY29uZmlnOiBnZXRDb25maWdXaXRoRGVmYXVsdHModGFyZ2V0LCBjb25maWcpLFxuICAgICAgc3RhdGU6IGdldEluaXRpYWxTdGF0ZSh0YXJnZXQsIGNvbmZpZylcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuZnVuY3Rpb24gZ2V0Q29uZmlnV2l0aERlZmF1bHRzKHRhcmdldCwgX3JlZikge1xuICB2YXIgc3RpZmZuZXNzID0gX3JlZi5zdGlmZm5lc3MsXG4gICAgICBkYW1waW5nID0gX3JlZi5kYW1waW5nLFxuICAgICAgbWFzcyA9IF9yZWYubWFzcyxcbiAgICAgIGRlY2ltYWxzID0gX3JlZi5kZWNpbWFscyxcbiAgICAgIHRlbGVwb3J0ID0gX3JlZi50ZWxlcG9ydDtcbiAgcmV0dXJuIHtcbiAgICBYOiB0YXJnZXQsXG4gICAgazogc3RpZmZuZXNzICE9PSBudWxsICYmIHN0aWZmbmVzcyAhPT0gdm9pZCAwID8gc3RpZmZuZXNzIDogMTcwLFxuICAgIGM6IGRhbXBpbmcgIT09IG51bGwgJiYgZGFtcGluZyAhPT0gdm9pZCAwID8gZGFtcGluZyA6IDI2LFxuICAgIG06IG1hc3MgIT09IG51bGwgJiYgbWFzcyAhPT0gdm9pZCAwID8gbWFzcyA6IDEsXG4gICAgdGVsZXBvcnQ6IHRlbGVwb3J0ICE9PSBudWxsICYmIHRlbGVwb3J0ICE9PSB2b2lkIDAgPyB0ZWxlcG9ydCA6IGZhbHNlLFxuICAgIGRlY2ltYWxzOiBkZWNpbWFscyAhPT0gbnVsbCAmJiBkZWNpbWFscyAhPT0gdm9pZCAwID8gZGVjaW1hbHMgOiAyXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSh0YXJnZXQsIF9yZWYyKSB7XG4gIHZhciBmcm9tID0gX3JlZjIuZnJvbSxcbiAgICAgIGluaXRpYWxTcGVlZCA9IF9yZWYyLmluaXRpYWxTcGVlZDtcbiAgcmV0dXJuIHtcbiAgICB4MDogZnJvbSAhPT0gbnVsbCAmJiBmcm9tICE9PSB2b2lkIDAgPyBmcm9tIDogdGFyZ2V0LFxuICAgIHYwOiBpbml0aWFsU3BlZWQgIT09IG51bGwgJiYgaW5pdGlhbFNwZWVkICE9PSB2b2lkIDAgPyBpbml0aWFsU3BlZWQgOiAwLFxuICAgIHQwOiBjdXJyZW50VGltZSgpLFxuICAgIHJhZjogbnVsbFxuICB9O1xufVxuXG52YXIgc3FydCA9IE1hdGguc3FydCxcbiAgICBleHAgPSBNYXRoLmV4cCxcbiAgICBzaW4gPSBNYXRoLnNpbixcbiAgICBjb3MgPSBNYXRoLmNvcztcbmZ1bmN0aW9uIHNwcmluZyhfcmVmKSB7XG4gIHZhciB4MCA9IF9yZWYueDAsXG4gICAgICB2MCA9IF9yZWYudjAsXG4gICAgICB0MCA9IF9yZWYudDAsXG4gICAgICB0ID0gX3JlZi50LFxuICAgICAgayA9IF9yZWYuayxcbiAgICAgIGMgPSBfcmVmLmMsXG4gICAgICBtID0gX3JlZi5tLFxuICAgICAgWCA9IF9yZWYuWDtcbiAgdmFyIGR4ID0geDAgLSBYO1xuICB2YXIgZHQgPSAodCAtIHQwKSAvIDEwMDA7XG4gIHZhciByYWRpY2FuZCA9IGMgKiBjIC0gNCAqIGsgKiBtO1xuXG4gIGlmIChyYWRpY2FuZCA+IDApIHtcbiAgICB2YXIgcnAgPSAoLWMgKyBzcXJ0KHJhZGljYW5kKSkgLyAoMiAqIG0pO1xuICAgIHZhciBybiA9ICgtYyAtIHNxcnQocmFkaWNhbmQpKSAvICgyICogbSk7XG4gICAgdmFyIGEgPSAoZHggKiBycCAtIHYwKSAvIChycCAtIHJuKTtcbiAgICB2YXIgYiA9ICh2MCAtIGR4ICogcm4pIC8gKHJwIC0gcm4pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBYICsgYSAqIGV4cChybiAqIGR0KSArIGIgKiBleHAocnAgKiBkdCksXG4gICAgICB2OiBhICogcm4gKiBleHAocm4gKiBkdCkgKyBiICogcnAgKiBleHAocnAgKiBkdClcbiAgICB9O1xuICB9IGVsc2UgaWYgKHJhZGljYW5kIDwgMCkge1xuICAgIHZhciByID0gLWMgLyAoMiAqIG0pO1xuICAgIHZhciBzID0gc3FydCgtcmFkaWNhbmQpIC8gKDIgKiBtKTtcbiAgICB2YXIgX2EgPSBkeDtcblxuICAgIHZhciBfYiA9ICh2MCAtIHIgKiBkeCkgLyBzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IFggKyBleHAociAqIGR0KSAqIChfYSAqIGNvcyhzICogZHQpICsgX2IgKiBzaW4ocyAqIGR0KSksXG4gICAgICB2OiBleHAociAqIGR0KSAqICgoX2IgKiBzICsgX2EgKiByKSAqIGNvcyhzICogZHQpIC0gKF9hICogcyAtIF9iICogcikgKiBzaW4ocyAqIGR0KSlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBfciA9IC1jIC8gKDIgKiBtKTtcblxuICAgIHZhciBfYTIgPSBkeDtcblxuICAgIHZhciBfYjIgPSB2MCAtIF9yICogZHg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogWCArIChfYTIgKyBfYjIgKiBkdCkgKiBleHAoX3IgKiBkdCksXG4gICAgICB2OiAoX2IyICsgX2EyICogX3IgKyBfYjIgKiBfciAqIGR0KSAqIGV4cChfciAqIGR0KVxuICAgIH07XG4gIH1cbn1cblxudmFyIG5leHRGcmFtZVF1ZXVlID0gW107XG52YXIgbmV4dEZyYW1lSWQgPSBudWxsO1xuZnVuY3Rpb24gcXVldWVBbmltYXRpb25GcmFtZShmbikge1xuICB2YXIgbGVuZ3RoID0gbmV4dEZyYW1lUXVldWUucHVzaChmbik7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgIG5leHRGcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJ1blF1ZXVlKTtcbiAgfVxuXG4gIHJldHVybiBbbmV4dEZyYW1lSWQsIGxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gdW5xdWV1ZUFuaW1hdGlvbkZyYW1lKF9yZWYpIHtcbiAgdmFyIGZyYW1lSWQgPSBfcmVmWzBdLFxuICAgICAgaW5kZXggPSBfcmVmWzFdO1xuXG4gIGlmIChmcmFtZUlkID09PSBuZXh0RnJhbWVJZCkge1xuICAgIGRlbGV0ZSBuZXh0RnJhbWVRdWV1ZVtpbmRleF07XG4gIH1cbn1cblxuZnVuY3Rpb24gcnVuUXVldWUoKSB7XG4gIHZhciBub3cgPSBjdXJyZW50VGltZSgpO1xuICB2YXIgcXVldWUgPSBuZXh0RnJhbWVRdWV1ZTtcbiAgbmV4dEZyYW1lUXVldWUgPSBbXTtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICByZXR1cm4gdGFzayAmJiB0YXNrKG5vdyk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG52YXIgdXNlTGF5b3V0RWZmZWN0JDMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuZnVuY3Rpb24gdXNlU3ByaW5nKHRhcmdldCwgY29uZmlnKSB7XG4gIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgIGNvbmZpZyA9IHt9O1xuICB9XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKCksXG4gICAgICBmb3JjZVVwZGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICB2YXIgbmV3Q29uZmlnID0gZ2V0Q29uZmlnV2l0aERlZmF1bHRzKHRhcmdldCwgY29uZmlnKTtcblxuICB2YXIgX3VzZVNwcmluZ0luc3RhbmNlID0gdXNlU3ByaW5nSW5zdGFuY2UodGFyZ2V0LCBjb25maWcpLFxuICAgICAgc3RhdGUgPSBfdXNlU3ByaW5nSW5zdGFuY2Uuc3RhdGUsXG4gICAgICBvbGRDb25maWcgPSBfdXNlU3ByaW5nSW5zdGFuY2UuY29uZmlnOyAvLyBUT0RPIGFsbCBzcHJpbmdzIHNob3VsZCB1c2UgdGhlIHNhbWUgdCBpbiB0aGUgc2FtZSBmcmFtZVxuXG5cbiAgdmFyIHQgPSBjdXJyZW50VGltZSgpO1xuICB2YXIgeDAgPSBzdGF0ZS54MCxcbiAgICAgIHYwID0gc3RhdGUudjAsXG4gICAgICB0MCA9IHN0YXRlLnQwO1xuICB2YXIgayA9IG9sZENvbmZpZy5rLFxuICAgICAgYyA9IG9sZENvbmZpZy5jLFxuICAgICAgbSA9IG9sZENvbmZpZy5tLFxuICAgICAgWCA9IG9sZENvbmZpZy5YO1xuXG4gIHZhciBfcmVmID0gbmV3Q29uZmlnLnRlbGVwb3J0ID8ge1xuICAgIHg6IFgsXG4gICAgdjogMFxuICB9IDogc3ByaW5nKHtcbiAgICB4MDogeDAsXG4gICAgdjA6IHYwLFxuICAgIHQwOiB0MCxcbiAgICB0OiB0LFxuICAgIGs6IGssXG4gICAgYzogYyxcbiAgICBtOiBtLFxuICAgIFg6IFhcbiAgfSksXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgdiA9IF9yZWYudjtcblxuICB2YXIgbW92aW5nID0gaXNNb3ZpbmcoeCwgdiwgdCwgbmV3Q29uZmlnKTtcbiAgdXNlTGF5b3V0RWZmZWN0JDMoZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5hc3NpZ24ob2xkQ29uZmlnLCBuZXdDb25maWcpO1xuICB9LCBbbmV3Q29uZmlnLlgsIG5ld0NvbmZpZy5rLCBuZXdDb25maWcuYywgbmV3Q29uZmlnLm0sIG5ld0NvbmZpZy50ZWxlcG9ydF0pO1xuICB1c2VMYXlvdXRFZmZlY3QkMyhmdW5jdGlvbiAoKSB7XG4gICAgc3RhdGUueDAgPSB4O1xuICAgIHN0YXRlLnYwID0gdjtcbiAgICBzdGF0ZS50MCA9IHQ7XG4gIH0sIFt4LCB2LCB0XSk7XG4gIHVzZUxheW91dEVmZmVjdCQzKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uIGxvb3Aobm93KSB7XG4gICAgICB2YXIgeDAgPSBzdGF0ZS54MCxcbiAgICAgICAgICB2MCA9IHN0YXRlLnYwLFxuICAgICAgICAgIHQwID0gc3RhdGUudDA7XG4gICAgICB2YXIgayA9IG9sZENvbmZpZy5rLFxuICAgICAgICAgIGMgPSBvbGRDb25maWcuYyxcbiAgICAgICAgICBtID0gb2xkQ29uZmlnLm0sXG4gICAgICAgICAgWCA9IG9sZENvbmZpZy5YLFxuICAgICAgICAgIGRlY2ltYWxzID0gb2xkQ29uZmlnLmRlY2ltYWxzO1xuXG4gICAgICB2YXIgX3NwcmluZyA9IHNwcmluZyh7XG4gICAgICAgIHgwOiB4MCxcbiAgICAgICAgdjA6IHYwLFxuICAgICAgICB0MDogdDAsXG4gICAgICAgIHQ6IG5vdyxcbiAgICAgICAgazogayxcbiAgICAgICAgYzogYyxcbiAgICAgICAgbTogbSxcbiAgICAgICAgWDogWFxuICAgICAgfSksXG4gICAgICAgICAgbmV4dFggPSBfc3ByaW5nLng7XG5cbiAgICAgIGlmIChyb3VuZFRvKG5leHRYLCBkZWNpbWFscykgIT09IHJvdW5kVG8oeDAsIGRlY2ltYWxzKSkge1xuICAgICAgICBzdGF0ZS5yYWYgPSBudWxsO1xuICAgICAgICBmb3JjZVVwZGF0ZShub3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmFmID0gcXVldWVBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG1vdmluZyAmJiBzdGF0ZS5yYWYgPT0gbnVsbCkge1xuICAgICAgc3RhdGUucmFmID0gcXVldWVBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICB9IGVsc2UgaWYgKCFtb3ZpbmcgJiYgc3RhdGUucmFmICE9IG51bGwpIHtcbiAgICAgIHVucXVldWVBbmltYXRpb25GcmFtZShzdGF0ZS5yYWYpO1xuICAgICAgc3RhdGUucmFmID0gbnVsbDtcbiAgICB9XG4gIH0pO1xuICB1c2VMYXlvdXRFZmZlY3QkMyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzdGF0ZS5yYWYgIT0gbnVsbCkge1xuICAgICAgICB1bnF1ZXVlQW5pbWF0aW9uRnJhbWUoc3RhdGUucmFmKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBbcm91bmRUbyh4LCBuZXdDb25maWcuZGVjaW1hbHMpLCBtb3ZpbmddO1xufVxuXG5mdW5jdGlvbiBpc01vdmluZyh4LCB2LCB0LCBfcmVmMikge1xuICB2YXIgZGVjaW1hbHMgPSBfcmVmMi5kZWNpbWFscyxcbiAgICAgIFggPSBfcmVmMi5YLFxuICAgICAgayA9IF9yZWYyLmssXG4gICAgICBjID0gX3JlZjIuYyxcbiAgICAgIG0gPSBfcmVmMi5tO1xuXG4gIGlmIChyb3VuZFRvKHgsIGRlY2ltYWxzKSAhPT0gcm91bmRUbyhYLCBkZWNpbWFscykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBuZXh0VCA9IHQgKyAwLjAxNjtcblxuICB2YXIgX3NwcmluZzIgPSBzcHJpbmcoe1xuICAgIHgwOiB4LFxuICAgIHYwOiB2LFxuICAgIHQwOiB0LFxuICAgIHQ6IG5leHRULFxuICAgIGs6IGssXG4gICAgYzogYyxcbiAgICBtOiBtLFxuICAgIFg6IFhcbiAgfSksXG4gICAgICBuZXh0WCA9IF9zcHJpbmcyLng7XG5cbiAgcmV0dXJuIHJvdW5kVG8obmV4dFgsIGRlY2ltYWxzKSAhPT0gcm91bmRUbyhYLCBkZWNpbWFscyk7XG59XG5cbmZ1bmN0aW9uIHJvdW5kVG8oeCwgZGVjaW1hbHMpIHtcbiAgdmFyIHAgPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICByZXR1cm4gTWF0aC5yb3VuZCh4ICogcCkgLyBwO1xufVxuXG5jb25zdCBkZWZhdWx0U3ByaW5nJDEgPSB7XHJcbiAgICBzdGlmZm5lc3M6IDEyMCxcclxuICAgIGRhbXBpbmc6IDI0LFxyXG4gICAgbWFzczogMC4yLFxyXG4gICAgZGVjaW1hbHM6IDMsXHJcbn07XHJcbmZ1bmN0aW9uIENvZGVTcHJpbmcoX2EpIHtcclxuICAgIHZhciB7IHN0ZXAsIGNvbmZpZyB9ID0gX2EsIGh0bWxQcm9wcyA9IF9fcmVzdChfYSwgW1wic3RlcFwiLCBcImNvbmZpZ1wiXSk7XHJcbiAgICBjb25zdCB7IHR3ZWVuLCB0IH0gPSB1c2VTdGVwU3ByaW5nJDEoc3RlcCwgY29uZmlnLnNwcmluZyk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29kZVR3ZWVuLCBPYmplY3QuYXNzaWduKHsgdHdlZW46IHR3ZWVuLCBwcm9ncmVzczogdCwgY29uZmlnOiBjb25maWcgfSwgaHRtbFByb3BzKSkpO1xyXG59XHJcbmZ1bmN0aW9uIHVzZVN0ZXBTcHJpbmckMShzdGVwLCBzcHJpbmdDb25maWcgPSBkZWZhdWx0U3ByaW5nJDEpIHtcclxuICAgIGNvbnN0IFt7IHRhcmdldCwgc3RlcHMsIGluZGV4IH0sIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcclxuICAgICAgICB0YXJnZXQ6IDIsXHJcbiAgICAgICAgc3RlcHM6IFtzdGVwLCBzdGVwLCBzdGVwXSxcclxuICAgICAgICBpbmRleDogMCxcclxuICAgIH0pO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBsYXN0U3RlcCA9IHN0ZXBzW3N0ZXBzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGlmIChsYXN0U3RlcCAhPSBzdGVwKSB7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gdXBkYXRlU3RlcFNwcmluZyQxKHMsIHN0ZXAsIHByb2dyZXNzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3N0ZXBdKTtcclxuICAgIGNvbnN0IFtwcm9ncmVzc10gPSB1c2VTcHJpbmcodGFyZ2V0LCBzcHJpbmdDb25maWcpO1xyXG4gICAgY29uc3QgdHJpb1Byb2dyZXNzID0gcHJvZ3Jlc3MgLSBpbmRleDtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRyaW9Qcm9ncmVzcyA8PSAxXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIHR3ZWVuOiB7IHByZXY6IHN0ZXBzWzBdLCBuZXh0OiBzdGVwc1sxXSB9LFxyXG4gICAgICAgICAgICB0OiB0cmlvUHJvZ3Jlc3MsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIDoge1xyXG4gICAgICAgICAgICB0d2VlbjogeyBwcmV2OiBzdGVwc1sxXSwgbmV4dDogc3RlcHNbMl0gfSxcclxuICAgICAgICAgICAgdDogdHJpb1Byb2dyZXNzIC0gMSxcclxuICAgICAgICB9O1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVTdGVwU3ByaW5nJDEoc3RhdGUsIG5ld1N0ZXAsIHByb2dyZXNzKSB7XHJcbiAgICBjb25zdCB7IHN0ZXBzLCB0YXJnZXQsIGluZGV4IH0gPSBzdGF0ZTtcclxuICAgIGNvbnN0IHN0ZXBzQ2xvbmUgPSBzdGVwcy5zbGljZSgpO1xyXG4gICAgY29uc3QgdHJpb1Byb2dyZXNzID0gcHJvZ3Jlc3MgLSBpbmRleDtcclxuICAgIGlmICh0cmlvUHJvZ3Jlc3MgPCAxKSB7XHJcbiAgICAgICAgc3RlcHNDbG9uZVsyXSA9IG5ld1N0ZXA7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7IHN0ZXBzOiBzdGVwc0Nsb25lIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3RlcHNDbG9uZVswXSA9IHN0ZXBzWzFdO1xyXG4gICAgICAgIHN0ZXBzQ2xvbmVbMV0gPSBzdGVwc1syXTtcclxuICAgICAgICBzdGVwc0Nsb25lWzJdID0gbmV3U3RlcDtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgc3RlcHM6IHN0ZXBzQ2xvbmUsIHRhcmdldDogdGFyZ2V0ICsgMSwgaW5kZXg6IGluZGV4ICsgMSB9KTtcclxuICAgIH1cclxufVxuXG5jb25zdCBNaW5pRnJhbWUgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChfYSwgcmVmKSB7XHJcbiAgICB2YXIgeyB0aXRsZSwgY2hpbGRyZW4sIHRpdGxlQmFyLCB6b29tID0gMSwgb3ZlcmZsb3cgfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1widGl0bGVcIiwgXCJjaGlsZHJlblwiLCBcInRpdGxlQmFyXCIsIFwiem9vbVwiLCBcIm92ZXJmbG93XCJdKTtcclxuICAgIGNvbnN0IGJhciA9IHRpdGxlQmFyIHx8IFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdFRpdGxlQmFyLCB7IHRpdGxlOiB0aXRsZSB9KTtcclxuICAgIGNvbnN0IHpvb21TdHlsZSA9IHtcclxuICAgICAgICBcIi0tY2gtZnJhbWUtem9vbVwiOiB6b29tLFxyXG4gICAgICAgIG92ZXJmbG93LFxyXG4gICAgfTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyByZWY6IHJlZiB9KSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLWZyYW1lXCIgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaC1mcmFtZS10aXRsZS1iYXJcIiB9LCBiYXIpLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLWZyYW1lLWNvbnRlbnRcIiB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaC1mcmFtZS16b29tXCIsIHN0eWxlOiB6b29tU3R5bGUgfSwgY2hpbGRyZW4pKSkpKTtcclxufSk7XHJcblJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKF9hLCByZWYpIHtcclxuICAgIHZhciB7IHRpdGxlLCBjaGlsZHJlbiwgdGl0bGVCYXIsIG92ZXJmbG93IH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcInRpdGxlXCIsIFwiY2hpbGRyZW5cIiwgXCJ0aXRsZUJhclwiLCBcIm92ZXJmbG93XCJdKTtcclxuICAgIGNvbnN0IGJhciA9IHRpdGxlQmFyIHx8IFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdFRpdGxlQmFyLCB7IHRpdGxlOiB0aXRsZSB9KTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyByZWY6IHJlZiB9KSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLXNpbXBsZS1mcmFtZVwiIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY2gtZnJhbWUtdGl0bGUtYmFyXCIgfSwgYmFyKSxcclxuICAgICAgICAgICAgY2hpbGRyZW4pKSk7XHJcbn0pO1xyXG5mdW5jdGlvbiBEZWZhdWx0VGl0bGVCYXIoeyB0aXRsZSB9KSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaC1mcmFtZS1sZWZ0LWJhclwiIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRnJhbWVCdXR0b25zLCBudWxsKSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaC1mcmFtZS1taWRkbGUtYmFyXCIgfSwgdGl0bGUpLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY2gtZnJhbWUtcmlnaHQtYmFyXCIgfSkpKTtcclxufVxyXG5mdW5jdGlvbiBGcmFtZUJ1dHRvbnMoKSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY2gtZnJhbWUtYnV0dG9uc1wiIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaC1mcmFtZS1idXR0b24gY2gtZnJhbWUtYnV0dG9uLWxlZnRcIiB9KSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLWZyYW1lLWJ1dHRvbi1zcGFjZVwiIH0pLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY2gtZnJhbWUtYnV0dG9uIGNoLWZyYW1lLWJ1dHRvbi1taWRkbGVcIiB9KSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLWZyYW1lLWJ1dHRvbi1zcGFjZVwiIH0pLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY2gtZnJhbWUtYnV0dG9uIGNoLWZyYW1lLWJ1dHRvbi1yaWdodFwiIH0pKSk7XHJcbn1cblxuY29uc3QgRWRpdG9yRnJhbWUgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIElubmVyRWRpdG9yRnJhbWUoX2EsIHJlZikge1xyXG4gICAgdmFyIF9iO1xyXG4gICAgdmFyIHsgbm9ydGhQYW5lbCwgc291dGhQYW5lbCwgdGVybWluYWxQYW5lbCwgc3R5bGUsIGhlaWdodCwgbm9ydGhCdXR0b24sIHNvdXRoQnV0dG9uLCBjbGFzc05hbWUsIG9uVGFiQ2xpY2sgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJub3J0aFBhbmVsXCIsIFwic291dGhQYW5lbFwiLCBcInRlcm1pbmFsUGFuZWxcIiwgXCJzdHlsZVwiLCBcImhlaWdodFwiLCBcIm5vcnRoQnV0dG9uXCIsIFwic291dGhCdXR0b25cIiwgXCJjbGFzc05hbWVcIiwgXCJvblRhYkNsaWNrXCJdKTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgcmVmOiByZWYgfSwgcmVzdCwgeyBjbGFzc05hbWU6IFwiY2gtZWRpdG9yLWZyYW1lXCIsIHN0eWxlOiBzdHlsZSB9KSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLWZyYW1lLXRpdGxlLWJhclwiIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGFic0NvbnRhaW5lciwgeyB0YWJzOiBub3J0aFBhbmVsLnRhYnMsIHNob3dGcmFtZUJ1dHRvbnM6IHRydWUsIGJ1dHRvbjogbm9ydGhCdXR0b24sIHBhbmVsOiBcIm5vcnRoXCIsIG9uVGFiQ2xpY2s6IG9uVGFiQ2xpY2sgfSkpLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtY2gtcGFuZWxcIjogXCJub3J0aFwiLCBzdHlsZTogbm9ydGhQYW5lbC5zdHlsZSwgY2hpbGRyZW46IG5vcnRoUGFuZWwuY2hpbGRyZW4gfSksXHJcbiAgICAgICAgc291dGhQYW5lbCAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaC1mcmFtZS10aXRsZS1iYXJcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IChfYiA9IHNvdXRoUGFuZWwuc3R5bGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgICAgICB9IH0sXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRhYnNDb250YWluZXIsIHsgdGFiczogc291dGhQYW5lbC50YWJzLCBzaG93RnJhbWVCdXR0b25zOiBmYWxzZSwgYnV0dG9uOiBzb3V0aEJ1dHRvbiwgdG9wQm9yZGVyOiB0cnVlLCBwYW5lbDogXCJzb3V0aFwiLCBvblRhYkNsaWNrOiBvblRhYkNsaWNrIH0pKSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1jaC1wYW5lbFwiOiBcInNvdXRoXCIsIGNoaWxkcmVuOiBzb3V0aFBhbmVsLmNoaWxkcmVuLCBzdHlsZTogc291dGhQYW5lbC5zdHlsZSB9KSkpKSk7XHJcbn0pO1xyXG5mdW5jdGlvbiBUYWJzQ29udGFpbmVyKHsgdGFicywgYnV0dG9uLCBzaG93RnJhbWVCdXR0b25zLCB0b3BCb3JkZXIsIHBhbmVsLCBvblRhYkNsaWNrLCB9KSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgdG9wQm9yZGVyICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLWVkaXRvci1ncm91cC1ib3JkZXJcIiB9KSksXHJcbiAgICAgICAgc2hvd0ZyYW1lQnV0dG9ucyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoRnJhbWVCdXR0b25zLCBudWxsKSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCksXHJcbiAgICAgICAgdGFicy5tYXAoKHsgdGl0bGUsIGFjdGl2ZSwgc3R5bGUgfSkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IHRpdGxlLCB0aXRsZTogdGl0bGUsIFwiZGF0YS1jaC10YWJcIjogcGFuZWwsIFwiZGF0YS1hY3RpdmVcIjogYWN0aXZlLCBjbGFzc05hbWU6IFwiY2gtZWRpdG9yLXRhYlwiLCBzdHlsZTogc3R5bGUsIG9uQ2xpY2s6IG9uVGFiQ2xpY2sgJiYgKCgpID0+IG9uVGFiQ2xpY2sodGl0bGUpKSB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRhYlRpdGxlLCB7IHRpdGxlOiB0aXRsZSB9KSkpKSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHsgZmxleDogMSwgbWluV2lkdGg6IFwiMC44ZW1cIiB9IH0pLFxyXG4gICAgICAgIGJ1dHRvbikpO1xyXG59XHJcbmZ1bmN0aW9uIFRhYlRpdGxlKHsgdGl0bGUgfSkge1xyXG4gICAgaWYgKCF0aXRsZSkge1xyXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VwYXJhdG9ySW5kZXggPSB0aXRsZS5sYXN0SW5kZXhPZihcIi9cIikgKyAxO1xyXG4gICAgY29uc3QgZmlsZW5hbWUgPSB0aXRsZS5zdWJzdHJpbmcoc2VwYXJhdG9ySW5kZXgpO1xyXG4gICAgY29uc3QgZm9sZGVyID0gdGl0bGUuc3Vic3RyaW5nKDAsIHNlcGFyYXRvckluZGV4KTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgc3R5bGU6IHsgb3BhY2l0eTogMC41IH0gfSwgZm9sZGVyKSxcclxuICAgICAgICBmaWxlbmFtZSkpO1xyXG59XG5cbmZ1bmN0aW9uIGdldENvbW1hbmRzKHRleHQpIHtcclxuICAgIGNvbnN0IFssIC4uLmxpbmVzXSA9IHRleHQuc3BsaXQoL15cXCRcXHMqL2dtKTtcclxuICAgIGNvbnN0IGNvbW1hbmRzID0gbGluZXMubWFwKChjKSA9PiB7XHJcbiAgICAgICAgY29uc3QgW3J1biwgLi4ub3V0cHV0TGluZXNdID0gYy5zcGxpdCgvXFxyP1xcbi8pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJ1bixcclxuICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXRMaW5lcy5sZW5ndGggPiAwID8gb3V0cHV0TGluZXMuam9pbihcIlxcblwiKSA6IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbGFzdENvbW1hbmQgPSBjb21tYW5kc1tjb21tYW5kcy5sZW5ndGggLSAxXTtcclxuICAgIGNvbnN0IGlzUnVubmluZyA9IGNvbW1hbmRzLmxlbmd0aCA+IDAgJiYgbGFzdENvbW1hbmQub3V0cHV0ICE9IG51bGw7XHJcbiAgICBjb25zdCB0aXRsZSA9IGlzUnVubmluZyA/IGxhc3RDb21tYW5kLnJ1bi5zcGxpdCgvKFxccyspLylbMF0gOiBcImJhc2hcIjtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgaXNSdW5uaW5nLFxyXG4gICAgICAgIGNvbW1hbmRzLFxyXG4gICAgfTtcclxufVxuXG5jb25zdCBwcm9tcHQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJjaC10ZXJtaW5hbC1wcm9tcHRcIiB9LCBcIiRcIik7XHJcbmZ1bmN0aW9uIFRlcm1pbmFsQ29udGVudCh7IHRleHQsIHByb2dyZXNzID0gMSwgc3R5bGUsIH0pIHtcclxuICAgIGNvbnN0IGNvbW1hbmRzID0gcGFyc2UodGV4dCwgcHJvZ3Jlc3MpO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIHsgc3R5bGU6IHN0eWxlLCBjbGFzc05hbWU6IFwiY2gtdGVybWluYWwtY29udGVudFwiIH0sIGNvbW1hbmRzLm1hcCgoeyBydW4sIG91dHB1dCB9LCBpKSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgeyBrZXk6IGkgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsXHJcbiAgICAgICAgICAgIHByb21wdCxcclxuICAgICAgICAgICAgXCIgXCIsXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIHJ1bikpLFxyXG4gICAgICAgIG91dHB1dCAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaC10ZXJtaW5hbC1vdXRwdXRcIiB9LCBvdXRwdXQpKSkpKSkpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlKHRleHQsIHByb2dyZXNzKSB7XHJcbiAgICBpZiAoIXRleHQpXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgY29uc3QgY2hhcnMgPSBNYXRoLnJvdW5kKHRleHQubGVuZ3RoICogcHJvZ3Jlc3MpO1xyXG4gICAgY29uc3QgeyBjb21tYW5kcyB9ID0gZ2V0Q29tbWFuZHModGV4dC5zbGljZSgwLCBjaGFycykpO1xyXG4gICAgcmV0dXJuIGNvbW1hbmRzO1xyXG59XG5cbmZ1bmN0aW9uIElubmVyVGVybWluYWxUcmFuc2l0aW9uKHsgcHJldiA9IFwiXCIsIHByZXZLZXksIG5leHQgPSBcIlwiLCBuZXh0S2V5LCBwcm9ncmVzcywgfSkge1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLXRlcm1pbmFsXCIgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVZKC0ke3Byb2dyZXNzICogMTAwfSUpYCxcclxuICAgICAgICAgICAgfSB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRlcm1pbmFsQ29udGVudCwgeyB0ZXh0OiBwcmV2LCBwcm9ncmVzczogMSwga2V5OiBwcmV2S2V5IH0pLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRlcm1pbmFsQ29udGVudCwgeyBzdHlsZTogeyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiIH0sIHRleHQ6IG5leHQsIHByb2dyZXNzOiBwcm9ncmVzcywga2V5OiBuZXh0S2V5IH0pKSkpO1xyXG59XG5cbmZ1bmN0aW9uIElubmVyVGVybWluYWxUcmFuc2l0aW9ucyh7IHN0ZXBzLCBwcm9ncmVzcywgfSkge1xyXG4gICAgY29uc3QgdGV4dFN0ZXBzID0gc3RlcHMubWFwKChzKSA9PiBzLnRleHQpO1xyXG4gICAgY29uc3Qgc3RlcFByb2dyZXNzID0gcHJvZ3Jlc3MgJSAxO1xyXG4gICAgY29uc3QgcHJldkluZGV4ID0gY2xhbXAoTWF0aC5mbG9vcihwcm9ncmVzcyksIDAsIHN0ZXBzLmxlbmd0aCAtIDEpO1xyXG4gICAgY29uc3QgbmV4dEluZGV4ID0gcHJldkluZGV4ICsgMTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChJbm5lclRlcm1pbmFsVHJhbnNpdGlvbiwgeyBwcmV2OiB0ZXh0U3RlcHNbcHJldkluZGV4XSwgcHJldktleTogcHJldkluZGV4LCBuZXh0OiB0ZXh0U3RlcHNbbmV4dEluZGV4XSB8fCBcIlwiLCBuZXh0S2V5OiBuZXh0SW5kZXgsIHByb2dyZXNzOiBzdGVwUHJvZ3Jlc3MgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIGNsYW1wKHgsIG1pbiwgbWF4KSB7XHJcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoeCwgbWluKSwgbWF4KTtcclxufVxuXG5mdW5jdGlvbiBUZXJtaW5hbFBhbmVsKHsgcHJldiwgbmV4dCwgdCwgYmFja3dhcmQsIH0pIHtcclxuICAgIGNvbnN0IGhlaWdodCA9IGdldEhlaWdodCh7IHByZXYsIG5leHQsIHQsIGJhY2t3YXJkIH0pO1xyXG4gICAgcmV0dXJuICFoZWlnaHQgPyBudWxsIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY2gtZWRpdG9yLXRlcm1pbmFsXCIsIHN0eWxlOiB7IGhlaWdodCB9IH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaC1lZGl0b3ItdGVybWluYWwtdGFiXCIgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgXCJUZXJtaW5hbFwiKSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaC1lZGl0b3ItdGVybWluYWwtY29udGVudFwiIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5uZXJUZXJtaW5hbFRyYW5zaXRpb25zLCB7IHN0ZXBzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgeyB0ZXh0OiBwcmV2IHx8IFwiXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICB7IHRleHQ6IG5leHQgfHwgXCJcIiB9LFxyXG4gICAgICAgICAgICAgICAgXSwgcHJvZ3Jlc3M6IHQgfSksXHJcbiAgICAgICAgICAgIFwiKVwiKSkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEhlaWdodCh7IHByZXYsIG5leHQsIHQsIGJhY2t3YXJkLCB9KSB7XHJcbiAgICBpZiAoIXByZXYgJiYgIW5leHQpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICBpZiAoIXByZXYgJiYgbmV4dClcclxuICAgICAgICByZXR1cm4gTUFYX0hFSUdIVCAqIE1hdGgubWluKHQgKiA0LCAxKTtcclxuICAgIGlmIChwcmV2ICYmICFuZXh0KVxyXG4gICAgICAgIHJldHVybiBNQVhfSEVJR0hUICogTWF0aC5tYXgoMSAtIHQgKiA0LCAwKTtcclxuICAgIHJldHVybiBNQVhfSEVJR0hUO1xyXG59XHJcbmNvbnN0IE1BWF9IRUlHSFQgPSAxNTA7XG5cbmZ1bmN0aW9uIG5vcnRoQ29uZmlnKGNvZGVDb25maWcpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvZGVDb25maWcucm93cykpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb2RlQ29uZmlnKSwgeyByb3dzOiBjb2RlQ29uZmlnLnJvd3NbMF0gfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29kZUNvbmZpZztcclxufVxyXG5mdW5jdGlvbiBzb3V0aENvbmZpZyhjb2RlQ29uZmlnKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb2RlQ29uZmlnLnJvd3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29kZUNvbmZpZyksIHsgcm93czogY29kZUNvbmZpZy5yb3dzWzFdIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvZGVDb25maWc7XHJcbn1cclxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbihyZWYsIHByZXYsIG5leHQsIHQsIGJhY2t3YXJkLCBjb2RlQ29uZmlnKSB7XHJcbiAgICAvLyBwcmV2U25hcHNob3QgaGFzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBlZGl0b3IgZm9yIHQ9MFxyXG4gICAgLy8gbmV4dFNuYXBzaG90IGhhcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZWRpdG9yIGZvciB0PTFcclxuICAgIGNvbnN0IHsgcHJldlNuYXBzaG90LCBuZXh0U25hcHNob3QgfSA9IHVzZVNuYXBzaG90cyhyZWYsIHByZXYsIG5leHQpO1xyXG4gICAgLy8gd2UgcmV0dXJuIHRoZSBkZWZhdWx0IHN0eWxlcyBmb3IgdD0wIHVudGlsIHdlIG1lYXN1cmUgdGhlIGRpbWVuc2lvbnNcclxuICAgIGlmICghcHJldlNuYXBzaG90KSB7XHJcbiAgICAgICAgcmV0dXJuIHN0YXJ0aW5nUG9zaXRpb24ocHJldiwgbmV4dCwgY29kZUNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICAvLyBhbmQgdGhlIHNhbWUgZm9yIHQ9MVxyXG4gICAgaWYgKCFuZXh0U25hcHNob3QpIHtcclxuICAgICAgICByZXR1cm4gZW5kaW5nUG9zaXRpb24ocHJldiwgbmV4dCwgY29kZUNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPIHRoaXMgc2hvdWxkIGJlIGNvbW1lbnRlZFxyXG4gICAgLy8gaWYgKHQgPT09IDApIHtcclxuICAgIC8vICAgcmV0dXJuIHN0YXJ0aW5nUG9zaXRpb24ocHJldiwgbmV4dCwgY29kZUNvbmZpZylcclxuICAgIC8vIH1cclxuICAgIGlmICh0ID09PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIGVuZGluZ1Bvc2l0aW9uKHByZXYsIG5leHQsIGNvZGVDb25maWcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5wdXRTb3V0aFBhbmVsID0gcHJldi5zb3V0aFBhbmVsIHx8IG5leHQuc291dGhQYW5lbDtcclxuICAgIGNvbnN0IHsgcHJldk5vcnRoRmlsZSwgcHJldlNvdXRoRmlsZSwgbmV4dE5vcnRoRmlsZSwgbmV4dFNvdXRoRmlsZSwgfSA9IGdldFN0ZXBGaWxlcyhwcmV2LCBuZXh0LCB0ID09IDAgfHwgYmFja3dhcmQpO1xyXG4gICAgY29uc3QgeyBub3J0aFN0eWxlLCBzb3V0aFN0eWxlIH0gPSBnZXRQYW5lbFN0eWxlcyhwcmV2U25hcHNob3QsIG5leHRTbmFwc2hvdCwgdCk7XHJcbiAgICBjb25zdCB7IG5vcnRoVGFicywgc291dGhUYWJzIH0gPSBnZXRUYWJzKHByZXZTbmFwc2hvdCwgbmV4dFNuYXBzaG90LCBwcmV2Tm9ydGhGaWxlLm5hbWUsIHByZXZTb3V0aEZpbGUgPT09IG51bGwgfHwgcHJldlNvdXRoRmlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldlNvdXRoRmlsZS5uYW1lLCB0KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9ydGhDb250ZW50OiBnZXRDb250ZW50RnJvbUZpbGUobmV4dE5vcnRoRmlsZSksXHJcbiAgICAgICAgbm9ydGhQYW5lbDoge1xyXG4gICAgICAgICAgICB0YWJzOiBub3J0aFRhYnMsXHJcbiAgICAgICAgICAgIHN0eWxlOiBub3J0aFN0eWxlLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29kZVRyYW5zaXRpb24sIHsgY29kZUNvbmZpZzogbm9ydGhDb25maWcoY29kZUNvbmZpZyksIHByZXZGaWxlOiBwcmV2Tm9ydGhGaWxlLCBuZXh0RmlsZTogbmV4dE5vcnRoRmlsZSwgdDogdCwgcGFyZW50SGVpZ2h0OiAobm9ydGhTdHlsZS5oZWlnaHQgfHxcclxuICAgICAgICAgICAgICAgICAgICBub3J0aFN0eWxlLm1pbkhlaWdodCkgfSkpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc291dGhDb250ZW50OiBnZXRDb250ZW50RnJvbUZpbGUobmV4dFNvdXRoRmlsZSksXHJcbiAgICAgICAgc291dGhQYW5lbDogaW5wdXRTb3V0aFBhbmVsICYmIHtcclxuICAgICAgICAgICAgdGFiczogc291dGhUYWJzLFxyXG4gICAgICAgICAgICBzdHlsZTogc291dGhTdHlsZSxcclxuICAgICAgICAgICAgY2hpbGRyZW46IChSZWFjdC5jcmVhdGVFbGVtZW50KENvZGVUcmFuc2l0aW9uLCB7IGNvZGVDb25maWc6IHNvdXRoQ29uZmlnKGNvZGVDb25maWcpLCBwcmV2RmlsZTogcHJldlNvdXRoRmlsZSwgbmV4dEZpbGU6IG5leHRTb3V0aEZpbGUsIHQ6IHQsIHBhcmVudEhlaWdodDogKChzb3V0aFN0eWxlID09PSBudWxsIHx8IHNvdXRoU3R5bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXRoU3R5bGUuaGVpZ2h0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChzb3V0aFN0eWxlID09PSBudWxsIHx8IHNvdXRoU3R5bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXRoU3R5bGUubWluSGVpZ2h0KSkgfSkpLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbi8vIFJldHVybnMgdGhlIHQ9MCBzdGF0ZSBvZiB0aGUgdHJhbnNpdGlvblxyXG5mdW5jdGlvbiBzdGFydGluZ1Bvc2l0aW9uKHByZXYsIG5leHQsIGNvZGVDb25maWcpIHtcclxuICAgIGNvbnN0IGlucHV0Tm9ydGhQYW5lbCA9IHByZXYubm9ydGhQYW5lbDtcclxuICAgIGNvbnN0IGlucHV0U291dGhQYW5lbCA9IHByZXYuc291dGhQYW5lbDtcclxuICAgIGNvbnN0IHsgcHJldk5vcnRoRmlsZSwgcHJldlNvdXRoRmlsZSwgbmV4dE5vcnRoRmlsZSwgbmV4dFNvdXRoRmlsZSwgfSA9IGdldFN0ZXBGaWxlcyhwcmV2LCBuZXh0LCB0cnVlKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9ydGhDb250ZW50OiBnZXRDb250ZW50RnJvbUZpbGUocHJldk5vcnRoRmlsZSksXHJcbiAgICAgICAgbm9ydGhQYW5lbDoge1xyXG4gICAgICAgICAgICB0YWJzOiBpbnB1dE5vcnRoUGFuZWwudGFicy5tYXAodGl0bGUgPT4gKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlLFxyXG4gICAgICAgICAgICAgICAgYWN0aXZlOiB0aXRsZSA9PT0gaW5wdXROb3J0aFBhbmVsLmFjdGl2ZSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7fSxcclxuICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmxleEdyb3c6IDEsXHJcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2hpbGRyZW46IChSZWFjdC5jcmVhdGVFbGVtZW50KENvZGVUcmFuc2l0aW9uLCB7IGNvZGVDb25maWc6IG5vcnRoQ29uZmlnKGNvZGVDb25maWcpLCBwcmV2RmlsZTogcHJldk5vcnRoRmlsZSwgbmV4dEZpbGU6IHByZXZOb3J0aEZpbGUsIHQ6IDAsIHBhcmVudEhlaWdodDogXCIwXCIgfSkpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc291dGhDb250ZW50OiBnZXRDb250ZW50RnJvbUZpbGUocHJldlNvdXRoRmlsZSksXHJcbiAgICAgICAgc291dGhQYW5lbDogaW5wdXRTb3V0aFBhbmVsICYmIHtcclxuICAgICAgICAgICAgdGFiczogaW5wdXRTb3V0aFBhbmVsLnRhYnMubWFwKHRpdGxlID0+ICh7XHJcbiAgICAgICAgICAgICAgICB0aXRsZSxcclxuICAgICAgICAgICAgICAgIGFjdGl2ZTogdGl0bGUgPT09IGlucHV0U291dGhQYW5lbC5hY3RpdmUsXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge30sXHJcbiAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZsZXhHcm93OiAxLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb2RlVHJhbnNpdGlvbiwgeyBjb2RlQ29uZmlnOiBzb3V0aENvbmZpZyhjb2RlQ29uZmlnKSwgcHJldkZpbGU6IHByZXZTb3V0aEZpbGUsIG5leHRGaWxlOiBwcmV2U291dGhGaWxlLCB0OiAwLCBwYXJlbnRIZWlnaHQ6IFwiMFwiIH0pKSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG4vLyBSZXR1cm5zIHRoZSB0PTEgc3RhdGUgb2YgdGhlIHRyYW5zaXRpb25cclxuZnVuY3Rpb24gZW5kaW5nUG9zaXRpb24ocHJldiwgbmV4dCwgY29kZUNvbmZpZykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgaW5wdXROb3J0aFBhbmVsID0gbmV4dC5ub3J0aFBhbmVsO1xyXG4gICAgY29uc3QgaW5wdXRTb3V0aFBhbmVsID0gbmV4dC5zb3V0aFBhbmVsO1xyXG4gICAgbGV0IHsgcHJldk5vcnRoRmlsZSwgcHJldlNvdXRoRmlsZSwgbmV4dE5vcnRoRmlsZSwgbmV4dFNvdXRoRmlsZSwgfSA9IGdldFN0ZXBGaWxlcyhwcmV2LCBuZXh0LCBmYWxzZSk7XHJcbiAgICAvLyBnZXRTdGVwRmlsZXMgcmV0dXJuIHRoZSBpbnRlcm1lZGlhdGUgZmlsZXMsIHdlIG5lZWQgdG8gcGF0Y2ggdGhlIGVuZGluZyBzdGF0ZSAoMnRvMXNvdXRoKVxyXG4gICAgY29uc3QgaXNUd29Ub09uZVNvdXRoID0gIWlucHV0U291dGhQYW5lbCAmJlxyXG4gICAgICAgIGlucHV0Tm9ydGhQYW5lbC5hY3RpdmUgPT09ICgoX2EgPSBwcmV2ID09PSBudWxsIHx8IHByZXYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXYuc291dGhQYW5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZSk7XHJcbiAgICBpZiAoaXNUd29Ub09uZVNvdXRoKSB7XHJcbiAgICAgICAgbmV4dE5vcnRoRmlsZSA9IG5leHRTb3V0aEZpbGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5vcnRoQ29udGVudDogZ2V0Q29udGVudEZyb21GaWxlKG5leHROb3J0aEZpbGUpLFxyXG4gICAgICAgIG5vcnRoUGFuZWw6IHtcclxuICAgICAgICAgICAgdGFiczogaW5wdXROb3J0aFBhbmVsLnRhYnMubWFwKHRpdGxlID0+ICh7XHJcbiAgICAgICAgICAgICAgICB0aXRsZSxcclxuICAgICAgICAgICAgICAgIGFjdGl2ZTogdGl0bGUgPT09IGlucHV0Tm9ydGhQYW5lbC5hY3RpdmUsXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge30sXHJcbiAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZsZXhHcm93OiAxLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb2RlVHJhbnNpdGlvbiwgeyBjb2RlQ29uZmlnOiBub3J0aENvbmZpZyhjb2RlQ29uZmlnKSwgcHJldkZpbGU6IG5leHROb3J0aEZpbGUsIG5leHRGaWxlOiBuZXh0Tm9ydGhGaWxlLCB0OiAxLCBwYXJlbnRIZWlnaHQ6IFwiMVwiIH0pKSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNvdXRoQ29udGVudDogZ2V0Q29udGVudEZyb21GaWxlKG5leHRTb3V0aEZpbGUpLFxyXG4gICAgICAgIHNvdXRoUGFuZWw6IGlucHV0U291dGhQYW5lbCAmJiB7XHJcbiAgICAgICAgICAgIHRhYnM6IGlucHV0U291dGhQYW5lbC50YWJzLm1hcCh0aXRsZSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgICAgICAgICBhY3RpdmU6IHRpdGxlID09PSBpbnB1dFNvdXRoUGFuZWwuYWN0aXZlLFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHt9LFxyXG4gICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmbGV4R3JvdzogMSxcclxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29kZVRyYW5zaXRpb24sIHsgY29kZUNvbmZpZzogc291dGhDb25maWcoY29kZUNvbmZpZyksIHByZXZGaWxlOiBuZXh0U291dGhGaWxlLCBuZXh0RmlsZTogbmV4dFNvdXRoRmlsZSwgdDogMSwgcGFyZW50SGVpZ2h0OiBcIjFcIiB9KSksXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gQ29kZVRyYW5zaXRpb24oeyBwcmV2RmlsZSwgbmV4dEZpbGUsIHQsIGNvZGVDb25maWcsIHBhcmVudEhlaWdodCwgfSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgaHRtbFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb2RlQ29uZmlnID09PSBudWxsIHx8IGNvZGVDb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvZGVDb25maWcuaHRtbFByb3BzKSwgeyBzdHlsZTogT2JqZWN0LmFzc2lnbih7IGhlaWdodDogXCIxMDAlXCIgfSwgKF9hID0gY29kZUNvbmZpZyA9PT0gbnVsbCB8fCBjb2RlQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2RlQ29uZmlnLmh0bWxQcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0eWxlKSB9KTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb2RlVHdlZW4sIE9iamVjdC5hc3NpZ24oeyBwcm9ncmVzczogdCwgdHdlZW46IHsgcHJldjogcHJldkZpbGUsIG5leHQ6IG5leHRGaWxlIH0sIGNvbmZpZzogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb2RlQ29uZmlnKSwgeyBwYXJlbnRIZWlnaHQgfSkgfSwgaHRtbFByb3BzKSkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbnRlbnRGcm9tRmlsZShmaWxlKSB7XHJcbiAgICByZXR1cm4gZmlsZSA/IGNvZGVUb1RleHQoZmlsZS5jb2RlKSA6IFwiXCI7XHJcbn1cclxuLyoqXHJcbiAqIEdldCB0aGUgU3RlcEZpbGVzIGZvciBhIHRyYW5zaXRpb25cclxuICogaW4gZWFjaCBwYW5lbCwgaWYgdGhlIHByZXYgYW5kIG5leHQgYWN0aXZlIGZpbGVzIGFyZSB0aGUgc2FtZVxyXG4gKiB3ZSByZXR1cm4gdGhlIHByZXYgYW5kIG5leHQgdmVyc2lvbiBvZiB0aGF0IHBhbmVsXHJcbiAqIGlmIHRoZSBhY3RpdmUgZmlsZXMgYXJlIGRpZmZlcmVudCwgd2UgcmV0dXJuIHRoZSBzYW1lIGZpbGUgdHdpY2UsXHJcbiAqIGlmIGJhY2t3YXJkIGlzIHRydWUgd2UgcmV0dXJuIHRoZSBwcmV2IGFjdGl2ZSBmaWxlIHR3aWNlLFxyXG4gKiBvciBlbHNlIHRoZSBuZXh0IGFjdGl2ZSBmaWxlIHR3aWNlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdGVwRmlsZXMocHJldiwgbmV4dCwgYmFja3dhcmQpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICAvLyBUaGUgYWN0aXZlIGZpbGUgaW4gZWFjaCBwYW5lbCBiZWZvcmUgYW5kIGFmdGVyOlxyXG4gICAgLy8gKy0tLS0rLS0tLStcclxuICAgIC8vIHwgcG4gfCBubiB8XHJcbiAgICAvLyArLS0tLSstLS0tK1xyXG4gICAgLy8gfCBwcyB8IG5zIHxcclxuICAgIC8vICstLS0tKy0tLS0rXHJcbiAgICAvL1xyXG4gICAgY29uc3QgcG4gPSBwcmV2Lm5vcnRoUGFuZWwuYWN0aXZlO1xyXG4gICAgY29uc3Qgbm4gPSBuZXh0Lm5vcnRoUGFuZWwuYWN0aXZlO1xyXG4gICAgY29uc3QgcHMgPSAoX2EgPSBwcmV2LnNvdXRoUGFuZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmU7XHJcbiAgICBjb25zdCBucyA9IChfYiA9IG5leHQuc291dGhQYW5lbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFjdGl2ZTtcclxuICAgIGNvbnN0IHBuRmlsZSA9IHByZXYuZmlsZXMuZmluZChmID0+IGYubmFtZSA9PT0gcG4pO1xyXG4gICAgY29uc3Qgbm5GaWxlID0gbmV4dC5maWxlcy5maW5kKGYgPT4gZi5uYW1lID09PSBubik7XHJcbiAgICBjb25zdCBwc0ZpbGUgPSBwc1xyXG4gICAgICAgID8gcHJldi5maWxlcy5maW5kKGYgPT4gZi5uYW1lID09PSBwcylcclxuICAgICAgICA6IG51bGw7XHJcbiAgICBjb25zdCBuc0ZpbGUgPSBuc1xyXG4gICAgICAgID8gbmV4dC5maWxlcy5maW5kKGYgPT4gZi5uYW1lID09PSBucylcclxuICAgICAgICA6IG51bGw7XHJcbiAgICBjb25zdCBvbmVUb1R3b1NvdXRoID0gIXBzICYmIHBuID09PSBucztcclxuICAgIGlmIChvbmVUb1R3b1NvdXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJldk5vcnRoRmlsZTogbm5GaWxlLFxyXG4gICAgICAgICAgICBuZXh0Tm9ydGhGaWxlOiBubkZpbGUsXHJcbiAgICAgICAgICAgIHByZXZTb3V0aEZpbGU6IHBuRmlsZSxcclxuICAgICAgICAgICAgbmV4dFNvdXRoRmlsZTogbnNGaWxlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCB0d29Ub09uZVNvdXRoID0gIW5zICYmIG5uID09PSBwcztcclxuICAgIGlmICh0d29Ub09uZVNvdXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJldk5vcnRoRmlsZTogcG5GaWxlLFxyXG4gICAgICAgICAgICBuZXh0Tm9ydGhGaWxlOiBwbkZpbGUsXHJcbiAgICAgICAgICAgIHByZXZTb3V0aEZpbGU6IHBzRmlsZSxcclxuICAgICAgICAgICAgbmV4dFNvdXRoRmlsZTogbm5GaWxlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcmV2Tm9ydGhGaWxlID0gcG4gPT09IG5uID8gcG5GaWxlIDogYmFja3dhcmQgPyBwbkZpbGUgOiBubkZpbGU7XHJcbiAgICBjb25zdCBuZXh0Tm9ydGhGaWxlID0gcG4gPT09IG5uID8gbm5GaWxlIDogYmFja3dhcmQgPyBwbkZpbGUgOiBubkZpbGU7XHJcbiAgICBjb25zdCBwcmV2U291dGhGaWxlID0gcHMgPT09IG5zXHJcbiAgICAgICAgPyBwc0ZpbGVcclxuICAgICAgICA6IGJhY2t3YXJkXHJcbiAgICAgICAgICAgID8gcHNGaWxlIHx8IG5zRmlsZVxyXG4gICAgICAgICAgICA6IG5zRmlsZSB8fCBwc0ZpbGU7XHJcbiAgICBjb25zdCBuZXh0U291dGhGaWxlID0gcHMgPT09IG5zXHJcbiAgICAgICAgPyBuc0ZpbGVcclxuICAgICAgICA6IGJhY2t3YXJkXHJcbiAgICAgICAgICAgID8gcHNGaWxlIHx8IG5zRmlsZVxyXG4gICAgICAgICAgICA6IG5zRmlsZSB8fCBwc0ZpbGU7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByZXZOb3J0aEZpbGUsXHJcbiAgICAgICAgbmV4dE5vcnRoRmlsZSxcclxuICAgICAgICBwcmV2U291dGhGaWxlLFxyXG4gICAgICAgIG5leHRTb3V0aEZpbGUsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFBhbmVsU3R5bGVzKHByZXYsIG5leHQsIHQpIHtcclxuICAgIC8vICstLS0rLS0tK1xyXG4gICAgLy8gfCB4IHwgeCB8XHJcbiAgICAvLyArLS0tKy0tLStcclxuICAgIC8vIHwgICB8ICAgfFxyXG4gICAgLy8gKy0tLSstLS0rXHJcbiAgICBpZiAocHJldi5zb3V0aEhlaWdodCA9PT0gbnVsbCAmJlxyXG4gICAgICAgIG5leHQuc291dGhIZWlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBub3J0aFN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQ6IHByZXYubm9ydGhIZWlnaHQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vICstLS0rLS0tK1xyXG4gICAgLy8gfCB4IHwgeCB8XHJcbiAgICAvLyArLS0tKy0tLStcclxuICAgIC8vIHwgeSB8ICAgfFxyXG4gICAgLy8gKy0tLSstLS0rXHJcbiAgICBpZiAocHJldi5zb3V0aEhlaWdodCAhPT0gbnVsbCAmJlxyXG4gICAgICAgIG5leHQuc291dGhIZWlnaHQgPT09IG51bGwgJiZcclxuICAgICAgICBuZXh0Lm5vcnRoS2V5ICE9PSBwcmV2LnNvdXRoS2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbm9ydGhTdHlsZToge1xyXG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0OiB0d2VlbihwcmV2Lm5vcnRoSGVpZ2h0LCBuZXh0Lm5vcnRoSGVpZ2h0LCB0KSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc291dGhTdHlsZToge1xyXG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0OiBwcmV2LnNvdXRoSGVpZ2h0LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyArLS0tKy0tLStcclxuICAgIC8vIHwgeCB8IHkgfFxyXG4gICAgLy8gKy0tLSstLS0rXHJcbiAgICAvLyB8IHkgfCAgIHxcclxuICAgIC8vICstLS0rLS0tK1xyXG4gICAgaWYgKHByZXYuc291dGhIZWlnaHQgIT09IG51bGwgJiZcclxuICAgICAgICBuZXh0LnNvdXRoSGVpZ2h0ID09PSBudWxsICYmXHJcbiAgICAgICAgcHJldi5zb3V0aEtleSA9PT0gbmV4dC5ub3J0aEtleSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5vcnRoU3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG1pbkhlaWdodDogcHJldi5ub3J0aEhlaWdodCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc291dGhTdHlsZToge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcclxuICAgICAgICAgICAgICAgIG1pbkhlaWdodDogdHdlZW4ocHJldi5zb3V0aEhlaWdodCwgbmV4dC5ub3J0aEhlaWdodCwgdCksXHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVZKCR7dHdlZW4oMCwgLShwcmV2Lm5vcnRoSGVpZ2h0ICsgcHJldi50aXRsZUJhckhlaWdodCksIHQpfXB4KWAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vICstLS0rLS0tK1xyXG4gICAgLy8gfCB4IHwgeCB8XHJcbiAgICAvLyArLS0tKy0tLStcclxuICAgIC8vIHwgICB8IHkgfFxyXG4gICAgLy8gKy0tLSstLS0rXHJcbiAgICBpZiAocHJldi5zb3V0aEhlaWdodCA9PT0gbnVsbCAmJlxyXG4gICAgICAgIG5leHQuc291dGhIZWlnaHQgIT09IG51bGwgJiZcclxuICAgICAgICBwcmV2Lm5vcnRoS2V5ICE9PSBuZXh0LnNvdXRoS2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbm9ydGhTdHlsZToge1xyXG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0OiB0d2VlbihwcmV2Lm5vcnRoSGVpZ2h0LCBuZXh0Lm5vcnRoSGVpZ2h0LCB0KSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc291dGhTdHlsZToge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcclxuICAgICAgICAgICAgICAgIG1pbkhlaWdodDogbmV4dC5zb3V0aEhlaWdodCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gKy0tLSstLS0rXHJcbiAgICAvLyB8IHkgfCB4IHxcclxuICAgIC8vICstLS0rLS0tK1xyXG4gICAgLy8gfCAgIHwgeSB8XHJcbiAgICAvLyArLS0tKy0tLStcclxuICAgIGlmIChwcmV2LnNvdXRoSGVpZ2h0ID09PSBudWxsICYmXHJcbiAgICAgICAgbmV4dC5zb3V0aEhlaWdodCAhPT0gbnVsbCAmJlxyXG4gICAgICAgIHByZXYubm9ydGhLZXkgPT09IG5leHQuc291dGhLZXkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBub3J0aFN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQ6IG5leHQubm9ydGhIZWlnaHQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNvdXRoU3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXHJcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQ6IHR3ZWVuKHByZXYubm9ydGhIZWlnaHQsIG5leHQuc291dGhIZWlnaHQsIHQpLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWSgke3R3ZWVuKC0obmV4dC5ub3J0aEhlaWdodCArIG5leHQudGl0bGVCYXJIZWlnaHQpLCAwLCB0KX1weClgLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyArLS0tKy0tLStcclxuICAgIC8vIHwgeCB8IHggfFxyXG4gICAgLy8gKy0tLSstLS0rXHJcbiAgICAvLyB8IHkgfCB5IHxcclxuICAgIC8vICstLS0rLS0tK1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBub3J0aFN0eWxlOiB7XHJcbiAgICAgICAgICAgIG1pbkhlaWdodDogdHdlZW4ocHJldi5ub3J0aEhlaWdodCwgbmV4dC5ub3J0aEhlaWdodCwgdCksXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzb3V0aFN0eWxlOiB7XHJcbiAgICAgICAgICAgIG1pbkhlaWdodDogdHdlZW4ocHJldi5zb3V0aEhlaWdodCwgbmV4dC5zb3V0aEhlaWdodCwgdCksXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdHdlZW4oYSwgYiwgdCkge1xyXG4gICAgcmV0dXJuIGEgKyAoYiAtIGEpICogdDtcclxufVxyXG5mdW5jdGlvbiBnZXRUYWJzKHByZXZTbmFwc2hvdCwgbmV4dFNuYXBzaG90LCBub3J0aEFjdGl2ZSwgc291dGhBY3RpdmUsIHQpIHtcclxuICAgIC8vIFRPRE8gc2ltcGxpZnlcclxuICAgIGlmICghcHJldlNuYXBzaG90LnNvdXRoVGFicyAmJlxyXG4gICAgICAgIGlzUHJlc2VudChzb3V0aEFjdGl2ZSwgcHJldlNuYXBzaG90Lm5vcnRoVGFicykpIHtcclxuICAgICAgICAvLy8gb25lIHRvIHR3byBzb3V0aFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5vcnRoVGFiczogZ2V0UGFuZWxUYWJzKG5leHRTbmFwc2hvdC5ub3J0aFRhYnMsIG5leHRTbmFwc2hvdC5zb3V0aFRhYnMsIHByZXZTbmFwc2hvdC5zb3V0aFRhYnMsIHByZXZTbmFwc2hvdC5ub3J0aFRhYnMsIG5vcnRoQWN0aXZlLCB0KSxcclxuICAgICAgICAgICAgc291dGhUYWJzOiBnZXRQYW5lbFRhYnMobmV4dFNuYXBzaG90LnNvdXRoVGFicywgbmV4dFNuYXBzaG90Lm5vcnRoVGFicywgcHJldlNuYXBzaG90Lm5vcnRoVGFicywgcHJldlNuYXBzaG90LnNvdXRoVGFicywgc291dGhBY3RpdmUsIHQpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoIW5leHRTbmFwc2hvdC5zb3V0aFRhYnMgJiZcclxuICAgICAgICBpc1ByZXNlbnQoc291dGhBY3RpdmUsIG5leHRTbmFwc2hvdC5ub3J0aFRhYnMpKSB7XHJcbiAgICAgICAgLy8vIHR3byB0byBvbmUgc291dGhcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBub3J0aFRhYnM6IGdldFBhbmVsVGFicyhuZXh0U25hcHNob3Quc291dGhUYWJzLCBuZXh0U25hcHNob3Qubm9ydGhUYWJzLCBwcmV2U25hcHNob3Qubm9ydGhUYWJzLCBwcmV2U25hcHNob3Quc291dGhUYWJzLCBub3J0aEFjdGl2ZSwgdCksXHJcbiAgICAgICAgICAgIHNvdXRoVGFiczogZ2V0UGFuZWxUYWJzKG5leHRTbmFwc2hvdC5ub3J0aFRhYnMsIG5leHRTbmFwc2hvdC5zb3V0aFRhYnMsIHByZXZTbmFwc2hvdC5zb3V0aFRhYnMsIHByZXZTbmFwc2hvdC5ub3J0aFRhYnMsIHNvdXRoQWN0aXZlLCB0KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBub3J0aFRhYnM6IGdldFBhbmVsVGFicyhuZXh0U25hcHNob3Qubm9ydGhUYWJzLCBuZXh0U25hcHNob3Quc291dGhUYWJzLCBwcmV2U25hcHNob3Qubm9ydGhUYWJzLCBwcmV2U25hcHNob3Quc291dGhUYWJzLCBub3J0aEFjdGl2ZSwgdCksXHJcbiAgICAgICAgc291dGhUYWJzOiBnZXRQYW5lbFRhYnMobmV4dFNuYXBzaG90LnNvdXRoVGFicywgbmV4dFNuYXBzaG90Lm5vcnRoVGFicywgcHJldlNuYXBzaG90LnNvdXRoVGFicywgcHJldlNuYXBzaG90Lm5vcnRoVGFicywgc291dGhBY3RpdmUsIHQpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRQYW5lbFRhYnMobmV4dFNuYXBzaG90LCBvdGhlck5leHRTbmFwc2hvdCwgcHJldlNuYXBzaG90LCBvdGhlclByZXZTbmFwc2hvdCwgYWN0aXZlLCB0KSB7XHJcbiAgICAvLyBGb3IgZWFjaCB0YWIgYmFyIHRoZXJlIGFyZSBmb3VyIHR5cGVzIG9mIHRhYnNcclxuICAgIC8vIC0gb2xkVGFiczogdGFicyB0aGF0IGFyZSBwcmVzZW50IGluIGJvdGggcHJldiBhbmQgbmV4dCB2ZXJzaW9ucyBvZiB0aGUgYmFyXHJcbiAgICAvLyAtIHRvdGFsbHlOZXdUYWJzOiB0YWJzIHRoYXQgYXJlIHRvdGFsbHkgbmV3IChwcmVzZW50IGluIG5leHRcclxuICAgIC8vIGJ1dCBub3QgaW4gYW55IHByZXYpXHJcbiAgICAvLyAtIG1pZ3JhdGluZ1RhYnM6IHRhYnMgdGhhdCBhcmUgY29tZSBmcm9tIHRoZSBvdGhlciBiYXIgKHByZXNlbnRcclxuICAgIC8vIGluIG5leHQgYW5kIGluIG90aGVyUHJldilcclxuICAgIC8vIC0gZGlzYXBwZWFyaW5nVGFiczogcHJlc2VudCBpbiBwcmV2IGJ1dCBub3QgaW4gbmV4dCBvciBvdGhlck5leHRcclxuICAgIGNvbnN0IG9sZFRhYnMgPSAhbmV4dFNuYXBzaG90XHJcbiAgICAgICAgPyBbXVxyXG4gICAgICAgIDogT2JqZWN0LmtleXMobmV4dFNuYXBzaG90KVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZpbGVuYW1lID0+IGlzUHJlc2VudChmaWxlbmFtZSwgcHJldlNuYXBzaG90KSB8fFxyXG4gICAgICAgICAgICAhcHJldlNuYXBzaG90KVxyXG4gICAgICAgICAgICAubWFwKGZpbGVuYW1lID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJldiA9IHByZXZTbmFwc2hvdCAmJiBwcmV2U25hcHNob3RbZmlsZW5hbWVdO1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV4dFNuYXBzaG90W2ZpbGVuYW1lXTtcclxuICAgICAgICAgICAgY29uc3QgZHggPSBwcmV2XHJcbiAgICAgICAgICAgICAgICA/IHByZXYubGVmdCArIChuZXh0LmxlZnQgLSBwcmV2LmxlZnQpICogdFxyXG4gICAgICAgICAgICAgICAgOiBuZXh0LmxlZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcHJldlxyXG4gICAgICAgICAgICAgICAgPyBwcmV2LndpZHRoICsgKG5leHQud2lkdGggLSBwcmV2LndpZHRoKSAqIHRcclxuICAgICAgICAgICAgICAgIDogbmV4dC53aWR0aDtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZTogZmlsZW5hbWUgPT09IGFjdGl2ZSxcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBmaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7ZHh9cHgpYCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICBjb25zdCB0b3RhbGx5TmV3VGFicyA9ICFuZXh0U25hcHNob3RcclxuICAgICAgICA/IFtdXHJcbiAgICAgICAgOiBPYmplY3Qua2V5cyhuZXh0U25hcHNob3QpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZmlsZW5hbWUgPT4gcHJldlNuYXBzaG90ICYmXHJcbiAgICAgICAgICAgICFpc1ByZXNlbnQoZmlsZW5hbWUsIHByZXZTbmFwc2hvdClcclxuICAgICAgICAvLyAmJiAhaXNQcmVzZW50KGZpbGVuYW1lLCBvdGhlclByZXZTbmFwc2hvdClcclxuICAgICAgICApXHJcbiAgICAgICAgICAgIC5tYXAoZmlsZW5hbWUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV4dFNuYXBzaG90W2ZpbGVuYW1lXTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZTogZmlsZW5hbWUgPT09IGFjdGl2ZSxcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBmaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7bmV4dC5sZWZ0fXB4KWAsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogdCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbmV4dC53aWR0aCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAhbmV4dFNuYXBzaG90XHJcbiAgICAgICAgPyBbXVxyXG4gICAgICAgIDogT2JqZWN0LmtleXMobmV4dFNuYXBzaG90KVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZpbGVuYW1lID0+IGlzUHJlc2VudChmaWxlbmFtZSwgb3RoZXJQcmV2U25hcHNob3QpKVxyXG4gICAgICAgICAgICAubWFwKGZpbGVuYW1lID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJldiA9IG90aGVyUHJldlNuYXBzaG90W2ZpbGVuYW1lXTtcclxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5leHRTbmFwc2hvdFtmaWxlbmFtZV07XHJcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gbmV4dC5sZWZ0IC0gcHJldi5sZWZ0O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlOiBmaWxlbmFtZSA9PT0gYWN0aXZlLFxyXG4gICAgICAgICAgICAgICAgdGl0bGU6IGZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtkeH1weClgLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIGNvbnN0IGRpc2FwcGVhcmluZ1RhYnMgPSAhcHJldlNuYXBzaG90XHJcbiAgICAgICAgPyBbXVxyXG4gICAgICAgIDogT2JqZWN0LmtleXMocHJldlNuYXBzaG90KVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZpbGVuYW1lID0+ICFpc1ByZXNlbnQoZmlsZW5hbWUsIG5leHRTbmFwc2hvdClcclxuICAgICAgICAvLyAmJiAhaXNQcmVzZW50KGZpbGVuYW1lLCBvdGhlck5leHRTbmFwc2hvdClcclxuICAgICAgICApXHJcbiAgICAgICAgICAgIC5tYXAoZmlsZW5hbWUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gcHJldlNuYXBzaG90W2ZpbGVuYW1lXTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZTogZmlsZW5hbWUgPT09IGFjdGl2ZSxcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBmaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxIC0gdCxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7cHJldi5sZWZ0fXB4KWAsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByZXYud2lkdGgsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICAuLi50b3RhbGx5TmV3VGFicyxcclxuICAgICAgICAvLyAuLi5taWdyYXRpbmdUYWJzLFxyXG4gICAgICAgIC4uLm9sZFRhYnMsXHJcbiAgICAgICAgLi4uZGlzYXBwZWFyaW5nVGFicyxcclxuICAgIF07XHJcbn1cclxuZnVuY3Rpb24gaXNQcmVzZW50KGZpbGVuYW1lLCBzbmFwc2hvdCkge1xyXG4gICAgcmV0dXJuIHNuYXBzaG90ICYmIGZpbGVuYW1lICYmIGZpbGVuYW1lIGluIHNuYXBzaG90O1xyXG59XHJcbi8vIHNuYXBzaG90c1xyXG5jb25zdCB1c2VMYXlvdXRFZmZlY3QkMiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcclxuICAgID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0XHJcbiAgICA6IFJlYWN0LnVzZUVmZmVjdDtcclxuZnVuY3Rpb24gdXNlU25hcHNob3RzKHJlZiwgcHJldiwgbmV4dCkge1xyXG4gICAgY29uc3QgW3sgcHJldlNuYXBzaG90LCBuZXh0U25hcHNob3QgfSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xyXG4gICAgICAgIHByZXZTbmFwc2hvdDogbnVsbCxcclxuICAgICAgICBuZXh0U25hcHNob3Q6IG51bGwsXHJcbiAgICB9KTtcclxuICAgIHVzZUxheW91dEVmZmVjdCQyKCgpID0+IHtcclxuICAgICAgICBpZiAocHJldlNuYXBzaG90IHx8IG5leHRTbmFwc2hvdCkge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBwcmV2U25hcHNob3Q6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBuZXh0U25hcHNob3Q6IG51bGwsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtwcmV2LCBuZXh0XSk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QkMigoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFwcmV2U25hcHNob3QpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gcmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcyksIHsgcHJldlNuYXBzaG90OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldFBhbmVsU25hcHNob3QocGFyZW50LCBwcmV2KSksIGdldFRhYnNTbmFwc2hvdChwYXJlbnQsIHByZXYpKSB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghbmV4dFNuYXBzaG90KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHJlZi5jdXJyZW50O1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHMpLCB7IG5leHRTbmFwc2hvdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXRQYW5lbFNuYXBzaG90KHBhcmVudCwgbmV4dCkpLCBnZXRUYWJzU25hcHNob3QocGFyZW50LCBuZXh0KSkgfSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7IHByZXZTbmFwc2hvdCwgbmV4dFNuYXBzaG90IH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGFuZWxTbmFwc2hvdChwYXJlbnQsIHN0ZXApIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IG5vcnRoRWxlbWVudCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtY2gtcGFuZWw9J25vcnRoJ11cIik7XHJcbiAgICBjb25zdCBzb3V0aEVsZW1lbnQgPSBwYXJlbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLWNoLXBhbmVsPSdzb3V0aCddXCIpO1xyXG4gICAgY29uc3QgYmFyID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoXCIuY2gtZnJhbWUtdGl0bGUtYmFyXCIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0aXRsZUJhckhlaWdodDogYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCxcclxuICAgICAgICBub3J0aEhlaWdodDogbm9ydGhFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCxcclxuICAgICAgICBub3J0aEtleTogc3RlcC5ub3J0aFBhbmVsLmFjdGl2ZSxcclxuICAgICAgICBzb3V0aEhlaWdodDogKHNvdXRoRWxlbWVudCA9PT0gbnVsbCB8fCBzb3V0aEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXRoRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpIHx8IG51bGwsXHJcbiAgICAgICAgc291dGhLZXk6IChfYSA9IHN0ZXAuc291dGhQYW5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGFic1NuYXBzaG90KHBhcmVudCwgc3RlcCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3Qgbm9ydGhUYWJzID0gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWNoLXRhYj0nbm9ydGgnXVwiKSk7XHJcbiAgICBjb25zdCBzb3V0aFRhYnMgPSBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtY2gtdGFiPSdzb3V0aCddXCIpKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9ydGhUYWJzOiBnZXRUYWJzRGltZW5zaW9ucyhub3J0aFRhYnMsIHN0ZXAubm9ydGhQYW5lbC5hY3RpdmUpLFxyXG4gICAgICAgIHNvdXRoVGFiczogZ2V0VGFic0RpbWVuc2lvbnMoc291dGhUYWJzLCAoX2EgPSBzdGVwLnNvdXRoUGFuZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmUpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRUYWJzRGltZW5zaW9ucyh0YWJFbGVtZW50cywgYWN0aXZlKSB7XHJcbiAgICBpZiAoIXRhYkVsZW1lbnRzWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJlbnQgPSB0YWJFbGVtZW50c1swXS5wYXJlbnRFbGVtZW50O1xyXG4gICAgY29uc3QgcGFyZW50TGVmdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xyXG4gICAgY29uc3QgZGltZW5zaW9ucyA9IHt9O1xyXG4gICAgdGFiRWxlbWVudHMuZm9yRWFjaChjaGlsZCA9PiB7XHJcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKTtcclxuICAgICAgICBjb25zdCByZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgZGltZW5zaW9uc1tmaWxlbmFtZV0gPSB7XHJcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIHBhcmVudExlZnQsXHJcbiAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxyXG4gICAgICAgICAgICBhY3RpdmU6IGZpbGVuYW1lID09PSBhY3RpdmUsXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRpbWVuc2lvbnM7XHJcbn1cblxuZnVuY3Rpb24gQ29kZUJyb3dzZXIoeyBmaWxlcywgc3RhcnRpbmdGaWxlTmFtZSwgfSkge1xyXG4gICAgY29uc3QgW2FjdGl2ZUZpbGUsIHNldEFjdGl2ZUZpbGVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gZmlsZXMuZmluZChmID0+IGYubmFtZSA9PT0gc3RhcnRpbmdGaWxlTmFtZSkpO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLWNvZGUtYnJvd3NlclwiIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTaWRlYmFyLCB7IGZpbGVzOiBmaWxlcywgYWN0aXZlRmlsZTogYWN0aXZlRmlsZSwgc2V0QWN0aXZlRmlsZTogc2V0QWN0aXZlRmlsZSB9KSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRlbnQsIHsgZmlsZTogYWN0aXZlRmlsZSB9KSkpO1xyXG59XHJcbmZ1bmN0aW9uIFNpZGViYXIoeyBmaWxlcywgYWN0aXZlRmlsZSwgc2V0QWN0aXZlRmlsZSwgfSkge1xyXG4gICAgY29uc3QgdHJlZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gdG9GaWxlVHJlZShmaWxlcyksIFtmaWxlc10pO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLWNvZGUtYnJvd3Nlci1zaWRlYmFyXCIgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFNpZGViYXJOb2RlcywgeyB0cmVlOiB0cmVlLCBhY3RpdmVGaWxlOiBhY3RpdmVGaWxlLCBzZXRBY3RpdmVGaWxlOiBzZXRBY3RpdmVGaWxlIH0pKSk7XHJcbn1cclxuZnVuY3Rpb24gU2lkZWJhck5vZGVzKHsgdHJlZSwgYWN0aXZlRmlsZSwgc2V0QWN0aXZlRmlsZSwgbGV2ZWwgPSAwLCB9KSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHRyZWUubWFwKG5vZGUgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2lkZWJhck5vZGUsIHsga2V5OiBub2RlLm5hbWUsIG5vZGU6IG5vZGUsIGFjdGl2ZUZpbGU6IGFjdGl2ZUZpbGUsIHNldEFjdGl2ZUZpbGU6IHNldEFjdGl2ZUZpbGUsIGxldmVsOiBsZXZlbCB9KSkpKSk7XHJcbn1cclxuZnVuY3Rpb24gU2lkZWJhck5vZGUoeyBub2RlLCBhY3RpdmVGaWxlLCBzZXRBY3RpdmVGaWxlLCBsZXZlbCwgfSkge1xyXG4gICAgY29uc3QgaXNGb2xkZXIgPSBub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMDtcclxuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBub2RlLmNvZGVGaWxlID09PSBhY3RpdmVGaWxlO1xyXG4gICAgaWYgKGlzRm9sZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY2gtY29kZS1icm93c2VyLXNpZGViYXItZm9sZGVyXCIgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogeyBwYWRkaW5nTGVmdDogbGV2ZWwgKiAxLjUgKyBcImNoXCIgfSB9LCBub2RlLm5hbWUpKSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTaWRlYmFyTm9kZXMsIHsgdHJlZTogbm9kZS5jaGlsZHJlbiwgYWN0aXZlRmlsZTogYWN0aXZlRmlsZSwgc2V0QWN0aXZlRmlsZTogc2V0QWN0aXZlRmlsZSwgbGV2ZWw6IGxldmVsICsgMSB9KSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY2gtY29kZS1icm93c2VyLXNpZGViYXItZmlsZVwiLCBcImRhdGEtc2VsZWN0ZWRcIjogaXNTZWxlY3RlZCwgb25DbGljazogKCkgPT4gc2V0QWN0aXZlRmlsZShub2RlLmNvZGVGaWxlKSB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IHBhZGRpbmdMZWZ0OiBsZXZlbCAqIDEuNSArIFwiY2hcIiB9IH0sIG5vZGUubmFtZSkpKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gQ29udGVudCh7IGZpbGUgfSkge1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLWNvZGUtYnJvd3Nlci1jb250ZW50XCIgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENvcHlCdXR0b24sIHsgY2xhc3NOYW1lOiBcImNoLWNvZGUtYnJvd3Nlci1idXR0b25cIiwgY29udGVudDogY29kZVRvVGV4dChmaWxlLmNvZGUpIH0pLFxyXG4gICAgICAgIGZpbGUuY29kZS5saW5lcy5tYXAoKGxpbmUsIGkpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBpIH0sXHJcbiAgICAgICAgICAgIGxpbmUudG9rZW5zLm1hcCgodG9rZW4sIGkpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBPYmplY3QuYXNzaWduKHsga2V5OiBpIH0sIHRva2VuLnByb3BzKSwgdG9rZW4uY29udGVudCkpKSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpKSkpKSk7XHJcbn1cclxuZnVuY3Rpb24gdG9GaWxlVHJlZShmaWxlcykge1xyXG4gICAgbGV0IHRyZWUgPSBbXTtcclxuICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gZmlsZS5uYW1lLnNwbGl0KFwiL1wiKTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRyZWU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdFBhcnQgPSBpID09PSBwYXJ0cy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGN1cnJlbnQuZmluZEluZGV4KGYgPT4gZi5uYW1lID09PSBwYXJ0KTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVGaWxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTGFzdFBhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWIuY29kZUZpbGUgPSBmaWxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudC5wdXNoKHN1Yik7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gc3ViLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbaW5kZXhdLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdHJlZSA9IHNvcnRUcmVlKHRyZWUpO1xyXG4gICAgcmV0dXJuIHRyZWU7XHJcbn1cclxuZnVuY3Rpb24gc29ydFRyZWUodHJlZSkge1xyXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0cmVlKSB7XHJcbiAgICAgICAgY2hpbGQuY2hpbGRyZW4gPSBzb3J0VHJlZShjaGlsZC5jaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJlZS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYUlzRm9sZGVyID0gYS5jaGlsZHJlbiAmJiBhLmNoaWxkcmVuLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgY29uc3QgYklzRm9sZGVyID0gYi5jaGlsZHJlbiAmJiBiLmNoaWxkcmVuLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgaWYgKChhSXNGb2xkZXIgJiYgYklzRm9sZGVyKSB8fFxyXG4gICAgICAgICAgICAoIWFJc0ZvbGRlciAmJiAhYklzRm9sZGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFJc0ZvbGRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfSk7XHJcbn1cblxuZnVuY3Rpb24gRXhwYW5kQnV0dG9uKHsgc3R5bGUsIHN0ZXAsIGNsYXNzTmFtZSwgfSkge1xyXG4gICAgY29uc3QgW2V4cGFuZGVkLCBzZXRFeHBhbmRlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbZGlhbG9nU3VwcG9ydGVkLCBzZXREaWFsb2dTdXBwb3J0ZWRdID0gUmVhY3QudXNlU3RhdGUodHJ1ZSk7XHJcbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCBmaWxlcyA9IHN0ZXAuZmlsZXM7XHJcbiAgICAvLyBjaGVjayBpZiA8ZGlhbG9nIC8+IGlzIHN1cHBvcnRlZFxyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAocmVmLmN1cnJlbnQgJiYgIXJlZi5jdXJyZW50LnNob3dNb2RhbCkge1xyXG4gICAgICAgICAgICBzZXREaWFsb2dTdXBwb3J0ZWQoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuICAgIGlmICghZGlhbG9nU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChFeHBhbmRJY29uLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lLCBzdHlsZTogc3R5bGUsIG9uQ2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50LnNob3dNb2RhbCgpO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiY2gtbm8tc2Nyb2xsXCIpO1xyXG4gICAgICAgICAgICAgICAgc2V0RXhwYW5kZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0gfSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpYWxvZ1wiLCB7IHJlZjogcmVmLCBjbGFzc05hbWU6IFwiY2gtZXhwYW5kLWRpYWxvZ1wiLCBvbkNsb3NlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXRFeHBhbmRlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIH0sIG9uQ2xpY2s6IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuY3VycmVudFRhcmdldCA9PT0gZS50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWYuY3VycmVudC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImNoLW5vLXNjcm9sbFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENsb3NlQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZWYuY3VycmVudC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImNoLW5vLXNjcm9sbFwiKTtcclxuICAgICAgICAgICAgICAgIH0gfSksXHJcbiAgICAgICAgICAgIGV4cGFuZGVkID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY2gtZXhwYW5kLWRpYWxvZy1jb250ZW50XCIgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29kZUJyb3dzZXIsIHsgZmlsZXM6IGZpbGVzLCBzdGFydGluZ0ZpbGVOYW1lOiBzdGVwLm5vcnRoUGFuZWwuYWN0aXZlIH0pKSkgOiB1bmRlZmluZWQpKSk7XHJcbn1cclxuZnVuY3Rpb24gRXhwYW5kSWNvbih7IG9uQ2xpY2ssIHN0eWxlLCBjbGFzc05hbWUsIH0pIHtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIHRpdGxlOiBcIkV4cGFuZFwiLCBzdHlsZTogc3R5bGUsIG9uQ2xpY2s6IG9uQ2xpY2ssIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIHN0cm9rZVdpZHRoOiAyLCBkOiBcIk00IDhWNG0wIDBoNE00IDRsNSA1bTExLTFWNG0wIDBoLTRtNCAwbC01IDVNNCAxNnY0bTAgMGg0bS00IDBsNS01bTExIDVsLTUtNW01IDV2LTRtMCA0aC00XCIgfSkpKSk7XHJcbn1cclxuZnVuY3Rpb24gQ2xvc2VCdXR0b24oeyBvbkNsaWNrIH0pIHtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IG9uQ2xpY2s6IG9uQ2xpY2ssIGNsYXNzTmFtZTogXCJjaC1leHBhbmQtY2xvc2VcIiwgdHlwZTogXCJidXR0b25cIiwgdGl0bGU6IFwiQ2xvc2VcIiB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBzdHJva2VXaWR0aDogMiwgZDogXCJNNiAxOEwxOCA2TTYgNmwxMiAxMlwiIH0pKSkpO1xyXG59XG5cbmNvbnN0IERFRkFVTFRfU1RFUCA9IHtcclxuICAgIGZpbGVzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb2RlOiB7IGxpbmVzOiBbXSwgbGFuZzogXCJqc1wiIH0sXHJcbiAgICAgICAgICAgIGZvY3VzOiBcIlwiLFxyXG4gICAgICAgICAgICBuYW1lOiBcIlwiLFxyXG4gICAgICAgIH0sXHJcbiAgICBdLFxyXG4gICAgbm9ydGhQYW5lbDogeyBhY3RpdmU6IFwiXCIsIHRhYnM6IFtcIlwiXSwgaGVpZ2h0UmF0aW86IDEgfSxcclxufTtcclxuZnVuY3Rpb24gRWRpdG9yVHdlZW4oX2EpIHtcclxuICAgIHZhciB7IHByZXYgPSBERUZBVUxUX1NURVAsIG5leHQsIHQsIGJhY2t3YXJkLCBjb2RlQ29uZmlnLCBmcmFtZVByb3BzID0ge30gfSA9IF9hLCBkaXZQcm9wcyA9IF9fcmVzdChfYSwgW1wicHJldlwiLCBcIm5leHRcIiwgXCJ0XCIsIFwiYmFja3dhcmRcIiwgXCJjb2RlQ29uZmlnXCIsIFwiZnJhbWVQcm9wc1wiXSk7XHJcbiAgICBjb25zdCByZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcclxuICAgIGNvbnN0IHsgc2hvd0NvcHlCdXR0b24sIHNob3dFeHBhbmRCdXR0b24gfSA9IGNvZGVDb25maWcsIGNvbmZpZyA9IF9fcmVzdChjb2RlQ29uZmlnLCBbXCJzaG93Q29weUJ1dHRvblwiLCBcInNob3dFeHBhbmRCdXR0b25cIl0pO1xyXG4gICAgY29uc3QgeyBub3J0aFBhbmVsLCBzb3V0aFBhbmVsLCBub3J0aENvbnRlbnQsIHNvdXRoQ29udGVudCwgfSA9IHVzZVRyYW5zaXRpb24ocmVmLCBwcmV2LCBuZXh0IHx8IHByZXYsIHQsIGJhY2t3YXJkLCBjb25maWcpO1xyXG4gICAgY29uc3QgW2Zyb3plbkhlaWdodCwgZnJlZXplSGVpZ2h0XSA9IFJlYWN0LnVzZVN0YXRlKHVuZGVmaW5lZCk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QkNCgoKSA9PiB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IChfYSA9IHJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xyXG4gICAgICAgIGZyZWV6ZUhlaWdodChoZWlnaHQpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3QgZnJhbWVQcm9wc1dpdGhIZWlnaHQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZnJhbWVQcm9wcyksIGRpdlByb3BzKSwgeyBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmcmFtZVByb3BzID09PSBudWxsIHx8IGZyYW1lUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZyYW1lUHJvcHMuc3R5bGUpLCBkaXZQcm9wcyA9PT0gbnVsbCB8fCBkaXZQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGl2UHJvcHMuc3R5bGUpIH0pO1xyXG4gICAgaWYgKGZyb3plbkhlaWdodCkge1xyXG4gICAgICAgIGZyYW1lUHJvcHNXaXRoSGVpZ2h0LnN0eWxlLmhlaWdodCA9IGZyb3plbkhlaWdodDtcclxuICAgICAgICBmcmFtZVByb3BzV2l0aEhlaWdodC5zdHlsZS5tYXhIZWlnaHQgPSBmcm96ZW5IZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBub3J0aEJ1dHRvbnMgPSAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBzaG93Q29weUJ1dHRvbiA/IChSZWFjdC5jcmVhdGVFbGVtZW50KENvcHlCdXR0b24sIHsgY2xhc3NOYW1lOiBcImNoLWVkaXRvci1idXR0b25cIiwgY29udGVudDogbm9ydGhDb250ZW50IH0pKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICBzaG93RXhwYW5kQnV0dG9uID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRXhwYW5kQnV0dG9uLCB7IGNsYXNzTmFtZTogXCJjaC1lZGl0b3ItYnV0dG9uXCIsIHN0ZXA6IG5leHQgfHwgcHJldiB9KSkgOiB1bmRlZmluZWQpKTtcclxuICAgIGNvbnN0IHNvdXRoQ29weUJ1dHRvbiA9IHNob3dDb3B5QnV0dG9uID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29weUJ1dHRvbiwgeyBjbGFzc05hbWU6IFwiY2gtZWRpdG9yLWJ1dHRvblwiLCBjb250ZW50OiBzb3V0aENvbnRlbnQgfSkpIDogdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgdGVybWluYWxQYW5lbCA9IChSZWFjdC5jcmVhdGVFbGVtZW50KFRlcm1pbmFsUGFuZWwsIHsgcHJldjogcHJldi50ZXJtaW5hbCwgbmV4dDogKG5leHQgfHwgcHJldikudGVybWluYWwsIHQ6IHQsIGJhY2t3YXJkOiBiYWNrd2FyZCB9KSk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRpdG9yRnJhbWUsIE9iamVjdC5hc3NpZ24oeyByZWY6IHJlZiB9LCBmcmFtZVByb3BzV2l0aEhlaWdodCwgeyBub3J0aFBhbmVsOiBub3J0aFBhbmVsLCBzb3V0aFBhbmVsOiBzb3V0aFBhbmVsLCB0ZXJtaW5hbFBhbmVsOiB0ZXJtaW5hbFBhbmVsLCBub3J0aEJ1dHRvbjogbm9ydGhCdXR0b25zLCBzb3V0aEJ1dHRvbjogc291dGhDb3B5QnV0dG9uIH0pKSk7XHJcbn1cblxuY29uc3QgZGVmYXVsdFNwcmluZyA9IHtcclxuICAgIHN0aWZmbmVzczogMTIwLFxyXG4gICAgZGFtcGluZzogMjQsXHJcbiAgICBtYXNzOiAwLjIsXHJcbiAgICBkZWNpbWFsczogMyxcclxufTtcclxuZnVuY3Rpb24gRWRpdG9yU3ByaW5nKF9hKSB7XHJcbiAgICB2YXIgeyBub3J0aFBhbmVsLCBzb3V0aFBhbmVsLCBmaWxlcywgdGVybWluYWwsIHNwcmluZ0NvbmZpZyB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJub3J0aFBhbmVsXCIsIFwic291dGhQYW5lbFwiLCBcImZpbGVzXCIsIFwidGVybWluYWxcIiwgXCJzcHJpbmdDb25maWdcIl0pO1xyXG4gICAgY29uc3Qgc3RlcCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5vcnRoUGFuZWwsXHJcbiAgICAgICAgICAgIHNvdXRoUGFuZWwsXHJcbiAgICAgICAgICAgIGZpbGVzLFxyXG4gICAgICAgICAgICB0ZXJtaW5hbCxcclxuICAgICAgICB9O1xyXG4gICAgfSwgW25vcnRoUGFuZWwsIHNvdXRoUGFuZWwsIGZpbGVzLCB0ZXJtaW5hbF0pO1xyXG4gICAgY29uc3QgeyBwcmV2LCBuZXh0LCB0IH0gPSB1c2VTdGVwU3ByaW5nKHN0ZXAsIHNwcmluZ0NvbmZpZyk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRpdG9yVHdlZW4sIE9iamVjdC5hc3NpZ24oeyB0OiB0LCBiYWNrd2FyZDogZmFsc2UsIHByZXY6IHByZXYsIG5leHQ6IG5leHQgfSwgcHJvcHMpKSk7XHJcbn1cclxuZnVuY3Rpb24gdXNlU3RlcFNwcmluZyhzdGVwLCBzcHJpbmdDb25maWcgPSBkZWZhdWx0U3ByaW5nKSB7XHJcbiAgICBjb25zdCBbeyB0YXJnZXQsIHN0ZXBzLCBpbmRleCB9LCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XHJcbiAgICAgICAgdGFyZ2V0OiAyLFxyXG4gICAgICAgIHN0ZXBzOiBbc3RlcCwgc3RlcCwgc3RlcF0sXHJcbiAgICAgICAgaW5kZXg6IDAsXHJcbiAgICB9KTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbGFzdFN0ZXAgPSBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXTtcclxuICAgICAgICBpZiAobGFzdFN0ZXAgIT0gc3RlcCkge1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzID0+IHVwZGF0ZVN0ZXBTcHJpbmcocywgc3RlcCwgcHJvZ3Jlc3MpKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbc3RlcF0pO1xyXG4gICAgY29uc3QgW3Byb2dyZXNzXSA9IHVzZVNwcmluZyh0YXJnZXQsIHNwcmluZ0NvbmZpZyk7XHJcbiAgICBjb25zdCB0cmlvUHJvZ3Jlc3MgPSBwcm9ncmVzcyAtIGluZGV4O1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdHJpb1Byb2dyZXNzIDw9IDFcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgcHJldjogc3RlcHNbMF0sXHJcbiAgICAgICAgICAgIG5leHQ6IHN0ZXBzWzFdLFxyXG4gICAgICAgICAgICB0OiB0cmlvUHJvZ3Jlc3MsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIDoge1xyXG4gICAgICAgICAgICBwcmV2OiBzdGVwc1sxXSxcclxuICAgICAgICAgICAgbmV4dDogc3RlcHNbMl0sXHJcbiAgICAgICAgICAgIHQ6IHRyaW9Qcm9ncmVzcyAtIDEsXHJcbiAgICAgICAgfTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlU3RlcFNwcmluZyhzdGF0ZSwgbmV3U3RlcCwgcHJvZ3Jlc3MpIHtcclxuICAgIGNvbnN0IHsgc3RlcHMsIHRhcmdldCwgaW5kZXggfSA9IHN0YXRlO1xyXG4gICAgY29uc3Qgc3RlcHNDbG9uZSA9IHN0ZXBzLnNsaWNlKCk7XHJcbiAgICBjb25zdCB0cmlvUHJvZ3Jlc3MgPSBwcm9ncmVzcyAtIGluZGV4O1xyXG4gICAgaWYgKHRyaW9Qcm9ncmVzcyA8IDEpIHtcclxuICAgICAgICBzdGVwc0Nsb25lWzJdID0gbmV3U3RlcDtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgc3RlcHM6IHN0ZXBzQ2xvbmUgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzdGVwc0Nsb25lWzBdID0gc3RlcHNbMV07XHJcbiAgICAgICAgc3RlcHNDbG9uZVsxXSA9IHN0ZXBzWzJdO1xyXG4gICAgICAgIHN0ZXBzQ2xvbmVbMl0gPSBuZXdTdGVwO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgeyBzdGVwczogc3RlcHNDbG9uZSwgdGFyZ2V0OiB0YXJnZXQgKyAxLCBpbmRleDogaW5kZXggKyAxIH0pO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIENvZGUocHJvcHMpIHtcclxuICAgIGNvbnN0IFtzdGVwLCBzZXRTdGVwXSA9IFJlYWN0LnVzZVN0YXRlKHByb3BzKTtcclxuICAgIGZ1bmN0aW9uIG9uVGFiQ2xpY2soZmlsZW5hbWUpIHtcclxuICAgICAgICBjb25zdCBuZXdTdGVwID0gdXBkYXRlRWRpdG9yU3RlcChzdGVwLCBmaWxlbmFtZSwgbnVsbCk7XHJcbiAgICAgICAgc2V0U3RlcChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXApLCBuZXdTdGVwKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJbm5lckNvZGUsIE9iamVjdC5hc3NpZ24oe30sIHN0ZXAsIHsgb25UYWJDbGljazogb25UYWJDbGljayB9KSk7XHJcbn1cclxuLy8gYnVpbGQgdGhlIENvZGVDb25maWcgZnJvbSBwcm9wcyBhbmQgcHJvcHMuY29kZUNvbmZpZ1xyXG5mdW5jdGlvbiBtZXJnZUNvZGVDb25maWcocHJvcHMpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xyXG4gICAgY29uc3QgeyBsaW5lTnVtYmVycywgc2hvd0NvcHlCdXR0b24sIHNob3dFeHBhbmRCdXR0b24sIG1pblpvb20sIG1heFpvb20gfSA9IHByb3BzLCByZXN0ID0gX19yZXN0KHByb3BzLCBbXCJsaW5lTnVtYmVyc1wiLCBcInNob3dDb3B5QnV0dG9uXCIsIFwic2hvd0V4cGFuZEJ1dHRvblwiLCBcIm1pblpvb21cIiwgXCJtYXhab29tXCJdKTtcclxuICAgIGNvbnN0IGNvZGVDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzLmNvZGVDb25maWcpLCB7IG1heFpvb206IG1heFpvb20gPT0gbnVsbCA/IChfYSA9IHByb3BzLmNvZGVDb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXhab29tIDogbWF4Wm9vbSwgbWluWm9vbTogbWluWm9vbSA9PSBudWxsID8gKF9iID0gcHJvcHMuY29kZUNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1pblpvb20gOiBtaW5ab29tLCBob3Jpem9udGFsQ2VudGVyOiAoX2QgPSAoX2MgPSBwcm9wcy5jb2RlQ29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaG9yaXpvbnRhbENlbnRlcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogcHJvcHMuaG9yaXpvbnRhbENlbnRlciwgbGluZU51bWJlcnM6IGxpbmVOdW1iZXJzID09IG51bGxcclxuICAgICAgICAgICAgPyAoX2UgPSBwcm9wcy5jb2RlQ29uZmlnKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UubGluZU51bWJlcnNcclxuICAgICAgICAgICAgOiBsaW5lTnVtYmVycywgc2hvd0NvcHlCdXR0b246IHNob3dDb3B5QnV0dG9uID09IG51bGxcclxuICAgICAgICAgICAgPyAoX2YgPSBwcm9wcy5jb2RlQ29uZmlnKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc2hvd0NvcHlCdXR0b25cclxuICAgICAgICAgICAgOiBzaG93Q29weUJ1dHRvbiwgc2hvd0V4cGFuZEJ1dHRvbjogc2hvd0V4cGFuZEJ1dHRvbiA9PSBudWxsXHJcbiAgICAgICAgICAgID8gKF9nID0gcHJvcHMuY29kZUNvbmZpZykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnNob3dFeHBhbmRCdXR0b25cclxuICAgICAgICAgICAgOiBzaG93RXhwYW5kQnV0dG9uLCByb3dzOiBwcm9wcy5yb3dzLCBkZWJ1ZzogKF9oID0gcHJvcHMuZGVidWcpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IChfaiA9IHByb3BzLmNvZGVDb25maWcpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5kZWJ1ZyB9KTtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCB7IGNvZGVDb25maWcgfSk7XHJcbn1cclxuZnVuY3Rpb24gSW5uZXJDb2RlKF9hKSB7XHJcbiAgICB2YXIgX2IsIF9jO1xyXG4gICAgdmFyIHsgb25UYWJDbGljayB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJvblRhYkNsaWNrXCJdKTtcclxuICAgIGNvbnN0IF9kID0gbWVyZ2VDb2RlQ29uZmlnKHByb3BzKSwgeyBjbGFzc05hbWUsIHN0eWxlLCBjb2RlQ29uZmlnIH0gPSBfZCwgZWRpdG9yUHJvcHMgPSBfX3Jlc3QoX2QsIFtcImNsYXNzTmFtZVwiLCBcInN0eWxlXCIsIFwiY29kZUNvbmZpZ1wiXSk7XHJcbiAgICBpZiAoIXByb3BzLnNvdXRoUGFuZWwgJiZcclxuICAgICAgICBwcm9wcy5maWxlcy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAhcHJvcHMuZmlsZXNbMF0ubmFtZSkge1xyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogYGNoLWNvZGVibG9jayBub3QtcHJvc2UgJHtjbGFzc05hbWUgfHwgXCJcIn1gLCBcImRhdGEtY2gtdGhlbWVcIjogKF9iID0gcHJvcHMuY29kZUNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRoZW1lTmFtZSwgc3R5bGU6IHN0eWxlIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29kZVNwcmluZywgeyBjbGFzc05hbWU6IFwiY2gtY29kZVwiLCBjb25maWc6IGNvZGVDb25maWcsIHN0ZXA6IGVkaXRvclByb3BzLmZpbGVzWzBdIH0pKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBmcmFtZVByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlZGl0b3JQcm9wcyA9PT0gbnVsbCB8fCBlZGl0b3JQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRpdG9yUHJvcHMuZnJhbWVQcm9wcyksIHsgb25UYWJDbGljayB9KTtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGBjaC1jb2RlZ3JvdXAgbm90LXByb3NlICR7Y2xhc3NOYW1lIHx8IFwiXCJ9YCwgXCJkYXRhLWNoLXRoZW1lXCI6IChfYyA9IHByb3BzLmNvZGVDb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50aGVtZU5hbWUsIHN0eWxlOiBzdHlsZSB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvclNwcmluZywgT2JqZWN0LmFzc2lnbih7fSwgZWRpdG9yUHJvcHMsIHsgZnJhbWVQcm9wczogZnJhbWVQcm9wcywgY29kZUNvbmZpZzogY29kZUNvbmZpZyB9KSkpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB1cGRhdGVFZGl0b3JTdGVwKHN0ZXAsIGZpbGVuYW1lLCBmb2N1cykge1xyXG4gICAgY29uc3QgbmFtZSA9IGZpbGVuYW1lIHx8IHN0ZXAubm9ydGhQYW5lbC5hY3RpdmU7XHJcbiAgICBjb25zdCBuZXdGaWxlcyA9IHN0ZXAuZmlsZXMubWFwKChmaWxlKSA9PiBmaWxlLm5hbWUgPT09IG5hbWVcclxuICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmlsZSksIHsgZm9jdXM6IGZvY3VzID09PSBudWxsID8gZmlsZS5mb2N1cyA6IGZvY3VzIH0pIDogZmlsZSk7XHJcbiAgICBsZXQgbm9ydGhQYW5lbCA9IE9iamVjdC5hc3NpZ24oe30sIHN0ZXAubm9ydGhQYW5lbCk7XHJcbiAgICBsZXQgc291dGhQYW5lbCA9IHN0ZXAuc291dGhQYW5lbCAmJiBPYmplY3QuYXNzaWduKHt9LCBzdGVwLnNvdXRoUGFuZWwpO1xyXG4gICAgaWYgKHN0ZXAubm9ydGhQYW5lbC50YWJzLmluY2x1ZGVzKG5hbWUpKSB7XHJcbiAgICAgICAgbm9ydGhQYW5lbC5hY3RpdmUgPSBuYW1lO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc291dGhQYW5lbCkge1xyXG4gICAgICAgIHNvdXRoUGFuZWwuYWN0aXZlID0gbmFtZTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGZpbGVzOiBuZXdGaWxlcywgbm9ydGhQYW5lbCwgc291dGhQYW5lbCB9O1xyXG59XG5cbmNvbnN0IFNlY3Rpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7XHJcbiAgICBwcm9wczogbnVsbCxcclxuICAgIHNldEZvY3VzOiAoKSA9PiB7IH0sXHJcbn0pO1xyXG5mdW5jdGlvbiBTZWN0aW9uKF9hKSB7XHJcbiAgICB2YXIgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcInN0eWxlXCJdKTtcclxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUocHJvcHMpO1xyXG4gICAgY29uc3QgcmVzZXRGb2N1cyA9ICgpID0+IHNldFN0YXRlKHByb3BzKTtcclxuICAgIGNvbnN0IHNldEZvY3VzID0gKHsgZmlsZU5hbWUsIGZvY3VzLCBpZCwgfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5ld1N0ZXAgPSB1cGRhdGVFZGl0b3JTdGVwKHN0YXRlLCBmaWxlTmFtZSwgZm9jdXMpO1xyXG4gICAgICAgIHNldFN0YXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIG5ld1N0ZXApLCB7IHNlbGVjdGVkSWQ6IGlkIH0pKTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZXN0ID0gX19yZXN0KHN0YXRlLCBbXCJzZWxlY3RlZElkXCJdKTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgeyBjbGFzc05hbWU6IGBjaC1zZWN0aW9uICR7Y2xhc3NOYW1lIHx8IFwiXCJ9YCwgc3R5bGU6IHN0eWxlIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTZWN0aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZToge1xyXG4gICAgICAgICAgICAgICAgcHJvcHM6IHJlc3QsXHJcbiAgICAgICAgICAgICAgICBzZXRGb2N1cyxcclxuICAgICAgICAgICAgfSB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmthYmxlU2VjdGlvbiwgeyBvbkFjdGl2YXRpb246IHNldEZvY3VzLCBvblJlc2V0OiByZXNldEZvY3VzIH0sIGNoaWxkcmVuKSkpKTtcclxufVxyXG5mdW5jdGlvbiBTZWN0aW9uQ29kZShpbm5lclByb3BzKSB7XHJcbiAgICBjb25zdCB7IHByb3BzLCBzZXRGb2N1cyB9ID0gUmVhY3QudXNlQ29udGV4dChTZWN0aW9uQ29udGV4dCk7XHJcbiAgICBjb25zdCBvblRhYkNsaWNrID0gKGZpbGVuYW1lKSA9PiB7XHJcbiAgICAgICAgc2V0Rm9jdXMoeyBmaWxlTmFtZTogZmlsZW5hbWUsIGZvY3VzOiBudWxsLCBpZDogXCJcIiB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5uZXJDb2RlLCBPYmplY3QuYXNzaWduKHt9LCBpbm5lclByb3BzLCBwcm9wcywgeyBvblRhYkNsaWNrOiBvblRhYkNsaWNrIH0pKSk7XHJcbn1cclxuLy8gLS0tXHJcbmZ1bmN0aW9uIFNlY3Rpb25MaW5rKHsgZm9jdXMsIGZpbGUsIGNoaWxkcmVuLCBpZCwgfSkge1xyXG4gICAgY29uc3QgeyBhY3RpdmF0ZSwgcmVzZXQsIGFjdGl2YXRlZElkIH0gPSBSZWFjdC51c2VDb250ZXh0KExpbmthYmxlQ29udGV4dCk7XHJcbiAgICBjb25zdCBpc1NlbGVjdGVkID0gYWN0aXZhdGVkSWQgPT09IGlkO1xyXG4gICAgLy8gY29uc3QgaGFuZGxlQ2xpY2sgPSBpc1NlbGVjdGVkXHJcbiAgICAvLyAgID8gcmVzZXRGb2N1c1xyXG4gICAgLy8gICA6ICgpID0+IHNldEZvY3VzKHsgZmlsZU5hbWU6IGZpbGUsIGZvY3VzLCBpZCB9KVxyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJjaC1zZWN0aW9uLWxpbmtcIiwgXCJkYXRhLWFjdGl2ZVwiOiBpc1NlbGVjdGVkLCBcclxuICAgICAgICAvLyBvbkNsaWNrPXtoYW5kbGVDbGlja31cclxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sIG9uTW91c2VPdmVyOiAoKSA9PiBhY3RpdmF0ZSh7IGZpbGVOYW1lOiBmaWxlLCBmb2N1cywgaWQgfSksIG9uTW91c2VPdXQ6IHJlc2V0IH0pKTtcclxufVxyXG5jb25zdCBMaW5rYWJsZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcclxuICAgIGFjdGl2YXRlZElkOiB1bmRlZmluZWQsXHJcbiAgICBhY3RpdmF0ZTogKCkgPT4geyB9LFxyXG4gICAgcmVzZXQ6ICgpID0+IHsgfSxcclxufSk7XHJcbmZ1bmN0aW9uIExpbmthYmxlU2VjdGlvbih7IG9uQWN0aXZhdGlvbiwgb25SZXNldCwgY2hpbGRyZW4sIH0pIHtcclxuICAgIGNvbnN0IFthY3RpdmF0ZWRJZCwgc2V0QWN0aXZhdGVkSWRdID0gUmVhY3QudXNlU3RhdGUodW5kZWZpbmVkKTtcclxuICAgIGNvbnN0IGFjdGl2YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soeCA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZhdGVkSWQoeC5pZCk7XHJcbiAgICAgICAgb25BY3RpdmF0aW9uKHgpO1xyXG4gICAgfSwgW29uQWN0aXZhdGlvbl0pO1xyXG4gICAgY29uc3QgcmVzZXQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZhdGVkSWQodW5kZWZpbmVkKTtcclxuICAgICAgICBvblJlc2V0KCk7XHJcbiAgICB9LCBbb25SZXNldF0pO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KExpbmthYmxlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZToge1xyXG4gICAgICAgICAgICBhY3RpdmF0ZSxcclxuICAgICAgICAgICAgcmVzZXQsXHJcbiAgICAgICAgICAgIGFjdGl2YXRlZElkLFxyXG4gICAgICAgIH0gfSwgY2hpbGRyZW4pKTtcclxufVxuXG5mdW5jdGlvbiBCYWNrKCkge1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJ4TWlkWU1pZCBtZWV0XCIsIGhlaWdodDogXCIxZW1cIiwgdmlld0JveDogXCIxMyAxMCAxNCAyM1wiLCBjbGFzc05hbWU6IFwiY2gtYnJvd3Nlci1idXR0b24gY2gtYnJvd3Nlci1iYWNrLWJ1dHRvblwiIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgbnVsbCxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIm0yNi41IDEyLjFxMCAwLjMtMC4yIDAuNmwtOC44IDguNyA4LjggOC44cTAuMiAwLjIgMC4yIDAuNXQtMC4yIDAuNWwtMS4xIDEuMXEtMC4zIDAuMy0wLjYgMC4zdC0wLjUtMC4zbC0xMC40LTEwLjRxLTAuMi0wLjItMC4yLTAuNXQwLjItMC41bDEwLjQtMTAuNHEwLjMtMC4yIDAuNS0wLjJ0MC42IDAuMmwxLjEgMS4xcTAuMiAwLjIgMC4yIDAuNXpcIiB9KSkpKTtcclxufVxyXG5mdW5jdGlvbiBGb3J3YXJkKCkge1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJ4TWlkWU1pZCBtZWV0XCIsIGhlaWdodDogXCIxZW1cIiwgdmlld0JveDogXCIxMyAxMCAxNCAyM1wiLCBjbGFzc05hbWU6IFwiY2gtYnJvd3Nlci1idXR0b24gY2gtYnJvd3Nlci1mb3J3YXJkLWJ1dHRvblwiIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgbnVsbCxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIm0yNi4zIDIxLjRxMCAwLjMtMC4yIDAuNWwtMTAuNCAxMC40cS0wLjMgMC4zLTAuNiAwLjN0LTAuNS0wLjNsLTEuMS0xLjFxLTAuMi0wLjItMC4yLTAuNXQwLjItMC41bDguOC04LjgtOC44LTguN3EtMC4yLTAuMy0wLjItMC42dDAuMi0wLjVsMS4xLTEuMXEwLjMtMC4yIDAuNS0wLjJ0MC42IDAuMmwxMC40IDEwLjRxMC4yIDAuMiAwLjIgMC41elwiIH0pKSkpO1xyXG59XHJcbmZ1bmN0aW9uIE9wZW4oeyBocmVmIH0pIHtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwgeyBjbGFzc05hbWU6IFwiY2gtYnJvd3Nlci1idXR0b24gY2gtYnJvd3Nlci1vcGVuLWJ1dHRvblwiLCB0aXRsZTogXCJPcGVuIGluIG5ldyB0YWJcIiwgaHJlZjogaHJlZiwgdGFyZ2V0OiBcIl9ibGFua1wiLCByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMFwiLCB2aWV3Qm94OiBcIjMgMyAxOCAxOFwiLCBoZWlnaHQ6IFwiMWVtXCIsIHdpZHRoOiBcIjFlbVwiLCBjbGFzc05hbWU6IFwiY2gtYnJvd3Nlci1vcGVuLWljb25cIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE5IDE5SDVWNWg3VjNINWMtMS4xMSAwLTIgLjktMiAydjE0YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0ydi03aC0ydjd6TTE0IDN2MmgzLjU5bC05LjgzIDkuODMgMS40MSAxLjQxTDE5IDYuNDFWMTBoMlYzaC03elwiIH0pKSkpO1xyXG59XG5cbmZ1bmN0aW9uIFRpdGxlQmFyKHsgdXJsLCBsaW5rVXJsLCB9KSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChGcmFtZUJ1dHRvbnMsIG51bGwpLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFjaywgbnVsbCksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChGb3J3YXJkLCBudWxsKSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgeyB2YWx1ZTogdXJsIHx8IFwiXCIsIHJlYWRPbmx5OiB0cnVlIH0pLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoT3BlbiwgeyBocmVmOiBsaW5rVXJsIH0pKSk7XHJcbn1cblxuZnVuY3Rpb24gdXNlU3RlcHMkMShzdGVwcykge1xyXG4gICAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xyXG4gICAgICAgIGlmICghc3RlcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt7IHpvb206IDEgfV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGVwcy5tYXAoc3RlcCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGlzcGxheVVybCwgbG9hZFVybCB9ID0gdHJhbnNmb3JtVXJsKHN0ZXAudXJsLCBzdGVwLmxvYWRVcmwsIHN0ZXAucHJlcGVuZE9yaWdpbik7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB6b29tOiBzdGVwLnpvb20gfHwgMSxcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlVcmwsXHJcbiAgICAgICAgICAgICAgICBsb2FkVXJsLFxyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IHN0ZXAuY2hpbGRyZW4sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbc3RlcHNdKTtcclxufVxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1VcmwodXJsLCBsb2FkVXJsLCBwcmVwZW5kT3JpZ2luKSB7XHJcbiAgICBjb25zdCBjdXJyZW50T3JpZ2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5vcmlnaW4gOiBcIlwiO1xyXG4gICAgY29uc3QgZGlzcGxheVVybCA9IHVybCAmJiBwcmVwZW5kT3JpZ2luID09PSB0cnVlXHJcbiAgICAgICAgPyBjdXJyZW50T3JpZ2luICsgdXJsXHJcbiAgICAgICAgOiB1cmw7XHJcbiAgICByZXR1cm4geyBkaXNwbGF5VXJsLCBsb2FkVXJsOiBsb2FkVXJsIHx8IGRpc3BsYXlVcmwgfTtcclxufVxuXG5jb25zdCBNaW5pQnJvd3Nlckhpa2UgPSBSZWFjdC5mb3J3YXJkUmVmKE1pbmlCcm93c2VyV2l0aFJlZik7XHJcbmZ1bmN0aW9uIE1pbmlCcm93c2VyV2l0aFJlZihfYSwgcmVmKSB7XHJcbiAgICB2YXIgeyBwcm9ncmVzcyA9IDAsIGJhY2t3YXJkID0gZmFsc2UsIHN0ZXBzOiBvZ1N0ZXBzLCB0cmFuc2l0aW9uID0gXCJub25lXCIgfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wicHJvZ3Jlc3NcIiwgXCJiYWNrd2FyZFwiLCBcInN0ZXBzXCIsIFwidHJhbnNpdGlvblwiXSk7XHJcbiAgICBjb25zdCBzdGVwcyA9IHVzZVN0ZXBzJDEob2dTdGVwcyk7XHJcbiAgICBjb25zdCBzdGVwSW5kZXggPSBNYXRoLnJvdW5kKHByb2dyZXNzKTtcclxuICAgIGNvbnN0IHsgem9vbSwgZGlzcGxheVVybCwgbG9hZFVybCwgY2hpbGRyZW4gfSA9IHN0ZXBzW3N0ZXBJbmRleF07XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWluaUZyYW1lLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyB6b29tOiB6b29tLCBjbGFzc05hbWU6IGBjaC1taW5pLWJyb3dzZXIgJHtwcm9wcy5jbGFzc05hbWUgfHwgXCJcIn1gLCBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0cmFuc2l0aW9uU3R5bGUoeyBwcm9ncmVzcywgdHJhbnNpdGlvbiB9KSksIHByb3BzLnN0eWxlKSwgdGl0bGVCYXI6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGl0bGVCYXIsIHsgdXJsOiBkaXNwbGF5VXJsLCBsaW5rVXJsOiBsb2FkVXJsIH0pIH0pLCBjaGlsZHJlbiB8fCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIsIHsgcmVmOiByZWYsIHNyYzogbG9hZFVybCB9KSkpO1xyXG59XHJcbmZ1bmN0aW9uIHRyYW5zaXRpb25TdHlsZSh7IHByb2dyZXNzLCB0cmFuc2l0aW9uLCB9KSB7XHJcbiAgICBpZiAodHJhbnNpdGlvbiA9PT0gXCJzbGlkZVwiKSB7XHJcbiAgICAgICAgY29uc3QgWCA9IDUwO1xyXG4gICAgICAgIGNvbnN0IHQgPSBwcm9ncmVzcyAtIE1hdGguZmxvb3IocHJvZ3Jlc3MpO1xyXG4gICAgICAgIGNvbnN0IHggPSB0IDw9IDAuNSA/IC1YICogdCA6IFggLSBYICogdDtcclxuICAgICAgICBjb25zdCBvID0gTWF0aC5hYnModCAtIDAuNSkgKiAyO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHt4fXB4KWAsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IG8gKiBvLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge307XHJcbn1cblxuZnVuY3Rpb24gTWluaUJyb3dzZXIoX2EpIHtcclxuICAgIHZhciB7IHVybCwgbG9hZFVybCwgcHJlcGVuZE9yaWdpbiwgY2hpbGRyZW4sIHpvb20gfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ1cmxcIiwgXCJsb2FkVXJsXCIsIFwicHJlcGVuZE9yaWdpblwiLCBcImNoaWxkcmVuXCIsIFwiem9vbVwiXSk7XHJcbiAgICBjb25zdCBbc3RlcHMsIHByb2dyZXNzXSA9IHVzZVN0ZXBzKHtcclxuICAgICAgICB1cmwsXHJcbiAgICAgICAgbG9hZFVybCxcclxuICAgICAgICBwcmVwZW5kT3JpZ2luLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIHpvb20sXHJcbiAgICB9KTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChNaW5pQnJvd3Nlckhpa2UsIE9iamVjdC5hc3NpZ24oe30sIHJlc3QsIHsgc3RlcHM6IHN0ZXBzLCBwcm9ncmVzczogcHJvZ3Jlc3MgfSkpKTtcclxufVxyXG5mdW5jdGlvbiB1c2VTdGVwcyh7IHVybCwgbG9hZFVybCwgcHJlcGVuZE9yaWdpbiwgY2hpbGRyZW4sIHpvb20sIH0pIHtcclxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xyXG4gICAgICAgIHRhcmdldDogMCxcclxuICAgICAgICBzdGVwczogW1xyXG4gICAgICAgICAgICB7IHVybCwgbG9hZFVybCwgcHJlcGVuZE9yaWdpbiwgY2hpbGRyZW4sIHpvb20gfSxcclxuICAgICAgICBdLFxyXG4gICAgfSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGxhc3QgPSBzdGF0ZS5zdGVwc1tzdGF0ZS5zdGVwcy5sZW5ndGggLSAxXTtcclxuICAgICAgICBpZiAobGFzdC51cmwgIT09IHVybCB8fFxyXG4gICAgICAgICAgICBsYXN0LmxvYWRVcmwgIT09IGxvYWRVcmwgfHxcclxuICAgICAgICAgICAgbGFzdC5wcmVwZW5kT3JpZ2luICE9PSBwcmVwZW5kT3JpZ2luIHx8XHJcbiAgICAgICAgICAgIGxhc3QuY2hpbGRyZW4gIT09IGNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKHMgPT4gKHtcclxuICAgICAgICAgICAgICAgIHRhcmdldDogcy50YXJnZXQgKyAxLFxyXG4gICAgICAgICAgICAgICAgc3RlcHM6IFtcclxuICAgICAgICAgICAgICAgICAgICAuLi5zLnN0ZXBzLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgdXJsLCBsb2FkVXJsLCBwcmVwZW5kT3JpZ2luLCBjaGlsZHJlbiwgem9vbSB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt1cmwsIGxvYWRVcmwsIHByZXBlbmRPcmlnaW4sIGNoaWxkcmVuLCB6b29tXSk7XHJcbiAgICBjb25zdCBbcHJvZ3Jlc3NdID0gdXNlU3ByaW5nKHN0YXRlLnRhcmdldCwge1xyXG4gICAgICAgIHN0aWZmbmVzczogMTAwLFxyXG4gICAgICAgIGRlY2ltYWxzOiAzLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gW3N0YXRlLnN0ZXBzLCBwcm9ncmVzc107XHJcbn1cblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciB0ZW1wbGF0ZXMgPSB7fTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHRlbXBsYXRlcywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBnZXRNYWluRmlsZSh0ZW1wbGF0ZSkge1xuICAgIGlmICh0ZW1wbGF0ZSA9PT0gXCJ2dWUtY2xpXCIpIHtcbiAgICAgICAgcmV0dXJuIFwic3JjL21haW4uanNcIjtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlID09PSBcImFuZ3VsYXItY2xpXCIpIHtcbiAgICAgICAgcmV0dXJuIFwic3JjL21haW4udHNcIjtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlID09PSBcImNyZWF0ZS1yZWFjdC1hcHAtdHlwZXNjcmlwdFwiKSB7XG4gICAgICAgIHJldHVybiBcInNyYy9pbmRleC50c3hcIjtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlID09PSBcInBhcmNlbFwiKSB7XG4gICAgICAgIHJldHVybiBcImluZGV4Lmh0bWxcIjtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlID09PSBcImdhdHNieVwiKSB7XG4gICAgICAgIHJldHVybiBcInNyYy9wYWdlcy9pbmRleC5qc1wiO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUgPT09IFwibnV4dFwiKSB7XG4gICAgICAgIC8vIFdpbGRjYXJkLCBiZWNhdXNlIG51eHQgaXMgbm90IHNwZWNpZmljIG9uIHRoaXNcbiAgICAgICAgcmV0dXJuIFwicGFja2FnZS5qc29uXCI7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gV2lsZGNhcmQsIGJlY2F1c2UgbmV4dCBpcyBub3Qgc3BlY2lmaWMgb24gdGhpc1xuICAgICAgICByZXR1cm4gXCJwYWNrYWdlLmpzb25cIjtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlID09PSBcImFwb2xsb1wiKSB7XG4gICAgICAgIC8vIFdpbGRjYXJkLCBiZWNhdXNlIGFwb2xsbyBpcyBub3Qgc3BlY2lmaWMgb24gdGhpc1xuICAgICAgICByZXR1cm4gXCJwYWNrYWdlLmpzb25cIjtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlID09PSBcInJlYXNvblwiKSB7XG4gICAgICAgIC8vIFdpbGRjYXJkLCBiZWNhdXNlIHJlYXNvbiBpcyBub3Qgc3BlY2lmaWMgb24gdGhpc1xuICAgICAgICByZXR1cm4gXCJwYWNrYWdlLmpzb25cIjtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlID09PSBcInNhcHBlclwiKSB7XG4gICAgICAgIC8vIFdpbGRjYXJkLCBiZWNhdXNlIHNhcHBlciBpcyBub3Qgc3BlY2lmaWMgb24gdGhpc1xuICAgICAgICByZXR1cm4gXCJwYWNrYWdlLmpzb25cIjtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlID09PSBcIm5lc3RcIikge1xuICAgICAgICByZXR1cm4gXCJzcmMvbWFpbi50c1wiO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUgPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiaW5kZXguaHRtbFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJzcmMvaW5kZXguanNcIjtcbn1cbnRlbXBsYXRlcy5nZXRNYWluRmlsZSA9IGdldE1haW5GaWxlO1xudmFyIFNBTkRCT1hfQ09ORklHID0gXCJzYW5kYm94LmNvbmZpZy5qc29uXCI7XG5mdW5jdGlvbiBnZXRUZW1wbGF0ZShwYWNrYWdlSlNPTlBhY2thZ2UsIG1vZHVsZXMpIHtcbiAgICB2YXIgc2FuZGJveENvbmZpZyA9IG1vZHVsZXNbU0FOREJPWF9DT05GSUddIHx8IG1vZHVsZXNbXCIvXCIgKyBTQU5EQk9YX0NPTkZJR107XG4gICAgaWYgKHNhbmRib3hDb25maWcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBKU09OLnBhcnNlKHNhbmRib3hDb25maWcuY29udGVudCk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy50ZW1wbGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIHZhciBfYSA9IHBhY2thZ2VKU09OUGFja2FnZS5kZXBlbmRlbmNpZXMsIGRlcGVuZGVuY2llcyA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYiA9IHBhY2thZ2VKU09OUGFja2FnZS5kZXZEZXBlbmRlbmNpZXMsIGRldkRlcGVuZGVuY2llcyA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iO1xuICAgIHZhciB0b3RhbERlcGVuZGVuY2llcyA9IE9iamVjdC5rZXlzKGRlcGVuZGVuY2llcykuY29uY2F0KE9iamVjdC5rZXlzKGRldkRlcGVuZGVuY2llcykpO1xuICAgIHZhciBudXh0ID0gW1wibnV4dFwiLCBcIm51eHQtZWRnZVwiXTtcbiAgICBpZiAodG90YWxEZXBlbmRlbmNpZXMuc29tZShmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBudXh0LmluZGV4T2YoZGVwKSA+IC0xOyB9KSkge1xuICAgICAgICByZXR1cm4gXCJudXh0XCI7XG4gICAgfVxuICAgIGlmICh0b3RhbERlcGVuZGVuY2llcy5pbmRleE9mKFwibmV4dFwiKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBcIm5leHRcIjtcbiAgICB9XG4gICAgdmFyIGFwb2xsbyA9IFtcbiAgICAgICAgXCJhcG9sbG8tc2VydmVyXCIsXG4gICAgICAgIFwiYXBvbGxvLXNlcnZlci1leHByZXNzXCIsXG4gICAgICAgIFwiYXBvbGxvLXNlcnZlci1oYXBpXCIsXG4gICAgICAgIFwiYXBvbGxvLXNlcnZlci1rb2FcIixcbiAgICAgICAgXCJhcG9sbG8tc2VydmVyLWxhbWJkYVwiLFxuICAgICAgICBcImFwb2xsby1zZXJ2ZXItbWljcm9cIlxuICAgIF07XG4gICAgaWYgKHRvdGFsRGVwZW5kZW5jaWVzLnNvbWUoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gYXBvbGxvLmluZGV4T2YoZGVwKSA+IC0xOyB9KSkge1xuICAgICAgICByZXR1cm4gXCJhcG9sbG9cIjtcbiAgICB9XG4gICAgaWYgKHRvdGFsRGVwZW5kZW5jaWVzLmluZGV4T2YoXCJlbWJlci1jbGlcIikgPiAtMSkge1xuICAgICAgICByZXR1cm4gXCJlbWJlclwiO1xuICAgIH1cbiAgICBpZiAodG90YWxEZXBlbmRlbmNpZXMuaW5kZXhPZihcInNhcHBlclwiKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBcInNhcHBlclwiO1xuICAgIH1cbiAgICB2YXIgbW9kdWxlTmFtZXMgPSBPYmplY3Qua2V5cyhtb2R1bGVzKTtcbiAgICBpZiAobW9kdWxlTmFtZXMuc29tZShmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5lbmRzV2l0aChcIi52dWVcIik7IH0pKSB7XG4gICAgICAgIHJldHVybiBcInZ1ZS1jbGlcIjtcbiAgICB9XG4gICAgaWYgKG1vZHVsZU5hbWVzLnNvbWUoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uZW5kc1dpdGgoXCIucmVcIik7IH0pKSB7XG4gICAgICAgIHJldHVybiBcInJlYXNvblwiO1xuICAgIH1cbiAgICBpZiAodG90YWxEZXBlbmRlbmNpZXMuaW5kZXhPZihcImdhdHNieVwiKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBcImdhdHNieVwiO1xuICAgIH1cbiAgICBpZiAodG90YWxEZXBlbmRlbmNpZXMuaW5kZXhPZihcInBhcmNlbC1idW5kbGVyXCIpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIFwicGFyY2VsXCI7XG4gICAgfVxuICAgIGlmICh0b3RhbERlcGVuZGVuY2llcy5pbmRleE9mKFwicmVhY3Qtc2NyaXB0c1wiKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBcImNyZWF0ZS1yZWFjdC1hcHBcIjtcbiAgICB9XG4gICAgaWYgKHRvdGFsRGVwZW5kZW5jaWVzLmluZGV4T2YoXCJyZWFjdC1zY3JpcHRzLXRzXCIpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIFwiY3JlYXRlLXJlYWN0LWFwcC10eXBlc2NyaXB0XCI7XG4gICAgfVxuICAgIGlmICh0b3RhbERlcGVuZGVuY2llcy5pbmRleE9mKFwiQGFuZ3VsYXIvY29yZVwiKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBcImFuZ3VsYXItY2xpXCI7XG4gICAgfVxuICAgIGlmICh0b3RhbERlcGVuZGVuY2llcy5pbmRleE9mKFwicHJlYWN0LWNsaVwiKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBcInByZWFjdC1jbGlcIjtcbiAgICB9XG4gICAgaWYgKHRvdGFsRGVwZW5kZW5jaWVzLmluZGV4T2YoXCJzdmVsdGVcIikgPiAtMSkge1xuICAgICAgICByZXR1cm4gXCJzdmVsdGVcIjtcbiAgICB9XG4gICAgaWYgKHRvdGFsRGVwZW5kZW5jaWVzLmluZGV4T2YoXCJ2dWVcIikgPiAtMSkge1xuICAgICAgICByZXR1cm4gXCJ2dWUtY2xpXCI7XG4gICAgfVxuICAgIHZhciBkb2pvID0gW1wiQGRvam8vY29yZVwiLCBcIkBkb2pvL2ZyYW1ld29ya1wiXTtcbiAgICBpZiAodG90YWxEZXBlbmRlbmNpZXMuc29tZShmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBkb2pvLmluZGV4T2YoZGVwKSA+IC0xOyB9KSkge1xuICAgICAgICByZXR1cm4gXCJAZG9qby9jbGktY3JlYXRlLWFwcFwiO1xuICAgIH1cbiAgICBpZiAodG90YWxEZXBlbmRlbmNpZXMuaW5kZXhPZihcImN4XCIpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIFwiY3hqc1wiO1xuICAgIH1cbiAgICBpZiAodG90YWxEZXBlbmRlbmNpZXMuaW5kZXhPZihcIkBuZXN0anMvY29yZVwiKSA+IC0xIHx8XG4gICAgICAgIHRvdGFsRGVwZW5kZW5jaWVzLmluZGV4T2YoXCJAbmVzdGpzL2NvbW1vblwiKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBcIm5lc3RcIjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbnZhciBnZXRUZW1wbGF0ZV8xID0gdGVtcGxhdGVzLmdldFRlbXBsYXRlID0gZ2V0VGVtcGxhdGU7XG5cbnZhciBsb2Rhc2hfaXNlcXVhbCA9IHtleHBvcnRzOiB7fX07XG5cbi8qKlxuICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBjb21tb25qc0dsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmICdvYmplY3QnID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBvYmplY3QgPT09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbDtcbn0obG9kYXNoX2lzZXF1YWwsIGxvZGFzaF9pc2VxdWFsLmV4cG9ydHMpKTtcblxudmFyIGlzRXF1YWwgPSBsb2Rhc2hfaXNlcXVhbC5leHBvcnRzO1xuXG4vLyBzcmMvY2xpZW50LnRzXG5cbi8vIHNyYy9maWxlLXJlc29sdmVyLXByb3RvY29sLnRzXG52YXIgZ2VuZXJhdGVJZCA9ICgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNiArIE1hdGgucmFuZG9tKCkgKiAxZTYpO1xudmFyIGdldENvbnN0cnVjdG9yTmFtZSA9ICh4KSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHguY29uc3RydWN0b3IubmFtZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG59O1xudmFyIFByb3RvY29sID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBoYW5kbGVNZXNzYWdlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuaGFuZGxlTWVzc2FnZSA9IGhhbmRsZU1lc3NhZ2U7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5vdXRnb2luZ01lc3NhZ2VzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IGFzeW5jIChlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGU7XG4gICAgICBpZiAoZGF0YS4kdHlwZSAhPT0gdGhpcy5nZXRUeXBlSWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vdXRnb2luZ01lc3NhZ2VzLmhhcyhkYXRhLiRpZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHJldHVybk1lc3NhZ2UgPSB7XG4gICAgICAgICRvcmlnaW5JZDogdGhpcy5pbnRlcm5hbElkLFxuICAgICAgICAkdHlwZTogdGhpcy5nZXRUeXBlSWQoKSxcbiAgICAgICAgJGlkOiBkYXRhLiRpZFxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaGFuZGxlTWVzc2FnZShkYXRhLiRkYXRhKTtcbiAgICAgICAgcmV0dXJuTWVzc2FnZS4kZGF0YSA9IHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWVyci5tZXNzYWdlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybk1lc3NhZ2UuJGVycm9yID0geyBtZXNzYWdlOiAoX2EgPSBlcnIubWVzc2FnZSkgIT0gbnVsbCA/IF9hIDogXCJVbmtub3duIGVycm9yXCIgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlLnNvdXJjZSkge1xuICAgICAgICBlLnNvdXJjZS5wb3N0TWVzc2FnZShyZXR1cm5NZXNzYWdlLCBcIipcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wb3N0TWVzc2FnZShyZXR1cm5NZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY3JlYXRlQ29ubmVjdGlvbigpO1xuICAgIHRoaXMuaW50ZXJuYWxJZCA9IGdlbmVyYXRlSWQoKTtcbiAgICB0aGlzLmlzV29ya2VyID0gZ2V0Q29uc3RydWN0b3JOYW1lKHRhcmdldCkgPT09IFwiV29ya2VyXCI7XG4gIH1cbiAgZ2V0VHlwZUlkKCkge1xuICAgIHJldHVybiBgcC0ke3RoaXMudHlwZX1gO1xuICB9XG4gIGNyZWF0ZUNvbm5lY3Rpb24oKSB7XG4gICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9tZXNzYWdlTGlzdGVuZXIpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9tZXNzYWdlTGlzdGVuZXIpO1xuICB9XG4gIHNlbmRNZXNzYWdlKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICRvcmlnaW5JZDogdGhpcy5pbnRlcm5hbElkLFxuICAgICAgICAkdHlwZTogdGhpcy5nZXRUeXBlSWQoKSxcbiAgICAgICAgJGRhdGE6IGRhdGEsXG4gICAgICAgICRpZDogbWVzc2FnZUlkXG4gICAgICB9O1xuICAgICAgdGhpcy5vdXRnb2luZ01lc3NhZ2VzLmFkZChtZXNzYWdlSWQpO1xuICAgICAgY29uc3QgbGlzdGVuRnVuY3Rpb24gPSAoZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGE6IGRhdGEyIH0gPSBlO1xuICAgICAgICBpZiAoZGF0YTIuJHR5cGUgPT09IHRoaXMuZ2V0VHlwZUlkKCkgJiYgZGF0YTIuJGlkID09PSBtZXNzYWdlSWQgJiYgZGF0YTIuJG9yaWdpbklkICE9PSB0aGlzLmludGVybmFsSWQpIHtcbiAgICAgICAgICByZXNvbHZlKGRhdGEyLiRkYXRhKTtcbiAgICAgICAgICBzZWxmLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbkZ1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuRnVuY3Rpb24pO1xuICAgICAgdGhpcy5fcG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cbiAgX3Bvc3RNZXNzYWdlKG0pIHtcbiAgICBpZiAodGhpcy5pc1dvcmtlciB8fCB0eXBlb2YgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy50YXJnZXQgaW5zdGFuY2VvZiBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZSkge1xuICAgICAgdGhpcy50YXJnZXQucG9zdE1lc3NhZ2UobSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFyZ2V0LnBvc3RNZXNzYWdlKG0sIFwiKlwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9pZnJhbWUtcHJvdG9jb2wudHNcbnZhciBJRnJhbWVQcm90b2NvbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaWZyYW1lLCBvcmlnaW4pIHtcbiAgICB0aGlzLmdsb2JhbExpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuZ2xvYmFsTGlzdGVuZXJzQ291bnQgPSAwO1xuICAgIHRoaXMuY2hhbm5lbExpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuY2hhbm5lbExpc3RlbmVyc0NvdW50ID0gMDtcbiAgICB0aGlzLmNoYW5uZWxJZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNik7XG4gICAgdGhpcy5mcmFtZVdpbmRvdyA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgIHRoaXMuZ2xvYmFsTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5jaGFubmVsTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5ldmVudExpc3RlbmVyID0gdGhpcy5ldmVudExpc3RlbmVyLmJpbmQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLmV2ZW50TGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLmV2ZW50TGlzdGVuZXIpO1xuICAgIHRoaXMuZ2xvYmFsTGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5jaGFubmVsTGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5nbG9iYWxMaXN0ZW5lcnNDb3VudCA9IDA7XG4gICAgdGhpcy5jaGFubmVsTGlzdGVuZXJzQ291bnQgPSAwO1xuICB9XG4gIHJlZ2lzdGVyKCkge1xuICAgIGlmICghdGhpcy5mcmFtZVdpbmRvdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZyYW1lV2luZG93LnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwicmVnaXN0ZXItZnJhbWVcIixcbiAgICAgIG9yaWdpbjogZG9jdW1lbnQubG9jYXRpb24ub3JpZ2luLFxuICAgICAgaWQ6IHRoaXMuY2hhbm5lbElkXG4gICAgfSwgdGhpcy5vcmlnaW4pO1xuICB9XG4gIGRpc3BhdGNoKG1lc3NhZ2UpIHtcbiAgICBpZiAoIXRoaXMuZnJhbWVXaW5kb3cpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5mcmFtZVdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICAkaWQ6IHRoaXMuY2hhbm5lbElkLFxuICAgICAgY29kZXNhbmRib3g6IHRydWUsXG4gICAgICAuLi5tZXNzYWdlXG4gICAgfSwgdGhpcy5vcmlnaW4pO1xuICB9XG4gIGdsb2JhbExpc3RlbihsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJJZCA9IHRoaXMuZ2xvYmFsTGlzdGVuZXJzQ291bnQ7XG4gICAgdGhpcy5nbG9iYWxMaXN0ZW5lcnNbbGlzdGVuZXJJZF0gPSBsaXN0ZW5lcjtcbiAgICB0aGlzLmdsb2JhbExpc3RlbmVyc0NvdW50Kys7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLmdsb2JhbExpc3RlbmVyc1tsaXN0ZW5lcklkXTtcbiAgICB9O1xuICB9XG4gIGNoYW5uZWxMaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVySWQgPSB0aGlzLmNoYW5uZWxMaXN0ZW5lcnNDb3VudDtcbiAgICB0aGlzLmNoYW5uZWxMaXN0ZW5lcnNbbGlzdGVuZXJJZF0gPSBsaXN0ZW5lcjtcbiAgICB0aGlzLmNoYW5uZWxMaXN0ZW5lcnNDb3VudCsrO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5jaGFubmVsTGlzdGVuZXJzW2xpc3RlbmVySWRdO1xuICAgIH07XG4gIH1cbiAgZXZlbnRMaXN0ZW5lcihldnQpIHtcbiAgICBpZiAoZXZ0LnNvdXJjZSAhPT0gdGhpcy5mcmFtZVdpbmRvdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gZXZ0LmRhdGE7XG4gICAgaWYgKCFtZXNzYWdlLmNvZGVzYW5kYm94KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC52YWx1ZXModGhpcy5nbG9iYWxMaXN0ZW5lcnMpLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihtZXNzYWdlKSk7XG4gICAgaWYgKG1lc3NhZ2UuJGlkICE9PSB0aGlzLmNoYW5uZWxJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QudmFsdWVzKHRoaXMuY2hhbm5lbExpc3RlbmVycykuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKG1lc3NhZ2UpKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzLnRzXG5mdW5jdGlvbiBjcmVhdGVQYWNrYWdlSlNPTihkZXBlbmRlbmNpZXMgPSB7fSwgZGV2RGVwZW5kZW5jaWVzID0ge30sIGVudHJ5ID0gXCIvaW5kZXguanNcIikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgIG5hbWU6IFwic2FuZHBhY2stcHJvamVjdFwiLFxuICAgIG1haW46IGVudHJ5LFxuICAgIGRlcGVuZGVuY2llcyxcbiAgICBkZXZEZXBlbmRlbmNpZXNcbiAgfSwgbnVsbCwgMik7XG59XG5mdW5jdGlvbiBhZGRQYWNrYWdlSlNPTklmTmVlZGVkKGZpbGVzLCBkZXBlbmRlbmNpZXMsIGRldkRlcGVuZGVuY2llcywgZW50cnkpIHtcbiAgY29uc3QgbmV3RmlsZXMgPSB7IC4uLmZpbGVzIH07XG4gIGlmICghbmV3RmlsZXNbXCIvcGFja2FnZS5qc29uXCJdKSB7XG4gICAgaWYgKCFkZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGRlcGVuZGVuY2llcyBzcGVjaWZpZWQsIHBsZWFzZSBzcGVjaWZ5IGVpdGhlciBhIHBhY2thZ2UuanNvbiBvciBkZXBlbmRlbmNpZXMuXCIpO1xuICAgIH1cbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdlbnRyeScgcGFyYW1ldGVyLiBFaXRoZXIgc3BlY2lmeSBhbiBlbnRyeSBwb2ludCwgb3IgcGFzcyBpbiBhIHBhY2thZ2UuanNvbiB3aXRoIHRoZSAnbWFpbicgZmllbGQgc2V0LlwiKTtcbiAgICB9XG4gICAgbmV3RmlsZXNbXCIvcGFja2FnZS5qc29uXCJdID0ge1xuICAgICAgY29kZTogY3JlYXRlUGFja2FnZUpTT04oZGVwZW5kZW5jaWVzLCBkZXZEZXBlbmRlbmNpZXMsIGVudHJ5KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG5ld0ZpbGVzO1xufVxuZnVuY3Rpb24gZXh0cmFjdEVycm9yRGV0YWlscyhtc2cpIHtcbiAgaWYgKG1zZy50aXRsZSA9PT0gXCJTeW50YXhFcnJvclwiKSB7XG4gICAgY29uc3QgeyB0aXRsZSwgcGF0aCwgbWVzc2FnZSwgbGluZSwgY29sdW1uIH0gPSBtc2c7XG4gICAgcmV0dXJuIHsgdGl0bGUsIHBhdGgsIG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiB9O1xuICB9XG4gIGNvbnN0IHJlbGV2YW50U3RhY2tGcmFtZSA9IGdldFJlbGV2YW50U3RhY2tGcmFtZShtc2cucGF5bG9hZC5mcmFtZXMpO1xuICBpZiAoIXJlbGV2YW50U3RhY2tGcmFtZSkge1xuICAgIHJldHVybiB7IG1lc3NhZ2U6IG1zZy5tZXNzYWdlIH07XG4gIH1cbiAgY29uc3QgZXJyb3JJbkNvZGUgPSBnZXRFcnJvckluT3JpZ2luYWxDb2RlKHJlbGV2YW50U3RhY2tGcmFtZSk7XG4gIGNvbnN0IGVycm9yTG9jYXRpb24gPSBnZXRFcnJvckxvY2F0aW9uKHJlbGV2YW50U3RhY2tGcmFtZSk7XG4gIGNvbnN0IGVycm9yTWVzc2FnZSA9IGZvcm1hdEVycm9yTWVzc2FnZShyZWxldmFudFN0YWNrRnJhbWUuX29yaWdpbmFsRmlsZU5hbWUsIG1zZy5tZXNzYWdlLCBlcnJvckxvY2F0aW9uLCBlcnJvckluQ29kZSk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgIHRpdGxlOiBtc2cudGl0bGUsXG4gICAgcGF0aDogcmVsZXZhbnRTdGFja0ZyYW1lLl9vcmlnaW5hbEZpbGVOYW1lLFxuICAgIGxpbmU6IHJlbGV2YW50U3RhY2tGcmFtZS5fb3JpZ2luYWxMaW5lTnVtYmVyLFxuICAgIGNvbHVtbjogcmVsZXZhbnRTdGFja0ZyYW1lLl9vcmlnaW5hbENvbHVtbk51bWJlclxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVsZXZhbnRTdGFja0ZyYW1lKGZyYW1lcykge1xuICBpZiAoIWZyYW1lcykge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gZnJhbWVzLmZpbmQoKGZyYW1lKSA9PiAhIWZyYW1lLl9vcmlnaW5hbEZpbGVOYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEVycm9yTG9jYXRpb24oZXJyb3JGcmFtZSkge1xuICByZXR1cm4gZXJyb3JGcmFtZSA/IGAgKCR7ZXJyb3JGcmFtZS5fb3JpZ2luYWxMaW5lTnVtYmVyfToke2Vycm9yRnJhbWUuX29yaWdpbmFsQ29sdW1uTnVtYmVyfSlgIDogYGA7XG59XG5mdW5jdGlvbiBnZXRFcnJvckluT3JpZ2luYWxDb2RlKGVycm9yRnJhbWUpIHtcbiAgY29uc3QgbGFzdFNjcmlwdExpbmUgPSBlcnJvckZyYW1lLl9vcmlnaW5hbFNjcmlwdENvZGVbZXJyb3JGcmFtZS5fb3JpZ2luYWxTY3JpcHRDb2RlLmxlbmd0aCAtIDFdO1xuICBjb25zdCBudW1iZXJPZkxpbmVOdW1iZXJDaGFyYWN0ZXJzID0gbGFzdFNjcmlwdExpbmUubGluZU51bWJlci50b1N0cmluZygpLmxlbmd0aDtcbiAgY29uc3QgbGVhZGluZ0NoYXJhY3Rlck9mZnNldCA9IDI7XG4gIGNvbnN0IGJhclNlcGFyYXRvckNoYXJhY3Rlck9mZnNldCA9IDM7XG4gIGNvbnN0IGV4dHJhTGluZUxlYWRpbmdTcGFjZXMgPSBsZWFkaW5nQ2hhcmFjdGVyT2Zmc2V0ICsgbnVtYmVyT2ZMaW5lTnVtYmVyQ2hhcmFjdGVycyArIGJhclNlcGFyYXRvckNoYXJhY3Rlck9mZnNldCArIGVycm9yRnJhbWUuX29yaWdpbmFsQ29sdW1uTnVtYmVyO1xuICByZXR1cm4gZXJyb3JGcmFtZS5fb3JpZ2luYWxTY3JpcHRDb2RlLnJlZHVjZSgocmVzdWx0LCBzY3JpcHRMaW5lKSA9PiB7XG4gICAgY29uc3QgbGVhZGluZ0NoYXIgPSBzY3JpcHRMaW5lLmhpZ2hsaWdodCA/IFwiPlwiIDogXCIgXCI7XG4gICAgY29uc3QgbGluZU51bWJlciA9IHNjcmlwdExpbmUubGluZU51bWJlci50b1N0cmluZygpLmxlbmd0aCA9PT0gbnVtYmVyT2ZMaW5lTnVtYmVyQ2hhcmFjdGVycyA/IGAke3NjcmlwdExpbmUubGluZU51bWJlcn1gIDogYCAke3NjcmlwdExpbmUubGluZU51bWJlcn1gO1xuICAgIGNvbnN0IGV4dHJhTGluZSA9IHNjcmlwdExpbmUuaGlnaGxpZ2h0ID8gXCJcXG5cIiArIFwiIFwiLnJlcGVhdChleHRyYUxpbmVMZWFkaW5nU3BhY2VzKSArIFwiXlwiIDogXCJcIjtcbiAgICByZXR1cm4gcmVzdWx0ICsgXCJcXG5cIiArIGxlYWRpbmdDaGFyICsgXCIgXCIgKyBsaW5lTnVtYmVyICsgXCIgfCBcIiArIHNjcmlwdExpbmUuY29udGVudCArIGV4dHJhTGluZTtcbiAgfSwgXCJcIik7XG59XG5mdW5jdGlvbiBmb3JtYXRFcnJvck1lc3NhZ2UoZmlsZVBhdGgsIG1lc3NhZ2UsIGxvY2F0aW9uLCBlcnJvckluQ29kZSkge1xuICByZXR1cm4gYCR7ZmlsZVBhdGh9OiAke21lc3NhZ2V9JHtsb2NhdGlvbn1cbiR7ZXJyb3JJbkNvZGV9YDtcbn1cblxuLy8gc3JjL2NsaWVudC50c1xudmFyIEJVTkRMRVJfVVJMID0gYGh0dHBzOi8vJHtcIjAuMTkuMFwiLnJlcGxhY2UoL1xcLi9nLCBcIi1cIil9LXNhbmRwYWNrLmNvZGVzYW5kYm94LmlvL2A7XG52YXIgU2FuZHBhY2tDbGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBzYW5kYm94SW5mbywgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5nZXRUcmFuc3BpbGVyQ29udGV4dCA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMubGlzdGVuKChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwidHJhbnNwaWxlci1jb250ZXh0XCIpIHtcbiAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogXCJnZXQtdHJhbnNwaWxlci1jb250ZXh0XCIgfSk7XG4gICAgfSk7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zYW5kYm94SW5mbyA9IHNhbmRib3hJbmZvO1xuICAgIHRoaXMuYnVuZGxlclVSTCA9IG9wdGlvbnMuYnVuZGxlclVSTCB8fCBCVU5ETEVSX1VSTDtcbiAgICB0aGlzLmJ1bmRsZXJTdGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMuc3RhdHVzID0gXCJpbml0aWFsaXppbmdcIjtcbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBlbGVtZW50IGZvdW5kIGZvciBzZWxlY3RvciAnJHtzZWxlY3Rvcn0nYCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5pZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgdGhpcy5pbml0aWFsaXplRWxlbWVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBzZWxlY3RvcjtcbiAgICAgIHRoaXMuaWZyYW1lID0gc2VsZWN0b3I7XG4gICAgfVxuICAgIGlmICghdGhpcy5pZnJhbWUuZ2V0QXR0cmlidXRlKFwic2FuZGJveFwiKSkge1xuICAgICAgdGhpcy5pZnJhbWUuc2V0QXR0cmlidXRlKFwic2FuZGJveFwiLCBcImFsbG93LWZvcm1zIGFsbG93LW1vZGFscyBhbGxvdy1wb3B1cHMgYWxsb3ctcHJlc2VudGF0aW9uIGFsbG93LXNhbWUtb3JpZ2luIGFsbG93LXNjcmlwdHNcIik7XG4gICAgfVxuICAgIGNvbnN0IHVybFNvdXJjZSA9IG9wdGlvbnMuc3RhcnRSb3V0ZSA/IG5ldyBVUkwob3B0aW9ucy5zdGFydFJvdXRlLCB0aGlzLmJ1bmRsZXJVUkwpLnRvU3RyaW5nKCkgOiB0aGlzLmJ1bmRsZXJVUkw7XG4gICAgKF9hID0gdGhpcy5pZnJhbWUuY29udGVudFdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxvY2F0aW9uLnJlcGxhY2UodXJsU291cmNlKTtcbiAgICB0aGlzLmlmcmFtZVByb3RvY29sID0gbmV3IElGcmFtZVByb3RvY29sKHRoaXMuaWZyYW1lLCB0aGlzLmJ1bmRsZXJVUkwpO1xuICAgIHRoaXMudW5zdWJzY3JpYmVHbG9iYWxMaXN0ZW5lciA9IHRoaXMuaWZyYW1lUHJvdG9jb2wuZ2xvYmFsTGlzdGVuKChtZXMpID0+IHtcbiAgICAgIGlmIChtZXMudHlwZSAhPT0gXCJpbml0aWFsaXplZFwiIHx8ICF0aGlzLmlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaWZyYW1lUHJvdG9jb2wucmVnaXN0ZXIoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsZVJlc29sdmVyKSB7XG4gICAgICAgIHRoaXMuZmlsZVJlc29sdmVyUHJvdG9jb2wgPSBuZXcgUHJvdG9jb2woXCJmaWxlLXJlc29sdmVyXCIsIGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGRhdGEubSA9PT0gXCJpc0ZpbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maWxlUmVzb2x2ZXIuaXNGaWxlKGRhdGEucCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZmlsZVJlc29sdmVyLnJlYWRGaWxlKGRhdGEucCk7XG4gICAgICAgIH0sIHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVQcmV2aWV3KHRoaXMuc2FuZGJveEluZm8sIHRydWUpO1xuICAgIH0pO1xuICAgIHRoaXMudW5zdWJzY3JpYmVDaGFubmVsTGlzdGVuZXIgPSB0aGlzLmlmcmFtZVByb3RvY29sLmNoYW5uZWxMaXN0ZW4oKG1lcykgPT4ge1xuICAgICAgc3dpdGNoIChtZXMudHlwZSkge1xuICAgICAgICBjYXNlIFwic3RhcnRcIjoge1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInN0YXR1c1wiOiB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBtZXMuc3RhdHVzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhY3Rpb25cIjoge1xuICAgICAgICAgIGlmIChtZXMuYWN0aW9uID09PSBcInNob3ctZXJyb3JcIikge1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBbLi4udGhpcy5lcnJvcnMsIGV4dHJhY3RFcnJvckRldGFpbHMobWVzKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzdGF0ZVwiOiB7XG4gICAgICAgICAgdGhpcy5idW5kbGVyU3RhdGUgPSBtZXMuc3RhdGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIHRoaXMudW5zdWJzY3JpYmVDaGFubmVsTGlzdGVuZXIoKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlR2xvYmFsTGlzdGVuZXIoKTtcbiAgICB0aGlzLmlmcmFtZVByb3RvY29sLmNsZWFudXAoKTtcbiAgfVxuICB1cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIWlzRXF1YWwodGhpcy5vcHRpb25zLCBvcHRpb25zKSkge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMudXBkYXRlUHJldmlldygpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQcmV2aWV3KHNhbmRib3hJbmZvID0gdGhpcy5zYW5kYm94SW5mbywgaXNJbml0aWFsaXphdGlvbkNvbXBpbGUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgdGhpcy5zYW5kYm94SW5mbyA9IHtcbiAgICAgIC4uLnRoaXMuc2FuZGJveEluZm8sXG4gICAgICAuLi5zYW5kYm94SW5mb1xuICAgIH07XG4gICAgY29uc3QgZmlsZXMgPSB0aGlzLmdldEZpbGVzKCk7XG4gICAgY29uc3QgbW9kdWxlcyA9IE9iamVjdC5rZXlzKGZpbGVzKS5yZWR1Y2UoKHByZXYsIG5leHQpID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgW25leHRdOiB7XG4gICAgICAgIGNvZGU6IGZpbGVzW25leHRdLmNvZGUsXG4gICAgICAgIHBhdGg6IG5leHRcbiAgICAgIH1cbiAgICB9KSwge30pO1xuICAgIGxldCBwYWNrYWdlSlNPTiA9IEpTT04ucGFyc2UoY3JlYXRlUGFja2FnZUpTT04odGhpcy5zYW5kYm94SW5mby5kZXBlbmRlbmNpZXMsIHRoaXMuc2FuZGJveEluZm8uZGV2RGVwZW5kZW5jaWVzLCB0aGlzLnNhbmRib3hJbmZvLmVudHJ5KSk7XG4gICAgdHJ5IHtcbiAgICAgIHBhY2thZ2VKU09OID0gSlNPTi5wYXJzZShmaWxlc1tcIi9wYWNrYWdlLmpzb25cIl0uY29kZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBwYWNrYWdlLmpzb24gZmlsZTogXCIgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkTW9kdWxlcyA9IE9iamVjdC5rZXlzKGZpbGVzKS5yZWR1Y2UoKHByZXYsIG5leHQpID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgW25leHRdOiB7XG4gICAgICAgIGNvbnRlbnQ6IGZpbGVzW25leHRdLmNvZGUsXG4gICAgICAgIHBhdGg6IG5leHRcbiAgICAgIH1cbiAgICB9KSwge30pO1xuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogXCJjb21waWxlXCIsXG4gICAgICBjb2Rlc2FuZGJveDogdHJ1ZSxcbiAgICAgIHZlcnNpb246IDMsXG4gICAgICBpc0luaXRpYWxpemF0aW9uQ29tcGlsZSxcbiAgICAgIG1vZHVsZXMsXG4gICAgICByZWFjdERldlRvb2xzOiB0aGlzLm9wdGlvbnMucmVhY3REZXZUb29scyxcbiAgICAgIGV4dGVybmFsUmVzb3VyY2VzOiB0aGlzLm9wdGlvbnMuZXh0ZXJuYWxSZXNvdXJjZXMgfHwgW10sXG4gICAgICBoYXNGaWxlUmVzb2x2ZXI6IEJvb2xlYW4odGhpcy5vcHRpb25zLmZpbGVSZXNvbHZlciksXG4gICAgICBkaXNhYmxlRGVwZW5kZW5jeVByZXByb2Nlc3Npbmc6IHRoaXMuc2FuZGJveEluZm8uZGlzYWJsZURlcGVuZGVuY3lQcmVwcm9jZXNzaW5nLFxuICAgICAgdGVtcGxhdGU6IHRoaXMuc2FuZGJveEluZm8udGVtcGxhdGUgfHwgZ2V0VGVtcGxhdGVfMShwYWNrYWdlSlNPTiwgbm9ybWFsaXplZE1vZHVsZXMpLFxuICAgICAgc2hvd09wZW5JbkNvZGVTYW5kYm94OiAoX2EgPSB0aGlzLm9wdGlvbnMuc2hvd09wZW5JbkNvZGVTYW5kYm94KSAhPSBudWxsID8gX2EgOiB0cnVlLFxuICAgICAgc2hvd0Vycm9yU2NyZWVuOiAoX2IgPSB0aGlzLm9wdGlvbnMuc2hvd0Vycm9yU2NyZWVuKSAhPSBudWxsID8gX2IgOiB0cnVlLFxuICAgICAgc2hvd0xvYWRpbmdTY3JlZW46IChfYyA9IHRoaXMub3B0aW9ucy5zaG93TG9hZGluZ1NjcmVlbikgIT0gbnVsbCA/IF9jIDogdHJ1ZSxcbiAgICAgIHNraXBFdmFsOiB0aGlzLm9wdGlvbnMuc2tpcEV2YWwgfHwgZmFsc2UsXG4gICAgICBjbGVhckNvbnNvbGVEaXNhYmxlZDogIXRoaXMub3B0aW9ucy5jbGVhckNvbnNvbGVPbkZpcnN0Q29tcGlsZSxcbiAgICAgIGxvZ0xldmVsOiAoX2QgPSB0aGlzLm9wdGlvbnMubG9nTGV2ZWwpICE9IG51bGwgPyBfZCA6IFNhbmRwYWNrTG9nTGV2ZWwuSW5mb1xuICAgIH0pO1xuICB9XG4gIGRpc3BhdGNoKG1lc3NhZ2UpIHtcbiAgICB0aGlzLmlmcmFtZVByb3RvY29sLmRpc3BhdGNoKG1lc3NhZ2UpO1xuICB9XG4gIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLmlmcmFtZVByb3RvY29sLmNoYW5uZWxMaXN0ZW4obGlzdGVuZXIpO1xuICB9XG4gIGdldENvZGVTYW5kYm94VVJMKCkge1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRGaWxlcygpO1xuICAgIGNvbnN0IHBhcmFtRmlsZXMgPSBPYmplY3Qua2V5cyhmaWxlcykucmVkdWNlKChwcmV2LCBuZXh0KSA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIFtuZXh0LnJlcGxhY2UoXCIvXCIsIFwiXCIpXToge1xuICAgICAgICBjb250ZW50OiBmaWxlc1tuZXh0XS5jb2RlLFxuICAgICAgICBpc0JpbmFyeTogZmFsc2VcbiAgICAgIH1cbiAgICB9KSwge30pO1xuICAgIHJldHVybiBmZXRjaChcImh0dHBzOi8vY29kZXNhbmRib3guaW8vYXBpL3YxL3NhbmRib3hlcy9kZWZpbmU/anNvbj0xXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGZpbGVzOiBwYXJhbUZpbGVzIH0pLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfVxuICAgIH0pLnRoZW4oKHgpID0+IHguanNvbigpKS50aGVuKChyZXMpID0+ICh7XG4gICAgICBzYW5kYm94SWQ6IHJlcy5zYW5kYm94X2lkLFxuICAgICAgZWRpdG9yVXJsOiBgaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zLyR7cmVzLnNhbmRib3hfaWR9YCxcbiAgICAgIGVtYmVkVXJsOiBgaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9lbWJlZC8ke3Jlcy5zYW5kYm94X2lkfWBcbiAgICB9KSk7XG4gIH1cbiAgZ2V0RmlsZXMoKSB7XG4gICAgY29uc3QgeyBzYW5kYm94SW5mbyB9ID0gdGhpcztcbiAgICBpZiAoc2FuZGJveEluZm8uZmlsZXNbXCIvcGFja2FnZS5qc29uXCJdID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBhZGRQYWNrYWdlSlNPTklmTmVlZGVkKHNhbmRib3hJbmZvLmZpbGVzLCBzYW5kYm94SW5mby5kZXBlbmRlbmNpZXMsIHNhbmRib3hJbmZvLmRldkRlcGVuZGVuY2llcywgc2FuZGJveEluZm8uZW50cnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zYW5kYm94SW5mby5maWxlcztcbiAgfVxuICBpbml0aWFsaXplRWxlbWVudCgpIHtcbiAgICB0aGlzLmlmcmFtZS5zdHlsZS5ib3JkZXIgPSBcIjBcIjtcbiAgICB0aGlzLmlmcmFtZS5zdHlsZS53aWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aCB8fCBcIjEwMCVcIjtcbiAgICB0aGlzLmlmcmFtZS5zdHlsZS5oZWlnaHQgPSB0aGlzLm9wdGlvbnMuaGVpZ2h0IHx8IFwiMTAwJVwiO1xuICAgIHRoaXMuaWZyYW1lLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICBpZiAoIXRoaXMuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHaXZlbiBlbGVtZW50IGRvZXMgbm90IGhhdmUgYSBwYXJlbnQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5pZnJhbWUsIHRoaXMuZWxlbWVudCk7XG4gIH1cbn07XG5cbi8vIHNyYy90eXBlcy50c1xudmFyIFNhbmRwYWNrTG9nTGV2ZWw7XG4oZnVuY3Rpb24oU2FuZHBhY2tMb2dMZXZlbDIpIHtcbiAgU2FuZHBhY2tMb2dMZXZlbDJbU2FuZHBhY2tMb2dMZXZlbDJbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgU2FuZHBhY2tMb2dMZXZlbDJbU2FuZHBhY2tMb2dMZXZlbDJbXCJFcnJvclwiXSA9IDEwXSA9IFwiRXJyb3JcIjtcbiAgU2FuZHBhY2tMb2dMZXZlbDJbU2FuZHBhY2tMb2dMZXZlbDJbXCJXYXJuaW5nXCJdID0gMjBdID0gXCJXYXJuaW5nXCI7XG4gIFNhbmRwYWNrTG9nTGV2ZWwyW1NhbmRwYWNrTG9nTGV2ZWwyW1wiSW5mb1wiXSA9IDMwXSA9IFwiSW5mb1wiO1xuICBTYW5kcGFja0xvZ0xldmVsMltTYW5kcGFja0xvZ0xldmVsMltcIkRlYnVnXCJdID0gNDBdID0gXCJEZWJ1Z1wiO1xufSkoU2FuZHBhY2tMb2dMZXZlbCB8fCAoU2FuZHBhY2tMb2dMZXZlbCA9IHt9KSk7XG5cbmZ1bmN0aW9uIFByZXZpZXcoX2EpIHtcclxuICAgIHZhciB7IGNsYXNzTmFtZSwgZmlsZXMsIHByZXNldENvbmZpZywgc2hvdywgY2hpbGRyZW4sIHN0eWxlLCBmcmFtZWxlc3MsIGNvZGVDb25maWcgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjbGFzc05hbWVcIiwgXCJmaWxlc1wiLCBcInByZXNldENvbmZpZ1wiLCBcInNob3dcIiwgXCJjaGlsZHJlblwiLCBcInN0eWxlXCIsIFwiZnJhbWVsZXNzXCIsIFwiY29kZUNvbmZpZ1wiXSk7XHJcbiAgICBjb25zdCBraWRzID0gcHJlc2V0Q29uZmlnID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2FuZHBhY2tQcmV2aWV3LCB7IGZpbGVzOiBmaWxlcywgcHJlc2V0Q29uZmlnOiBwcmVzZXRDb25maWcgfSkpIDogKGNoaWxkcmVuKTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaC1wcmV2aWV3XCIgKyAoY2xhc3NOYW1lID8gXCIgXCIgKyBjbGFzc05hbWUgOiBcIlwiKSwgc3R5bGU6IHN0eWxlLCBcImRhdGEtY2gtdGhlbWVcIjogY29kZUNvbmZpZyA9PT0gbnVsbCB8fCBjb2RlQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2RlQ29uZmlnLnRoZW1lTmFtZSB9LCBmcmFtZWxlc3MgPyAoa2lkcykgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChNaW5pQnJvd3NlciwgT2JqZWN0LmFzc2lnbih7IGxvYWRVcmw6IHNob3cgfSwgcmVzdCwgeyBjaGlsZHJlbjoga2lkcyB9KSkpKSk7XHJcbn1cclxuZnVuY3Rpb24gU2FuZHBhY2tQcmV2aWV3KHsgZmlsZXMsIHByZXNldENvbmZpZywgfSkge1xyXG4gICAgY29uc3QgaWZyYW1lUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xyXG4gICAgY29uc3QgY2xpZW50UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjbGllbnRSZWYuY3VycmVudCA9IG5ldyBTYW5kcGFja0NsaWVudChpZnJhbWVSZWYuY3VycmVudCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmVzZXRDb25maWcpLCB7IGZpbGVzOiBtZXJnZUZpbGVzKHByZXNldENvbmZpZy5maWxlcywgZmlsZXMpIH0pLCB7XHJcbiAgICAgICAgICAgIHNob3dPcGVuSW5Db2RlU2FuZGJveDogZmFsc2UsXHJcbiAgICAgICAgICAgIC8vIHNob3dFcnJvclNjcmVlbjogZmFsc2UsXHJcbiAgICAgICAgICAgIC8vIHNob3dMb2FkaW5nU2NyZWVuOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgIH0sIFtdKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGNsaWVudFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGNsaWVudFJlZi5jdXJyZW50LnVwZGF0ZVByZXZpZXcoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmVzZXRDb25maWcpLCB7IGZpbGVzOiBtZXJnZUZpbGVzKHByZXNldENvbmZpZy5maWxlcywgZmlsZXMpIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbZmlsZXNdKTtcclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIsIHsgcmVmOiBpZnJhbWVSZWYgfSk7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VGaWxlcyhjc2JGaWxlcywgY2hGaWxlcykge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgY3NiRmlsZXMpO1xyXG4gICAgY2hGaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xyXG4gICAgICAgIHJlc3VsdFtcIi9cIiArIGZpbGUubmFtZV0gPSB7XHJcbiAgICAgICAgICAgIGNvZGU6IGZpbGUuY29kZS5saW5lc1xyXG4gICAgICAgICAgICAgICAgLm1hcChsID0+IGwudG9rZW5zLm1hcCh0ID0+IHQuY29udGVudCkuam9pbihcIlwiKSlcclxuICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpLFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFByZXZpZXdTdGVwcyhjaGlsZHJlbiwgaGFzUHJldmlld1N0ZXBzKSB7XHJcbiAgICBjb25zdCBhbGxDaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xyXG4gICAgY29uc3Qgc3RlcHNDaGlsZHJlbiA9IGhhc1ByZXZpZXdTdGVwc1xyXG4gICAgICAgID8gYWxsQ2hpbGRyZW4uc2xpY2UoMCwgYWxsQ2hpbGRyZW4ubGVuZ3RoIC8gMilcclxuICAgICAgICA6IGFsbENoaWxkcmVuO1xyXG4gICAgY29uc3QgcHJldmlld0NoaWxkcmVuID0gaGFzUHJldmlld1N0ZXBzXHJcbiAgICAgICAgPyBhbGxDaGlsZHJlbi5zbGljZShhbGxDaGlsZHJlbi5sZW5ndGggLyAyKVxyXG4gICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgcmV0dXJuIHsgc3RlcHNDaGlsZHJlbiwgcHJldmlld0NoaWxkcmVuIH07XHJcbn1cblxuZnVuY3Rpb24gU3BvdGxpZ2h0KF9hKSB7XHJcbiAgICB2YXIgX2I7XHJcbiAgICB2YXIgeyBjaGlsZHJlbiwgZWRpdG9yU3RlcHMsIGNvZGVDb25maWcsIHN0YXJ0ID0gMCwgcHJlc2V0Q29uZmlnLCBjbGFzc05hbWUsIHN0eWxlLCBoYXNQcmV2aWV3U3RlcHMgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImVkaXRvclN0ZXBzXCIsIFwiY29kZUNvbmZpZ1wiLCBcInN0YXJ0XCIsIFwicHJlc2V0Q29uZmlnXCIsIFwiY2xhc3NOYW1lXCIsIFwic3R5bGVcIiwgXCJoYXNQcmV2aWV3U3RlcHNcIl0pO1xyXG4gICAgY29uc3QgeyBzdGVwc0NoaWxkcmVuLCBwcmV2aWV3Q2hpbGRyZW4gfSA9IGV4dHJhY3RQcmV2aWV3U3RlcHMoY2hpbGRyZW4sIGhhc1ByZXZpZXdTdGVwcyk7XHJcbiAgICBjb25zdCB3aXRoUHJldmlldyA9IHByZXNldENvbmZpZyB8fCBoYXNQcmV2aWV3U3RlcHM7XHJcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcclxuICAgICAgICBzdGVwSW5kZXg6IHN0YXJ0LFxyXG4gICAgICAgIHN0ZXA6IGVkaXRvclN0ZXBzW3N0YXJ0XSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgdGFiID0gc3RhdGUuc3RlcDtcclxuICAgIGZ1bmN0aW9uIG9uVGFiQ2xpY2soZmlsZW5hbWUpIHtcclxuICAgICAgICBjb25zdCBuZXdTdGVwID0gdXBkYXRlRWRpdG9yU3RlcChzdGF0ZS5zdGVwLCBmaWxlbmFtZSwgbnVsbCk7XHJcbiAgICAgICAgc2V0U3RhdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgc3RlcDogbmV3U3RlcCB9KSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBoZWFkZXJFbGVtZW50ID0gc3RlcHNDaGlsZHJlblswXTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgeyBjbGFzc05hbWU6IGBjaC1zcG90bGlnaHQgJHt3aXRoUHJldmlldyA/IFwiY2gtc3BvdGxpZ2h0LXdpdGgtcHJldmlld1wiIDogXCJcIn0gJHtjbGFzc05hbWUgfHwgXCJcIn1gLCBzdHlsZTogc3R5bGUsIFwiZGF0YS1jaC10aGVtZVwiOiBjb2RlQ29uZmlnLnRoZW1lTmFtZSB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY2gtc3BvdGxpZ2h0LXRhYnNcIiB9LFxyXG4gICAgICAgICAgICAoKF9iID0gaGVhZGVyRWxlbWVudCA9PT0gbnVsbCB8fCBoZWFkZXJFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoZWFkZXJFbGVtZW50LnByb3BzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hpbGRyZW4pID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgc3RlcHNDaGlsZHJlblswXSkpIDogbnVsbCxcclxuICAgICAgICAgICAgc3RlcHNDaGlsZHJlbi5tYXAoKGNoaWxkcmVuLCBpKSA9PiBpID09PSAwID8gbnVsbCA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBpLCBvbkNsaWNrOiAoKSA9PiBzZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcEluZGV4OiBpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IGVkaXRvclN0ZXBzW2ldLFxyXG4gICAgICAgICAgICAgICAgfSksIGNsYXNzTmFtZTogXCJjaC1zcG90bGlnaHQtdGFiXCIsIFwiZGF0YS1zZWxlY3RlZFwiOiBpID09PSBzdGF0ZS5zdGVwSW5kZXggPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9LCBjaGlsZHJlbikpKSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaC1zcG90bGlnaHQtc3RpY2tlclwiIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5uZXJDb2RlLCBPYmplY3QuYXNzaWduKHt9LCByZXN0LCB0YWIsIHsgY29kZUNvbmZpZzogY29kZUNvbmZpZywgb25UYWJDbGljazogb25UYWJDbGljayB9KSksXHJcbiAgICAgICAgICAgIHByZXNldENvbmZpZyA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFByZXZpZXcsIHsgY2xhc3NOYW1lOiBcImNoLXNwb3RsaWdodC1wcmV2aWV3XCIsIGZpbGVzOiB0YWIuZmlsZXMsIHByZXNldENvbmZpZzogcHJlc2V0Q29uZmlnIH0pKSA6IGhhc1ByZXZpZXdTdGVwcyA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFByZXZpZXcsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6IFwiY2gtc3BvdGxpZ2h0LXByZXZpZXdcIiB9LCBwcmV2aWV3Q2hpbGRyZW5bc3RhdGUuc3RlcEluZGV4XVtcInByb3BzXCJdKSkpIDogbnVsbCkpKTtcclxufVxuXG5mdW5jdGlvbiBkZWJ1Z0VudHJpZXMoZW50cmllcykge1xyXG4gICAgZW50cmllcy5mb3JFYWNoKHNob3dFbnRyeSk7XHJcbn1cclxuZnVuY3Rpb24gc2hvd0VudHJ5KGVudHJ5KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCByb290SGVpZ2h0ID0gKChfYSA9IGVudHJ5LnJvb3RCb3VuZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWlnaHQpIHx8IDA7XHJcbiAgICBhZGRGbGFzaGluZ1JlY3QoZW50cnkucm9vdEJvdW5kcywge1xyXG4gICAgICAgIGJvcmRlcjogYCR7TWF0aC5taW4oMTAsIHJvb3RIZWlnaHQgLyAyKX1weCBzb2xpZCAke2lvZE9wdGlvbnMucm9vdENvbG9yfWAsXHJcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXHJcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcclxuICAgIH0pO1xyXG4gICAgYWRkRmxhc2hpbmdSZWN0KGVudHJ5LmJvdW5kaW5nQ2xpZW50UmVjdCwge1xyXG4gICAgICAgIGJvcmRlcjogYCR7TWF0aC5taW4oMTAsIGVudHJ5LmJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQgLyAyKX1weCBzb2xpZCAke2VudHJ5LmlzSW50ZXJzZWN0aW5nXHJcbiAgICAgICAgICAgID8gaW9kT3B0aW9ucy5lbnRlckNvbG9yXHJcbiAgICAgICAgICAgIDogaW9kT3B0aW9ucy5leGl0Q29sb3J9YCxcclxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcclxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxyXG4gICAgfSk7XHJcbiAgICBhZGRGbGFzaGluZ1JlY3QoZW50cnkuaW50ZXJzZWN0aW9uUmVjdCwge1xyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaW9kT3B0aW9ucy5pbnRlckNvbG9yLFxyXG4gICAgICAgIHpJbmRleDogMixcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGFkZEZsYXNoaW5nUmVjdChib3VuZHMsIHN0eWxlID0ge30pIHtcclxuICAgIGNvbnN0IHsgd2lkdGgsIGxlZnQsIGhlaWdodCwgdG9wIH0gPSBib3VuZHM7XHJcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xyXG4gICAgZGl2LnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XHJcbiAgICBkaXYuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XHJcbiAgICBkaXYuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xyXG4gICAgZGl2LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcclxuICAgIGRpdi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XHJcbiAgICBkaXYuc3R5bGUudHJhbnNpdGlvbiA9IFwib3BhY2l0eSAycyBlYXNlLWluXCI7XHJcbiAgICBPYmplY3QuYXNzaWduKGRpdi5zdHlsZSwgc3R5bGUpO1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgZGl2LnN0eWxlLm9wYWNpdHkgPSBcIjBcIjtcclxuICAgIH0pKTtcclxuICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCAoKSA9PiB7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xyXG4gICAgfSk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XHJcbiAgICByZXR1cm4gZGl2O1xyXG59XHJcbmNvbnN0IGlvZE9wdGlvbnMgPSB7XHJcbiAgICByb290Q29sb3I6IFwiIzk0MjhBQlwiLFxyXG4gICAgZW50ZXJDb2xvcjogXCIjQjM1QzAwXCIsXHJcbiAgICBleGl0Q29sb3I6IFwiIzAzNTU3MFwiLFxyXG4gICAgaW50ZXJDb2xvcjogXCIjOUNBRjAwQkJcIixcclxufTtcblxuY29uc3QgdXNlTGF5b3V0RWZmZWN0JDEgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiXHJcbiAgICA/IFJlYWN0LnVzZUxheW91dEVmZmVjdFxyXG4gICAgOiBSZWFjdC51c2VFZmZlY3Q7XHJcbmZ1bmN0aW9uIHVzZVdpbmRvd0hlaWdodCgpIHtcclxuICAgIGNvbnN0IGlzQ2xpZW50ID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIjtcclxuICAgIGZ1bmN0aW9uIGdldEhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gaXNDbGllbnRcclxuICAgICAgICAgICAgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgW3dpbmRvd0hlaWdodCwgc2V0V2luZG93SGVpZ2h0XSA9IFJlYWN0LnVzZVN0YXRlKGdldEhlaWdodCk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSgpIHtcclxuICAgICAgICAgICAgc2V0V2luZG93SGVpZ2h0KGdldEhlaWdodCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlUmVzaXplKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlUmVzaXplKTtcclxuICAgIH0sIFtdKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCQxKCgpID0+IHtcclxuICAgICAgICAvLyBGSVggd2hlbiBhIGhvcml6b250YWwgc2Nyb2xsYmFyIGlzIGFkZGVkIGFmdGVyIHRoZSBmaXJzdCBsYXlvdXRcclxuICAgICAgICBzZXRXaW5kb3dIZWlnaHQoZ2V0SGVpZ2h0KCkpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgcmV0dXJuIHdpbmRvd0hlaWdodDtcclxufVxuXG5jb25zdCBPYnNlcnZlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XHJcbmNvbnN0IHVzZUxheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcclxuICAgID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0XHJcbiAgICA6IFJlYWN0LnVzZUVmZmVjdDtcclxuZnVuY3Rpb24gU2Nyb2xsZXIoeyBvblN0ZXBDaGFuZ2UsIGNoaWxkcmVuLCBnZXRSb290TWFyZ2luID0gZGVmYXVsdFJvb3RNYXJnaW4sIHRyaWdnZXJQb3NpdGlvbiwgZGVidWcgPSBmYWxzZSwgfSkge1xyXG4gICAgY29uc3QgW29ic2VydmVyLCBzZXRPYnNlcnZlcl0gPSBSZWFjdC51c2VTdGF0ZSgpO1xyXG4gICAgY29uc3QgdmggPSB1c2VXaW5kb3dIZWlnaHQoKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gdmggfHwgMDtcclxuICAgICAgICBjb25zdCBoYW5kbGVJbnRlcnNlY3QgPSBlbnRyaWVzID0+IHtcclxuICAgICAgICAgICAgaWYgKGRlYnVnIHx8IHdpbmRvdy5jaERlYnVnU2Nyb2xsZXIpIHtcclxuICAgICAgICAgICAgICAgIGRlYnVnRW50cmllcyhlbnRyaWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBFbGVtZW50ID0gZW50cnkudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIG9uU3RlcENoYW5nZSgrc3RlcEVsZW1lbnQuc3RlcEluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ld0ludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZUludGVyc2VjdCwgZ2V0Um9vdE1hcmdpbih3aW5kb3dIZWlnaHQsIHRyaWdnZXJQb3NpdGlvbikpO1xyXG4gICAgICAgIHNldE9ic2VydmVyKG9ic2VydmVyKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgfSwgW3ZoXSk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoT2JzZXJ2ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBvYnNlcnZlciB9LCBjaGlsZHJlbikpO1xyXG59XHJcbmZ1bmN0aW9uIFN0ZXAoX2EpIHtcclxuICAgIHZhciB7IGFzID0gXCJzZWN0aW9uXCIsIGluZGV4IH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImFzXCIsIFwiaW5kZXhcIl0pO1xyXG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xyXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBSZWFjdC51c2VDb250ZXh0KE9ic2VydmVyQ29udGV4dCk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHJlZi5jdXJyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IG9ic2VydmVyICYmIG9ic2VydmVyLnVub2JzZXJ2ZShyZWYuY3VycmVudCk7XHJcbiAgICB9LCBbb2JzZXJ2ZXJdKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3RlcEVsZW1lbnQgPSByZWYuY3VycmVudDtcclxuICAgICAgICBzdGVwRWxlbWVudC5zdGVwSW5kZXggPSBpbmRleDtcclxuICAgIH0sIFtpbmRleF0pO1xyXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoYXMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7IHJlZiB9KSk7XHJcbn1cclxuZnVuY3Rpb24gbmV3SW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlSW50ZXJzZWN0LCByb290TWFyZ2luKSB7XHJcbiAgICByZXR1cm4gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZUludGVyc2VjdCwge1xyXG4gICAgICAgIHJvb3RNYXJnaW4sXHJcbiAgICAgICAgdGhyZXNob2xkOiAwLjAwMDAwMSxcclxuICAgICAgICByb290OiBudWxsLFxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZGVmYXVsdFJvb3RNYXJnaW4odmgsIHRyaWdnZXJQb3NpdGlvbiA9IFwiNTAlXCIpIHtcclxuICAgIGxldCB5ID0gdmggKiAwLjU7XHJcbiAgICBpZiAodHJpZ2dlclBvc2l0aW9uLmVuZHNXaXRoKFwiJVwiKSkge1xyXG4gICAgICAgIGNvbnN0IHBlcmNlbnQgPSBwYXJzZUZsb2F0KHRyaWdnZXJQb3NpdGlvbi5yZXBsYWNlKFwiJVwiLCBcIlwiKSk7XHJcbiAgICAgICAgeSA9IHZoICogKHBlcmNlbnQgLyAxMDApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJpZ2dlclBvc2l0aW9uLmVuZHNXaXRoKFwicHhcIikpIHtcclxuICAgICAgICB5ID0gcGFyc2VGbG9hdCh0cmlnZ2VyUG9zaXRpb24ucmVwbGFjZShcInB4XCIsIFwiXCIpKTtcclxuICAgIH1cclxuICAgIGlmICh5IDwgMCkge1xyXG4gICAgICAgIHkgPSB2aCArIHk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYC0ke3kgLSAyfXB4IDBweCAtJHt2aCAtIHkgLSAyfXB4YDtcclxufVxuXG4vLyBzZXJ2ZXItc2lkZS1tZWRpYS1xdWVyaWVzLWZvci1yZWFjdFxyXG5sZXQgc3VmZml4Q291bnRlciA9IDA7XHJcbi8qKlxyXG4gKiBAdHlwZWRlZiBTd2FwUHJvcHNcclxuICogQHByb3Age1tzdHJpbmcsIEpTWC5FbGVtZW50XVtdfSBtYXRjaFxyXG4gKi9cclxuLyoqXHJcbiAqIFN3YXAgYmV0d2VlbiBkaWZmZXJlbnQgY29tcG9uZW50cyBkZXBlbmRpbmcgb24gdGhlIG1lZGlhIHF1ZXJpZXNcclxuICogQHBhcmFtIHtTd2FwUHJvcHN9IHByb3BzXHJcbiAqL1xyXG5mdW5jdGlvbiBTd2FwKHsgbWF0Y2ggfSkge1xyXG4gICAgY29uc3QgcXVlcmllcyA9IG1hdGNoLm1hcCgoW3FdKSA9PiBxKTtcclxuICAgIGNvbnN0IHsgaXNTZXJ2ZXIsIG1hdGNoZWRJbmRleCB9ID0gdXNlTWVkaWEocXVlcmllcyk7XHJcbiAgICBjb25zdCBtYWluQ2xhc3NOYW1lID0gaXNTZXJ2ZXJcclxuICAgICAgICA/IFwic3NtcS1cIiArIHN1ZmZpeENvdW50ZXIrK1xyXG4gICAgICAgIDogXCJcIjtcclxuICAgIHJldHVybiBpc1NlcnZlciA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7IGNsYXNzTmFtZTogbWFpbkNsYXNzTmFtZSwgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcclxuICAgICAgICAgICAgICAgIF9faHRtbDogZ2V0U3R5bGUocXVlcmllcywgbWFpbkNsYXNzTmFtZSksXHJcbiAgICAgICAgICAgIH0gfSksXHJcbiAgICAgICAgbWF0Y2gubWFwKChbcXVlcnksIGVsZW1lbnRdKSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogcXVlcnksIGNsYXNzTmFtZTogYCR7bWFpbkNsYXNzTmFtZX0gJHtnZXRDbGFzc05hbWUocXVlcnkpfWAgfSwgZWxlbWVudCkpKSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIHsgY2xhc3NOYW1lOiBtYWluQ2xhc3NOYW1lLCBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xyXG4gICAgICAgICAgICAgICAgX19odG1sOiBnZXRTY3JpcHQobWF0Y2gsIG1haW5DbGFzc05hbWUpLFxyXG4gICAgICAgICAgICB9IH0pKSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIG1hdGNoW21hdGNoZWRJbmRleF1bMV0pKSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U3R5bGUocXVlcmllcywgbWFpbkNsYXNzKSB7XHJcbiAgICBjb25zdCByZXZlcnNlZFF1ZXJpZXMgPSBxdWVyaWVzLnNsaWNlKCkucmV2ZXJzZSgpO1xyXG4gICAgY29uc3Qgc3R5bGUgPSByZXZlcnNlZFF1ZXJpZXNcclxuICAgICAgICAubWFwKHF1ZXJ5ID0+IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50U3R5bGUgPSBgLiR7bWFpbkNsYXNzfS4ke2dldENsYXNzTmFtZShxdWVyeSl9e2Rpc3BsYXk6YmxvY2t9YDtcclxuICAgICAgICBjb25zdCBvdGhlclN0eWxlID0gYC4ke21haW5DbGFzc306bm90KC4ke2dldENsYXNzTmFtZShxdWVyeSl9KXtkaXNwbGF5OiBub25lO31gO1xyXG4gICAgICAgIGlmIChxdWVyeSA9PT0gXCJkZWZhdWx0XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAke2N1cnJlbnRTdHlsZX0ke290aGVyU3R5bGV9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgQG1lZGlhICR7cXVlcnl9eyR7Y3VycmVudFN0eWxlfSR7b3RoZXJTdHlsZX19YDtcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG4gICAgICAgIC5qb2luKFwiXFxuXCIpO1xyXG4gICAgcmV0dXJuIHN0eWxlO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNjcmlwdChtYXRjaCwgbWFpbkNsYXNzKSB7XHJcbiAgICBjb25zdCBxdWVyaWVzID0gbWF0Y2gubWFwKChbcXVlcnldKSA9PiBxdWVyeSk7XHJcbiAgICBjb25zdCBjbGFzc2VzID0gcXVlcmllcy5tYXAoZ2V0Q2xhc3NOYW1lKTtcclxuICAgIHJldHVybiBgKGZ1bmN0aW9uKCkge1xuICB2YXIgcXMgPSAke0pTT04uc3RyaW5naWZ5KHF1ZXJpZXMpfTtcbiAgdmFyIGNsc3MgPSAke0pTT04uc3RyaW5naWZ5KGNsYXNzZXMpfTtcbiAgdmFyIG1haW5DbHMgPSBcIiR7bWFpbkNsYXNzfVwiO1xuXG4gIHZhciBzY3JFbHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcbiAgdmFyIHNjckVsID0gc2NyRWxzW3NjckVscy5sZW5ndGggLSAxXTtcbiAgdmFyIHBhcmVudCA9IHNjckVsLnBhcmVudE5vZGU7XG5cbiAgdmFyIGVsID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEocXNbaV0pLm1hdGNoZXMpIHtcbiAgICAgIGVsID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoXCI6c2NvcGUgPiAuXCIgKyBtYWluQ2xzICsgXCIuXCIgKyBjbHNzW2ldKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoIWVsKSB7XG4gICAgdmFyIGRlZmF1bHRDbGFzcyA9IGNsc3MucG9wKCk7XG4gICAgZWwgPSBwYXJlbnQucXVlcnlTZWxlY3RvcihcIjpzY29wZSA+IC5cIiArIG1haW5DbHMgKyBcIi5cIiArIGRlZmF1bHRDbGFzcyk7XG4gIH1cbiAgZWwucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG5cbiAgcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6c2NvcGUgPiAuXCIgKyBtYWluQ2xzKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKGUpO1xuICB9KTtcbn0pKCk7YDtcclxufVxyXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gKFwic3NtcS1cIiArXHJcbiAgICAgICAgc3RyaW5nXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bIVxcXCIjJCUmJ1xcKFxcKVxcKlxcKyxcXC5cXC86Ozw9PlxcP1xcQFxcW1xcXFxcXF1cXF5gXFx7XFx8XFx9flxcc10vZywgXCJcIilcclxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCkpO1xyXG59XHJcbmZ1bmN0aW9uIHVzZU1lZGlhKHF1ZXJpZXMpIHtcclxuICAgIGNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIjtcclxuICAgIGNvbnN0IGFsbFF1ZXJpZXMgPSBxdWVyaWVzLnNsaWNlKDAsIC0xKTtcclxuICAgIGlmIChxdWVyaWVzW3F1ZXJpZXMubGVuZ3RoIC0gMV0gIT09IFwiZGVmYXVsdFwiKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwibGFzdCBtZWRpYSBxdWVyeSBzaG91bGQgYmUgJ2RlZmF1bHQnXCIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgWywgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBtZWRpYVF1ZXJ5TGlzdHMgPSBpc1NlcnZlclxyXG4gICAgICAgID8gW11cclxuICAgICAgICA6IGFsbFF1ZXJpZXMubWFwKHEgPT4gd2luZG93Lm1hdGNoTWVkaWEocSkpO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4gc2V0VmFsdWUoeCA9PiB4ICsgMSk7XHJcbiAgICAgICAgbWVkaWFRdWVyeUxpc3RzLmZvckVhY2gobXFsID0+IG1xbC5hZGRMaXN0ZW5lcihoYW5kbGVyKSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IG1lZGlhUXVlcnlMaXN0cy5mb3JFYWNoKG1xbCA9PiBtcWwucmVtb3ZlTGlzdGVuZXIoaGFuZGxlcikpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3QgbWF0Y2hlZEluZGV4ID0gbWVkaWFRdWVyeUxpc3RzLmZpbmRJbmRleChtcWwgPT4gbXFsLm1hdGNoZXMpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc1NlcnZlcixcclxuICAgICAgICBtYXRjaGVkSW5kZXg6IG1hdGNoZWRJbmRleCA8IDAgPyBxdWVyaWVzLmxlbmd0aCAtIDEgOiBtYXRjaGVkSW5kZXgsXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIENvZGVTbG90KCkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoU3RhdGljU3RlcENvbnRleHQpO1xyXG4gICAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJbm5lckNvZGVTbG90LCBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KSk7XHJcbn1cclxuZnVuY3Rpb24gSW5uZXJDb2RlU2xvdCh7IGVkaXRvclN0ZXAsIHNldEZvY3VzIH0pIHtcclxuICAgIGNvbnN0IG9uVGFiQ2xpY2sgPSAoZmlsZW5hbWUpID0+IHtcclxuICAgICAgICBzZXRGb2N1cyh7IGZpbGVOYW1lOiBmaWxlbmFtZSwgZm9jdXM6IG51bGwsIGlkOiBcIlwiIH0pO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb3BzID0gX19yZXN0KGVkaXRvclN0ZXAsIFtcInByZXNldFwiLCBcInByZXNldENvbmZpZ1wiXSk7XHJcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJbm5lckNvZGUsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IG9uVGFiQ2xpY2s6IG9uVGFiQ2xpY2sgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIFByZXZpZXdTbG90KCkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoU3RhdGljU3RlcENvbnRleHQpO1xyXG4gICAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJbm5lclByZXZpZXdTbG90LCBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KSk7XHJcbn1cclxuZnVuY3Rpb24gSW5uZXJQcmV2aWV3U2xvdCh7IHByZXZpZXdTdGVwLCBhbGxQcm9wcywgZWRpdG9yU3RlcCwgfSkge1xyXG4gICAgY29uc3QgcHJvcHMgPSBfX3Jlc3QoYWxsUHJvcHMsIFtcInByZXNldFwiXSk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJldmlldywgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogXCJjaC1zY3JvbGx5Y29kaW5nLXByZXZpZXdcIiB9LCBwcm9wcywgcHJldmlld1N0ZXAgPT09IG51bGwgfHwgcHJldmlld1N0ZXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZpZXdTdGVwLnByb3BzLCB7IGZpbGVzOiBlZGl0b3JTdGVwLmZpbGVzIH0pKSk7XHJcbn1cclxuY29uc3QgU3RhdGljU3RlcENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG5mdW5jdGlvbiBTY3JvbGx5Y29kaW5nKHByb3BzKSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3dhcCwgeyBtYXRjaDogW1xyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBwcm9wcy5jb2RlQ29uZmlnLnN0YXRpY01lZGlhUXVlcnksXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFN0YXRpY1Njcm9sbHljb2RpbmcsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSksXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFtcImRlZmF1bHRcIiwgUmVhY3QuY3JlYXRlRWxlbWVudChEeW5hbWljU2Nyb2xseWNvZGluZywgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKV0sXHJcbiAgICAgICAgXSB9KSk7XHJcbn1cclxuZnVuY3Rpb24gU3RhdGljU2Nyb2xseWNvZGluZyhfYSkge1xyXG4gICAgdmFyIF9iO1xyXG4gICAgdmFyIHsgY2hpbGRyZW4sIGhhc1ByZXZpZXdTdGVwcywgZWRpdG9yU3RlcHMgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImhhc1ByZXZpZXdTdGVwc1wiLCBcImVkaXRvclN0ZXBzXCJdKTtcclxuICAgIGNvbnN0IHsgc3RlcHNDaGlsZHJlbiwgcHJldmlld0NoaWxkcmVuIH0gPSBleHRyYWN0UHJldmlld1N0ZXBzKGNoaWxkcmVuLCBoYXNQcmV2aWV3U3RlcHMpO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCB7IGNsYXNzTmFtZTogXCJjaC1zY3JvbGx5Y29kaW5nLXN0YXRpY1wiLCBcImRhdGEtY2gtdGhlbWVcIjogKF9iID0gcmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0LmNvZGVDb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50aGVtZU5hbWUgfSwgc3RlcHNDaGlsZHJlbi5tYXAoKGNoaWxkcmVuLCBpKSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChTdGF0aWNTZWN0aW9uLCB7IGtleTogaSwgZWRpdG9yU3RlcDogZWRpdG9yU3RlcHNbaV0sIHByZXZpZXdTdGVwOiBwcmV2aWV3Q2hpbGRyZW4gJiYgcHJldmlld0NoaWxkcmVuW2ldLCBhbGxQcm9wczogcmVzdCB9LCBjaGlsZHJlbikpKSkpO1xyXG59XHJcbmZ1bmN0aW9uIFN0YXRpY1NlY3Rpb24oeyBlZGl0b3JTdGVwLCBwcmV2aWV3U3RlcCwgYWxsUHJvcHMsIGNoaWxkcmVuLCB9KSB7XHJcbiAgICBjb25zdCBbc3RlcCwgc2V0U3RlcF0gPSBSZWFjdC51c2VTdGF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVkaXRvclN0ZXApLCBhbGxQcm9wcykpO1xyXG4gICAgY29uc3QgcmVzZXRGb2N1cyA9ICgpID0+IHNldFN0ZXAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlZGl0b3JTdGVwKSwgYWxsUHJvcHMpKTtcclxuICAgIGNvbnN0IHNldEZvY3VzID0gKHsgZmlsZU5hbWUsIGZvY3VzLCBpZCwgfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5ld1N0ZXAgPSB1cGRhdGVFZGl0b3JTdGVwKHN0ZXAsIGZpbGVOYW1lLCBmb2N1cyk7XHJcbiAgICAgICAgc2V0U3RlcChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RlcCksIG5ld1N0ZXApLCB7IHNlbGVjdGVkSWQ6IGlkIH0pKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RhdGljU3RlcENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHtcclxuICAgICAgICAgICAgZWRpdG9yU3RlcDogc3RlcCxcclxuICAgICAgICAgICAgcHJldmlld1N0ZXA6IHByZXZpZXdTdGVwLFxyXG4gICAgICAgICAgICBhbGxQcm9wcyxcclxuICAgICAgICAgICAgc2V0Rm9jdXMsXHJcbiAgICAgICAgfSB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGlua2FibGVTZWN0aW9uLCB7IG9uQWN0aXZhdGlvbjogc2V0Rm9jdXMsIG9uUmVzZXQ6IHJlc2V0Rm9jdXMgfSwgY2hpbGRyZW4pKSk7XHJcbn1cclxuZnVuY3Rpb24gRHluYW1pY1Njcm9sbHljb2RpbmcoX2EpIHtcclxuICAgIHZhciB7IGNoaWxkcmVuLCBlZGl0b3JTdGVwcywgY29kZUNvbmZpZywgcHJlc2V0Q29uZmlnLCBzdGFydCA9IDAsIGNsYXNzTmFtZSwgc3R5bGUsIGhhc1ByZXZpZXdTdGVwcyB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiZWRpdG9yU3RlcHNcIiwgXCJjb2RlQ29uZmlnXCIsIFwicHJlc2V0Q29uZmlnXCIsIFwic3RhcnRcIiwgXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcImhhc1ByZXZpZXdTdGVwc1wiXSk7XHJcbiAgICBjb25zdCB7IHN0ZXBzQ2hpbGRyZW4sIHByZXZpZXdDaGlsZHJlbiB9ID0gZXh0cmFjdFByZXZpZXdTdGVwcyhjaGlsZHJlbiwgaGFzUHJldmlld1N0ZXBzKTtcclxuICAgIGNvbnN0IHdpdGhQcmV2aWV3ID0gcHJlc2V0Q29uZmlnIHx8IGhhc1ByZXZpZXdTdGVwcztcclxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xyXG4gICAgICAgIHN0ZXBJbmRleDogc3RhcnQsXHJcbiAgICAgICAgc3RlcDogZWRpdG9yU3RlcHNbc3RhcnRdLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB0YWIgPSBzdGF0ZS5zdGVwO1xyXG4gICAgZnVuY3Rpb24gb25TdGVwQ2hhbmdlKGluZGV4KSB7XHJcbiAgICAgICAgc2V0U3RhdGUoeyBzdGVwSW5kZXg6IGluZGV4LCBzdGVwOiBlZGl0b3JTdGVwc1tpbmRleF0gfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBvblRhYkNsaWNrKGZpbGVuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U3RlcCA9IHVwZGF0ZUVkaXRvclN0ZXAoc3RhdGUuc3RlcCwgZmlsZW5hbWUsIG51bGwpO1xyXG4gICAgICAgIHNldFN0YXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7IHN0ZXA6IG5ld1N0ZXAgfSkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb25MaW5rQWN0aXZhdGlvbihzdGVwSW5kZXgsIGZpbGVuYW1lLCBmb2N1cykge1xyXG4gICAgICAgIGNvbnN0IG5ld1N0ZXAgPSB1cGRhdGVFZGl0b3JTdGVwKGVkaXRvclN0ZXBzW3N0ZXBJbmRleF0sIGZpbGVuYW1lLCBmb2N1cyk7XHJcbiAgICAgICAgc2V0U3RhdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgc3RlcEluZGV4LCBzdGVwOiBuZXdTdGVwIH0pKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgeyBjbGFzc05hbWU6IGBjaC1zY3JvbGx5Y29kaW5nICR7d2l0aFByZXZpZXcgPyBcImNoLXNjcm9sbHljb2Rpbmctd2l0aC1wcmV2aWV3XCIgOiBcIlwifSAke2NsYXNzTmFtZSB8fCBcIlwifWAsIHN0eWxlOiBzdHlsZSwgXCJkYXRhLWNoLXRoZW1lXCI6IGNvZGVDb25maWcgPT09IG51bGwgfHwgY29kZUNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29kZUNvbmZpZy50aGVtZU5hbWUgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLXNjcm9sbHljb2RpbmctY29udGVudFwiIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2Nyb2xsZXIsIHsgb25TdGVwQ2hhbmdlOiBvblN0ZXBDaGFuZ2UsIHRyaWdnZXJQb3NpdGlvbjogY29kZUNvbmZpZyA9PT0gbnVsbCB8fCBjb2RlQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2RlQ29uZmlnLnRyaWdnZXJQb3NpdGlvbiB9LCBzdGVwc0NoaWxkcmVuLm1hcCgoY2hpbGRyZW4sIGkpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFN0ZXAsIHsgYXM6IFwiZGl2XCIsIGtleTogaSwgaW5kZXg6IGksIG9uQ2xpY2s6ICgpID0+IG9uU3RlcENoYW5nZShpKSwgY2xhc3NOYW1lOiBcImNoLXNjcm9sbHljb2Rpbmctc3RlcC1jb250ZW50XCIsIFwiZGF0YS1zZWxlY3RlZFwiOiBpID09PSBzdGF0ZS5zdGVwSW5kZXggPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rYWJsZVNlY3Rpb24sIHsgb25BY3RpdmF0aW9uOiAoeyBmaWxlTmFtZSwgZm9jdXMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkxpbmtBY3RpdmF0aW9uKGksIGZpbGVOYW1lLCBmb2N1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgb25SZXNldDogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblN0ZXBDaGFuZ2UoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSB9LCBjaGlsZHJlbikpKSkpKSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLXNjcm9sbHljb2Rpbmctc3RpY2tlclwiIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5uZXJDb2RlLCBPYmplY3QuYXNzaWduKHsgc2hvd0V4cGFuZEJ1dHRvbjogdHJ1ZSB9LCByZXN0LCB0YWIsIHsgY29kZUNvbmZpZzogY29kZUNvbmZpZywgb25UYWJDbGljazogb25UYWJDbGljayB9KSksXHJcbiAgICAgICAgICAgIHByZXNldENvbmZpZyA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFByZXZpZXcsIHsgY2xhc3NOYW1lOiBcImNoLXNjcm9sbHljb2RpbmctcHJldmlld1wiLCBmaWxlczogdGFiLmZpbGVzLCBwcmVzZXRDb25maWc6IHByZXNldENvbmZpZyB9KSkgOiBoYXNQcmV2aWV3U3RlcHMgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChQcmV2aWV3LCBPYmplY3QuYXNzaWduKHsgY2xhc3NOYW1lOiBcImNoLXNjcm9sbHljb2RpbmctcHJldmlld1wiIH0sIHByZXZpZXdDaGlsZHJlbltzdGF0ZS5zdGVwSW5kZXhdW1wicHJvcHNcIl0pKSkgOiBudWxsKSkpO1xyXG59XG5cbmZ1bmN0aW9uIFNsaWRlc2hvdyhfYSkge1xyXG4gICAgdmFyIHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgY29kZSwgY29kZUNvbmZpZywgZWRpdG9yU3RlcHMsIGF1dG9Gb2N1cywgaGFzUHJldmlld1N0ZXBzLCBcclxuICAgIC8vIFNldCB0aGUgaW5pdGlhbCBzbGlkZSBpbmRleFxyXG4gICAgc3RhcnQgPSAwLCBcclxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBzbGlkZXNob3cgc3RhdGUgY2hhbmdlcyBhbmQgcmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZSBvYmplY3RcclxuICAgIG9uQ2hhbmdlOiBvblNsaWRlc2hvd0NoYW5nZSA9ICgpID0+IHsgfSwgcHJlc2V0Q29uZmlnLCBzdHlsZSwgYXV0b1BsYXksIGxvb3AgPSBmYWxzZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29kZVwiLCBcImNvZGVDb25maWdcIiwgXCJlZGl0b3JTdGVwc1wiLCBcImF1dG9Gb2N1c1wiLCBcImhhc1ByZXZpZXdTdGVwc1wiLCBcInN0YXJ0XCIsIFwib25DaGFuZ2VcIiwgXCJwcmVzZXRDb25maWdcIiwgXCJzdHlsZVwiLCBcImF1dG9QbGF5XCIsIFwibG9vcFwiXSk7XHJcbiAgICBjb25zdCB7IHN0ZXBzQ2hpbGRyZW4sIHByZXZpZXdDaGlsZHJlbiB9ID0gZXh0cmFjdFByZXZpZXdTdGVwcyhjaGlsZHJlbiwgaGFzUHJldmlld1N0ZXBzKTtcclxuICAgIGNvbnN0IHdpdGhQcmV2aWV3ID0gcHJlc2V0Q29uZmlnIHx8IGhhc1ByZXZpZXdTdGVwcztcclxuICAgIGNvbnN0IGhhc05vdGVzID0gc3RlcHNDaGlsZHJlbi5zb21lKChjaGlsZCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBjaGlsZC5wcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoaWxkcmVuOyB9KTtcclxuICAgIGNvbnN0IG1heFN0ZXBzID0gZWRpdG9yU3RlcHMubGVuZ3RoIC0gMTtcclxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBjbGFtcCQyKHN0YXJ0LCAwLCBtYXhTdGVwcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RlcEluZGV4OiBzdGFydEluZGV4LFxyXG4gICAgICAgICAgICBzdGVwOiBlZGl0b3JTdGVwc1tzdGFydEluZGV4XSxcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7IHN0ZXBJbmRleDogY3VycmVudEluZGV4LCBzdGVwOiB0YWIgfSA9IHN0YXRlO1xyXG4gICAgY29uc3QgYXRTbGlkZXNob3dFbmQgPSBjdXJyZW50SW5kZXggPT09IG1heFN0ZXBzO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBvblNsaWRlc2hvd0NoYW5nZSh7IGluZGV4OiBjdXJyZW50SW5kZXggfSk7XHJcbiAgICB9LCBbY3VycmVudEluZGV4XSk7XHJcbiAgICBmdW5jdGlvbiBvblRhYkNsaWNrKGZpbGVuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U3RlcCA9IHVwZGF0ZUVkaXRvclN0ZXAodGFiLCBmaWxlbmFtZSwgbnVsbCk7XHJcbiAgICAgICAgc2V0U3RhdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgc3RlcDogbmV3U3RlcCB9KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRJbmRleChuZXdJbmRleCkge1xyXG4gICAgICAgIGNvbnN0IHN0ZXBJbmRleCA9IGNsYW1wJDIobmV3SW5kZXgsIDAsIG1heFN0ZXBzKTtcclxuICAgICAgICBzZXRTdGF0ZSh7IHN0ZXBJbmRleCwgc3RlcDogZWRpdG9yU3RlcHNbc3RlcEluZGV4XSB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG5leHRTbGlkZSgpIHtcclxuICAgICAgICBzZXRTdGF0ZShzID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc3RlcEluZGV4ID0gbG9vcFxyXG4gICAgICAgICAgICAgICAgPyAocy5zdGVwSW5kZXggKyAxKSAlIChtYXhTdGVwcyArIDEpXHJcbiAgICAgICAgICAgICAgICA6IGNsYW1wJDIocy5zdGVwSW5kZXggKyAxLCAwLCBtYXhTdGVwcyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdGVwSW5kZXgsXHJcbiAgICAgICAgICAgICAgICBzdGVwOiBlZGl0b3JTdGVwc1tzdGVwSW5kZXhdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXNlSW50ZXJ2YWwobmV4dFNsaWRlLCBhdXRvUGxheSk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGBjaC1zbGlkZXNob3cgJHt3aXRoUHJldmlldyA/IFwiY2gtc2xpZGVzaG93LXdpdGgtcHJldmlld1wiIDogXCJcIn0gJHtjbGFzc05hbWUgfHwgXCJcIn1gLCBzdHlsZTogc3R5bGUsIFwiZGF0YS1jaC10aGVtZVwiOiBjb2RlQ29uZmlnLnRoZW1lTmFtZSB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY2gtc2xpZGVzaG93LXNsaWRlXCIgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChJbm5lckNvZGUsIE9iamVjdC5hc3NpZ24oe30sIHJlc3QsIHRhYiwgeyBjb2RlQ29uZmlnOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvZGVDb25maWcpLCBjb2RlKSwgb25UYWJDbGljazogb25UYWJDbGljayB9KSksXHJcbiAgICAgICAgICAgIHByZXNldENvbmZpZyA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFByZXZpZXcsIHsgY2xhc3NOYW1lOiBcImNoLXNsaWRlc2hvdy1wcmV2aWV3XCIsIGZpbGVzOiB0YWIuZmlsZXMsIHByZXNldENvbmZpZzogcHJlc2V0Q29uZmlnIH0pKSA6IGhhc1ByZXZpZXdTdGVwcyA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFByZXZpZXcsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6IFwiY2gtc2xpZGVzaG93LXByZXZpZXdcIiB9LCBwcmV2aWV3Q2hpbGRyZW5bY3VycmVudEluZGV4XVtcInByb3BzXCJdKSkpIDogbnVsbCksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJjaC1zbGlkZXNob3ctbm90ZXNcIiB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLXNsaWRlc2hvdy1yYW5nZVwiIH0sXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgb25DbGljazogKCkgPT4gc2V0SW5kZXgoY3VycmVudEluZGV4IC0gMSksIGRpc2FibGVkOiBjdXJyZW50SW5kZXggPT09IDAgfSwgXCJQcmV2XCIpLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHsgbWF4OiBtYXhTdGVwcywgbWluOiAwLCBzdGVwOiAxLCB0eXBlOiBcInJhbmdlXCIsIHZhbHVlOiBjdXJyZW50SW5kZXgsIG9uQ2hhbmdlOiBlID0+IHNldEluZGV4KCtlLnRhcmdldC52YWx1ZSksIHJlZjogdXNlQXV0b0ZvY3VzUmVmKGF1dG9Gb2N1cyksIGF1dG9Gb2N1czogYXV0b0ZvY3VzIH0pLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IG9uQ2xpY2s6IG5leHRTbGlkZSwgZGlzYWJsZWQ6IGF0U2xpZGVzaG93RW5kIH0sIFwiTmV4dFwiKSksXHJcbiAgICAgICAgICAgIGhhc05vdGVzICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLXNsaWRlc2hvdy1ub3RlXCIgfSwgc3RlcHNDaGlsZHJlbltjdXJyZW50SW5kZXhdKSkpKSk7XHJcbn1cclxuZnVuY3Rpb24gdXNlQXV0b0ZvY3VzUmVmKGF1dG9Gb2N1cykge1xyXG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBhdXRvRm9jdXMgJiYgcmVmLmN1cnJlbnQuZm9jdXMoKTtcclxuICAgIH0sIFtdKTtcclxuICAgIHJldHVybiByZWY7XHJcbn1cblxuZnVuY3Rpb24gQW5ub3RhdGlvbigpIHtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcIlxcXCJlcnJvcjogY29kZSBoaWtlIHJlbWFyayBwbHVnaW4gbm90IHJ1bm5pbmcgb3IgYW5ub3RhdGlvbiBpc24ndCBhdCB0aGUgcmlnaHQgcGxhY2VcXFwiXCIpKTtcclxufVxyXG5jb25zdCBhbm5vdGF0aW9uc01hcCA9IHtcclxuICAgIGJveDogQm94LFxyXG4gICAgYmc6IE11bHRpbGluZU1hcmssXHJcbiAgICBsYWJlbDogTGFiZWwsXHJcbiAgICBsaW5rOiBDb2RlTGluayxcclxuICAgIG1hcms6IE1hcmssXHJcbiAgICB3aXRoQ2xhc3M6IFdpdGhDbGFzcyxcclxufTtcclxuZnVuY3Rpb24gTWFyayhwcm9wcykge1xyXG4gICAgaWYgKHByb3BzLmlzSW5saW5lKSB7XHJcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5saW5lTWFyaywgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE11bHRpbGluZU1hcmssIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gTXVsdGlsaW5lTWFyayh7IGNoaWxkcmVuLCBkYXRhLCBzdHlsZSwgbGluZXMsIH0pIHtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBnZXRDb250ZW50KGxpbmVzKTtcclxuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGBjaC1jb2RlLW11bHRpbGluZS1tYXJrIGAgKyAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB2b2lkIDAgPyBkYXRhIDogXCJcIik7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogc3R5bGUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwiY2gtY29kZS1tdWx0aWxpbmUtbWFyay1ib3JkZXJcIiB9KSxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENvcHlCdXR0b24sIHsgY2xhc3NOYW1lOiBcImNoLWNvZGUtYnV0dG9uXCIsIGNvbnRlbnQ6IGNvbnRlbnQgfSkpKTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb250ZW50KGxpbmVzKSB7XHJcbiAgICByZXR1cm4gbGluZXNcclxuICAgICAgICAubWFwKGwgPT4gbC5hbm5vdGF0ZWRHcm91cHNcclxuICAgICAgICAuZmxhdE1hcChhZyA9PiB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSBhZy5wcmV2KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ3JvdXBzLmZsYXRNYXAodGcgPT4gdGcudG9rZW5zLm1hcCh0ID0+IHQuY29udGVudCkpO1xyXG4gICAgfSlcclxuICAgICAgICAuam9pbihcIlwiKSlcclxuICAgICAgICAuam9pbihcIlxcblwiKTtcclxufVxyXG5mdW5jdGlvbiBJbmxpbmVNYXJrKHsgY2hpbGRyZW4sIGRhdGEgfSkge1xyXG4gICAgY29uc3QgY2xhc3NOYW1lID0gXCJjaC1jb2RlLWlubGluZS1tYXJrIFwiICsgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdm9pZCAwID8gZGF0YSA6IFwiXCIpO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lLCBzdHlsZToge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB0cnlHdWVzc0NvbG9yKGNoaWxkcmVuKSB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgfSB9LCBjaGlsZHJlbikpO1xyXG59XHJcbmZ1bmN0aW9uIHRyeUd1ZXNzQ29sb3IoY2hpbGRyZW4pIHtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pWzBdO1xyXG4gICAgICAgIGNvbnN0IGdyYW5kQ2hpbGQgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KCgoX2EgPSBjaGlsZCA9PT0gbnVsbCB8fCBjaGlsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGQucHJvcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGlsZHJlbikgfHwgW10pWzBdO1xyXG4gICAgICAgIGNvbnN0IGdyYW5kR3JhbmRDaGlsZCA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoKChfYiA9IGdyYW5kQ2hpbGQgPT09IG51bGwgfHwgZ3JhbmRDaGlsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JhbmRDaGlsZC5wcm9wcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNoaWxkcmVuKSB8fCBbXSlbMF07XHJcbiAgICAgICAgY29uc3QgeyBjb2xvciB9ID0gKChfYyA9IGdyYW5kR3JhbmRDaGlsZCA9PT0gbnVsbCB8fCBncmFuZEdyYW5kQ2hpbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyYW5kR3JhbmRDaGlsZC5wcm9wcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0eWxlKSB8fCB7fTtcclxuICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zcGFyZW50KGNvbG9yLCAwLjIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIEJveCh7IGNoaWxkcmVuLCBkYXRhIH0pIHtcclxuICAgIGNvbnN0IG91dGxpbmVDb2xvciA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gZGF0YSA6IHVuZGVmaW5lZDtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwiY2gtY29kZS1ib3gtYW5ub3RhdGlvblwiLCBzdHlsZTogeyBvdXRsaW5lQ29sb3IgfSB9LCBjaGlsZHJlbikpO1xyXG59XHJcbmZ1bmN0aW9uIFdpdGhDbGFzcyh7IGNoaWxkcmVuLCBkYXRhLCBzdHlsZSwgfSkge1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IHN0eWxlOiBzdHlsZSwgY2xhc3NOYW1lOiBkYXRhIH0sIGNoaWxkcmVuKSk7XHJcbn1cclxuZnVuY3Rpb24gTGFiZWwoeyBjaGlsZHJlbiwgZGF0YSwgc3R5bGUgfSkge1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLWNvZGUtbGFiZWwtYW5ub3RhdGlvblwiLCBzdHlsZTogc3R5bGUgfSxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImNoLWNvZGUtbGFiZWwtYW5ub3RhdGlvbi10ZXh0XCIgfSwgKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jaGlsZHJlbikgfHwgZGF0YSkpKTtcclxufVxyXG5mdW5jdGlvbiBDb2RlTGluayh7IGNoaWxkcmVuLCBpc0lubGluZSwgc3R5bGUsIGRhdGEsIH0pIHtcclxuICAgIGNvbnN0IHVybCA9IChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudXJsKSB8fCBkYXRhO1xyXG4gICAgY29uc3QgdGl0bGUgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudGl0bGU7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgaHJlZjogdXJsLCB0aXRsZTogdGl0bGUsIGNsYXNzTmFtZTogaXNJbmxpbmUgPyBcImNoLWNvZGUtaW5saW5lLWxpbmtcIiA6IFwiY2gtY29kZS1saW5rXCIsIHN0eWxlOiBzdHlsZSB9LCBjaGlsZHJlbikpO1xyXG59XG5cbmZ1bmN0aW9uIElubGluZUNvZGUoX2EpIHtcclxuICAgIHZhciB7IGNsYXNzTmFtZSwgY29kZUNvbmZpZywgY2hpbGRyZW4sIGNvZGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjbGFzc05hbWVcIiwgXCJjb2RlQ29uZmlnXCIsIFwiY2hpbGRyZW5cIiwgXCJjb2RlXCJdKTtcclxuICAgIGNvbnN0IHsgbGluZXMgfSA9IGNvZGU7XHJcbiAgICBjb25zdCBhbGxUb2tlbnMgPSBsaW5lcy5mbGF0TWFwKGxpbmUgPT4gbGluZS50b2tlbnMpO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBPYmplY3QuYXNzaWduKHsgXCJkYXRhLWNoLXRoZW1lXCI6IGNvZGVDb25maWcudGhlbWVOYW1lLCBjbGFzc05hbWU6IFwiY2gtaW5saW5lLWNvZGUgbm90LXByb3NlXCIgK1xyXG4gICAgICAgICAgICAoY2xhc3NOYW1lID8gXCIgXCIgKyBjbGFzc05hbWUgOiBcIlwiKSB9LCByZXN0KSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCBudWxsLCBhbGxUb2tlbnMubWFwKCh0b2tlbiwgaikgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIE9iamVjdC5hc3NpZ24oeyBrZXk6IGogfSwgdG9rZW4ucHJvcHMpLCB0b2tlbi5jb250ZW50KSkpKSkpO1xyXG59XG5cbmNvbnN0IENIID0ge1xyXG4gICAgQ29kZSxcclxuICAgIFNlY3Rpb24sXHJcbiAgICBTZWN0aW9uTGluayxcclxuICAgIFNlY3Rpb25Db2RlLFxyXG4gICAgU3BvdGxpZ2h0LFxyXG4gICAgU2Nyb2xseWNvZGluZyxcclxuICAgIFByZXZpZXcsXHJcbiAgICBhbm5vdGF0aW9uczogYW5ub3RhdGlvbnNNYXAsXHJcbiAgICBBbm5vdGF0aW9uLFxyXG4gICAgU2xpZGVzaG93LFxyXG4gICAgSW5saW5lQ29kZSxcclxuICAgIENvZGVTbG90LFxyXG4gICAgUHJldmlld1Nsb3QsXHJcbn07XHJcbmNvbnN0IGludGVybmFsID0ge1xyXG4gICAgTWluaUJyb3dzZXIsXHJcbiAgICBFZGl0b3JTcHJpbmcsXHJcbn07XG5cbmV4cG9ydCB7IEFubm90YXRpb24sIENILCBDb2RlLCBDb2RlU2xvdCwgSW5saW5lQ29kZSwgUHJldmlldywgUHJldmlld1Nsb3QsIFNjcm9sbHljb2RpbmcsIFNlY3Rpb24sIFNlY3Rpb25Db2RlLCBTZWN0aW9uTGluaywgU2xpZGVzaG93LCBTcG90bGlnaHQsIGFubm90YXRpb25zTWFwIGFzIGFubm90YXRpb25zLCBpbnRlcm5hbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@code-hike/mdx/dist/components.esm.mjs\n"));

/***/ }),

/***/ "./node_modules/@mdx-js/react/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@mdx-js/react/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MDXContext\": function() { return /* reexport safe */ _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.MDXContext; },\n/* harmony export */   \"MDXProvider\": function() { return /* reexport safe */ _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.MDXProvider; },\n/* harmony export */   \"useMDXComponents\": function() { return /* reexport safe */ _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.useMDXComponents; },\n/* harmony export */   \"withMDXComponents\": function() { return /* reexport safe */ _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.withMDXComponents; }\n/* harmony export */ });\n/* harmony import */ var _lib_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/index.js */ \"./node_modules/@mdx-js/react/lib/index.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1keC1qcy9yZWFjdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUt1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG1keC1qcy9yZWFjdC9pbmRleC5qcz9mODkzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7XG4gIE1EWENvbnRleHQsXG4gIE1EWFByb3ZpZGVyLFxuICB1c2VNRFhDb21wb25lbnRzLFxuICB3aXRoTURYQ29tcG9uZW50c1xufSBmcm9tICcuL2xpYi9pbmRleC5qcydcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@mdx-js/react/index.js\n"));

/***/ }),

/***/ "./node_modules/@mdx-js/react/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@mdx-js/react/lib/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MDXContext\": function() { return /* binding */ MDXContext; },\n/* harmony export */   \"MDXProvider\": function() { return /* binding */ MDXProvider; },\n/* harmony export */   \"useMDXComponents\": function() { return /* binding */ useMDXComponents; },\n/* harmony export */   \"withMDXComponents\": function() { return /* binding */ withMDXComponents; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('mdx/types.js').MDXComponents} Components\n *\n * @typedef Props\n *   Configuration.\n * @property {Components | MergeComponents | null | undefined} [components]\n *   Mapping of names for JSX components to React components.\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context.\n * @property {ReactNode | null | undefined} [children]\n *   Children.\n *\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Components} currentComponents\n *   Current components from the context.\n * @returns {Components}\n *   Merged components.\n */\n\n\n\n/**\n * @type {import('react').Context<Components>}\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means its no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components and\n *   `MDXProvider` to set context based components instead.\n */\nconst MDXContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({})\n\n/**\n * @param {import('react').ComponentType<any>} Component\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means its no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components instead.\n */\nfunction withMDXComponents(Component) {\n  return boundMDXComponent\n\n  /**\n   * @param {Record<string, unknown> & {components?: Components | null | undefined}} props\n   * @returns {JSX.Element}\n   */\n  function boundMDXComponent(props) {\n    const allComponents = useMDXComponents(props.components)\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {...props, allComponents})\n  }\n}\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Components | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that takes the current\n *   components and filters/merges/changes them.\n * @returns {Components}\n *   Current components.\n */\nfunction useMDXComponents(components) {\n  const contextComponents = react__WEBPACK_IMPORTED_MODULE_0__.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    // Custom merge via a function prop\n    if (typeof components === 'function') {\n      return components(contextComponents)\n    }\n\n    return {...contextComponents, ...components}\n  }, [contextComponents, components])\n}\n\n/** @type {Components} */\nconst emptyObject = {}\n\n/**\n * Provider for MDX context\n *\n * @param {Props} props\n * @returns {JSX.Element}\n */\nfunction MDXProvider({components, children, disableParentContext}) {\n  /** @type {Components} */\n  let allComponents\n\n  if (disableParentContext) {\n    allComponents =\n      typeof components === 'function'\n        ? components({})\n        : components || emptyObject\n  } else {\n    allComponents = useMDXComponents(components)\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    children\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1keC1qcy9yZWFjdC9saWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDLGFBQWEsc0NBQXNDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaURBQWlEO0FBQy9EO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUV5Qjs7QUFFekI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQixnREFBbUIsR0FBRzs7QUFFaEQ7QUFDQSxXQUFXLG9DQUFvQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxhQUFhLDJCQUEyQiw2Q0FBNkM7QUFDckYsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQW1CLGFBQWEsd0JBQXdCO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpREFBaUQ7QUFDNUQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUCw0QkFBNEIsNkNBQWdCOztBQUU1QztBQUNBLFNBQVMsMENBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaLEdBQUc7QUFDSDs7QUFFQSxXQUFXLFlBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNPLHNCQUFzQiwyQ0FBMkM7QUFDeEUsYUFBYSxZQUFZO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLFNBQVMsZ0RBQW1CO0FBQzVCO0FBQ0EsS0FBSyxxQkFBcUI7QUFDMUI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbWR4LWpzL3JlYWN0L2xpYi9pbmRleC5qcz9mZGRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgncmVhY3QnKS5SZWFjdE5vZGV9IFJlYWN0Tm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWR4L3R5cGVzLmpzJykuTURYQ29tcG9uZW50c30gQ29tcG9uZW50c1xuICpcbiAqIEB0eXBlZGVmIFByb3BzXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkge0NvbXBvbmVudHMgfCBNZXJnZUNvbXBvbmVudHMgfCBudWxsIHwgdW5kZWZpbmVkfSBbY29tcG9uZW50c11cbiAqICAgTWFwcGluZyBvZiBuYW1lcyBmb3IgSlNYIGNvbXBvbmVudHMgdG8gUmVhY3QgY29tcG9uZW50cy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtkaXNhYmxlUGFyZW50Q29udGV4dD1mYWxzZV1cbiAqICAgVHVybiBvZmYgb3V0ZXIgY29tcG9uZW50IGNvbnRleHQuXG4gKiBAcHJvcGVydHkge1JlYWN0Tm9kZSB8IG51bGwgfCB1bmRlZmluZWR9IFtjaGlsZHJlbl1cbiAqICAgQ2hpbGRyZW4uXG4gKlxuICogQGNhbGxiYWNrIE1lcmdlQ29tcG9uZW50c1xuICogICBDdXN0b20gbWVyZ2UgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0NvbXBvbmVudHN9IGN1cnJlbnRDb21wb25lbnRzXG4gKiAgIEN1cnJlbnQgY29tcG9uZW50cyBmcm9tIHRoZSBjb250ZXh0LlxuICogQHJldHVybnMge0NvbXBvbmVudHN9XG4gKiAgIE1lcmdlZCBjb21wb25lbnRzLlxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCdyZWFjdCcpLkNvbnRleHQ8Q29tcG9uZW50cz59XG4gKiBAZGVwcmVjYXRlZFxuICogICBUaGlzIGV4cG9ydCBpcyBtYXJrZWQgYXMgYSBsZWdhY3kgZmVhdHVyZS5cbiAqICAgVGhhdCBtZWFucyBpdOKAmXMgbm8gbG9uZ2VyIHJlY29tbWVuZGVkIGZvciB1c2UgYXMgaXQgbWlnaHQgYmUgcmVtb3ZlZFxuICogICBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLlxuICpcbiAqICAgUGxlYXNlIHVzZSBgdXNlTURYQ29tcG9uZW50c2AgdG8gZ2V0IGNvbnRleHQgYmFzZWQgY29tcG9uZW50cyBhbmRcbiAqICAgYE1EWFByb3ZpZGVyYCB0byBzZXQgY29udGV4dCBiYXNlZCBjb21wb25lbnRzIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBNRFhDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSlcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgncmVhY3QnKS5Db21wb25lbnRUeXBlPGFueT59IENvbXBvbmVudFxuICogQGRlcHJlY2F0ZWRcbiAqICAgVGhpcyBleHBvcnQgaXMgbWFya2VkIGFzIGEgbGVnYWN5IGZlYXR1cmUuXG4gKiAgIFRoYXQgbWVhbnMgaXTigJlzIG5vIGxvbmdlciByZWNvbW1lbmRlZCBmb3IgdXNlIGFzIGl0IG1pZ2h0IGJlIHJlbW92ZWRcbiAqICAgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS5cbiAqXG4gKiAgIFBsZWFzZSB1c2UgYHVzZU1EWENvbXBvbmVudHNgIHRvIGdldCBjb250ZXh0IGJhc2VkIGNvbXBvbmVudHMgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhNRFhDb21wb25lbnRzKENvbXBvbmVudCkge1xuICByZXR1cm4gYm91bmRNRFhDb21wb25lbnRcblxuICAvKipcbiAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiAmIHtjb21wb25lbnRzPzogQ29tcG9uZW50cyB8IG51bGwgfCB1bmRlZmluZWR9fSBwcm9wc1xuICAgKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9XG4gICAqL1xuICBmdW5jdGlvbiBib3VuZE1EWENvbXBvbmVudChwcm9wcykge1xuICAgIGNvbnN0IGFsbENvbXBvbmVudHMgPSB1c2VNRFhDb21wb25lbnRzKHByb3BzLmNvbXBvbmVudHMpXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7Li4ucHJvcHMsIGFsbENvbXBvbmVudHN9KVxuICB9XG59XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgY29tcG9uZW50cyBmcm9tIHRoZSBNRFggQ29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudHMgfCBNZXJnZUNvbXBvbmVudHMgfCBudWxsIHwgdW5kZWZpbmVkfSBbY29tcG9uZW50c11cbiAqICAgQWRkaXRpb25hbCBjb21wb25lbnRzIHRvIHVzZSBvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGN1cnJlbnRcbiAqICAgY29tcG9uZW50cyBhbmQgZmlsdGVycy9tZXJnZXMvY2hhbmdlcyB0aGVtLlxuICogQHJldHVybnMge0NvbXBvbmVudHN9XG4gKiAgIEN1cnJlbnQgY29tcG9uZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1EWENvbXBvbmVudHMoY29tcG9uZW50cykge1xuICBjb25zdCBjb250ZXh0Q29tcG9uZW50cyA9IFJlYWN0LnVzZUNvbnRleHQoTURYQ29udGV4dClcblxuICAvLyBNZW1vaXplIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHRvcC1sZXZlbCBjb250ZXh0IGNoYW5nZXNcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIC8vIEN1c3RvbSBtZXJnZSB2aWEgYSBmdW5jdGlvbiBwcm9wXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50cyhjb250ZXh0Q29tcG9uZW50cylcbiAgICB9XG5cbiAgICByZXR1cm4gey4uLmNvbnRleHRDb21wb25lbnRzLCAuLi5jb21wb25lbnRzfVxuICB9LCBbY29udGV4dENvbXBvbmVudHMsIGNvbXBvbmVudHNdKVxufVxuXG4vKiogQHR5cGUge0NvbXBvbmVudHN9ICovXG5jb25zdCBlbXB0eU9iamVjdCA9IHt9XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIE1EWCBjb250ZXh0XG4gKlxuICogQHBhcmFtIHtQcm9wc30gcHJvcHNcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1EWFByb3ZpZGVyKHtjb21wb25lbnRzLCBjaGlsZHJlbiwgZGlzYWJsZVBhcmVudENvbnRleHR9KSB7XG4gIC8qKiBAdHlwZSB7Q29tcG9uZW50c30gKi9cbiAgbGV0IGFsbENvbXBvbmVudHNcblxuICBpZiAoZGlzYWJsZVBhcmVudENvbnRleHQpIHtcbiAgICBhbGxDb21wb25lbnRzID1cbiAgICAgIHR5cGVvZiBjb21wb25lbnRzID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY29tcG9uZW50cyh7fSlcbiAgICAgICAgOiBjb21wb25lbnRzIHx8IGVtcHR5T2JqZWN0XG4gIH0gZWxzZSB7XG4gICAgYWxsQ29tcG9uZW50cyA9IHVzZU1EWENvbXBvbmVudHMoY29tcG9uZW50cylcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIE1EWENvbnRleHQuUHJvdmlkZXIsXG4gICAge3ZhbHVlOiBhbGxDb21wb25lbnRzfSxcbiAgICBjaGlsZHJlblxuICApXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@mdx-js/react/lib/index.js\n"));

/***/ }),

/***/ "./node_modules/next-mdx-remote/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/next-mdx-remote/dist/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MDXRemote\": function() { return /* binding */ MDXRemote; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _jsx_runtime_cjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jsx-runtime.cjs */ \"./node_modules/next-mdx-remote/dist/jsx-runtime.cjs\");\n/* harmony import */ var _mdx_js_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mdx-js/react */ \"./node_modules/@mdx-js/react/index.js\");\n\n\n\n\n/**\n * Copyright (c) HashiCorp, Inc.\n * SPDX-License-Identifier: MPL-2.0\n */\n\nif (typeof window !== 'undefined') {\n  window.requestIdleCallback =\n    window.requestIdleCallback ||\n    function (cb) {\n      var start = Date.now();\n      return setTimeout(function () {\n        cb({\n          didTimeout: false,\n          timeRemaining: function () {\n            return Math.max(0, 50 - (Date.now() - start))\n          },\n        });\n      }, 1)\n    };\n\n  window.cancelIdleCallback =\n    window.cancelIdleCallback ||\n    function (id) {\n      clearTimeout(id);\n    };\n}\n\n/**\n * Copyright (c) HashiCorp, Inc.\n * SPDX-License-Identifier: MPL-2.0\n */\n/**\n * Renders compiled source from next-mdx-remote/serialize.\n */\nfunction MDXRemote({ compiledSource, frontmatter, scope, components = {}, lazy, }) {\n    const [isReadyToRender, setIsReadyToRender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!lazy || typeof window === 'undefined');\n    // if we're on the client side and `lazy` is set to true, we hydrate the\n    // mdx content inside requestIdleCallback, allowing the page to get to\n    // interactive quicker, but the mdx content to hydrate slower.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (lazy) {\n            const handle = window.requestIdleCallback(() => {\n                setIsReadyToRender(true);\n            });\n            return () => window.cancelIdleCallback(handle);\n        }\n    }, []);\n    const Content = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        // if we're ready to render, we can assemble the component tree and let React do its thing\n        // first we set up the scope which has to include the mdx custom\n        // create element function as well as any components we're using\n        const fullScope = Object.assign({ opts: { ..._mdx_js_react__WEBPACK_IMPORTED_MODULE_2__, ..._jsx_runtime_cjs__WEBPACK_IMPORTED_MODULE_1__.jsxRuntime } }, { frontmatter }, scope);\n        const keys = Object.keys(fullScope);\n        const values = Object.values(fullScope);\n        // now we eval the source code using a function constructor\n        // in order for this to work we need to have React, the mdx createElement,\n        // and all our components in scope for the function, which is the case here\n        // we pass the names (via keys) in as the function's args, and execute the\n        // function with the actual values.\n        const hydrateFn = Reflect.construct(Function, keys.concat(`${compiledSource}`));\n        return hydrateFn.apply(hydrateFn, values).default;\n    }, [scope, compiledSource]);\n    if (!isReadyToRender) {\n        // If we're not ready to render, return an empty div to preserve SSR'd markup\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { dangerouslySetInnerHTML: { __html: '' }, suppressHydrationWarning: true }));\n    }\n    // wrapping the content with MDXProvider will allow us to customize the standard\n    // markdown components (such as \"h1\" or \"a\") with the \"components\" object\n    const content = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__.MDXProvider, { components: components },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Content, null)));\n    // If lazy = true, we need to render a wrapping div to preserve the same markup structure that was SSR'd\n    return lazy ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null, content) : content;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1tZHgtcmVtb3RlL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0RDtBQUNiO0FBQ1Y7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRCxTQUFTO0FBQ2pGLGtEQUFrRCwrQ0FBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDhDQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRLEdBQUcsMENBQUcsS0FBSyx3REFBVSxJQUFJLElBQUksYUFBYTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxlQUFlO0FBQ3BGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQW1CLFVBQVUsMkJBQTJCLFlBQVksa0NBQWtDO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnREFBbUIsQ0FBQyxzREFBZSxJQUFJLHdCQUF3QjtBQUNwRixRQUFRLGdEQUFtQjtBQUMzQjtBQUNBLGtCQUFrQixnREFBbUI7QUFDckM7O0FBRXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LW1keC1yZW1vdGUvZGlzdC9pbmRleC5qcz8yMzI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4UnVudGltZSB9IGZyb20gJy4vanN4LXJ1bnRpbWUuY2pzJztcbmltcG9ydCAqIGFzIG1keCBmcm9tICdAbWR4LWpzL3JlYWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1QTC0yLjBcbiAqL1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgPVxuICAgIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8XG4gICAgZnVuY3Rpb24gKGNiKSB7XG4gICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjYih7XG4gICAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBzdGFydCkpXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9LCAxKVxuICAgIH07XG5cbiAgd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayA9XG4gICAgd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayB8fFxuICAgIGZ1bmN0aW9uIChpZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgSGFzaGlDb3JwLCBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuICovXG4vKipcbiAqIFJlbmRlcnMgY29tcGlsZWQgc291cmNlIGZyb20gbmV4dC1tZHgtcmVtb3RlL3NlcmlhbGl6ZS5cbiAqL1xuZnVuY3Rpb24gTURYUmVtb3RlKHsgY29tcGlsZWRTb3VyY2UsIGZyb250bWF0dGVyLCBzY29wZSwgY29tcG9uZW50cyA9IHt9LCBsYXp5LCB9KSB7XG4gICAgY29uc3QgW2lzUmVhZHlUb1JlbmRlciwgc2V0SXNSZWFkeVRvUmVuZGVyXSA9IHVzZVN0YXRlKCFsYXp5IHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKTtcbiAgICAvLyBpZiB3ZSdyZSBvbiB0aGUgY2xpZW50IHNpZGUgYW5kIGBsYXp5YCBpcyBzZXQgdG8gdHJ1ZSwgd2UgaHlkcmF0ZSB0aGVcbiAgICAvLyBtZHggY29udGVudCBpbnNpZGUgcmVxdWVzdElkbGVDYWxsYmFjaywgYWxsb3dpbmcgdGhlIHBhZ2UgdG8gZ2V0IHRvXG4gICAgLy8gaW50ZXJhY3RpdmUgcXVpY2tlciwgYnV0IHRoZSBtZHggY29udGVudCB0byBoeWRyYXRlIHNsb3dlci5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobGF6eSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldElzUmVhZHlUb1JlbmRlcih0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2soaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBDb250ZW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIC8vIGlmIHdlJ3JlIHJlYWR5IHRvIHJlbmRlciwgd2UgY2FuIGFzc2VtYmxlIHRoZSBjb21wb25lbnQgdHJlZSBhbmQgbGV0IFJlYWN0IGRvIGl0cyB0aGluZ1xuICAgICAgICAvLyBmaXJzdCB3ZSBzZXQgdXAgdGhlIHNjb3BlIHdoaWNoIGhhcyB0byBpbmNsdWRlIHRoZSBtZHggY3VzdG9tXG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50IGZ1bmN0aW9uIGFzIHdlbGwgYXMgYW55IGNvbXBvbmVudHMgd2UncmUgdXNpbmdcbiAgICAgICAgY29uc3QgZnVsbFNjb3BlID0gT2JqZWN0LmFzc2lnbih7IG9wdHM6IHsgLi4ubWR4LCAuLi5qc3hSdW50aW1lIH0gfSwgeyBmcm9udG1hdHRlciB9LCBzY29wZSk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmdWxsU2NvcGUpO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGZ1bGxTY29wZSk7XG4gICAgICAgIC8vIG5vdyB3ZSBldmFsIHRoZSBzb3VyY2UgY29kZSB1c2luZyBhIGZ1bmN0aW9uIGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIGluIG9yZGVyIGZvciB0aGlzIHRvIHdvcmsgd2UgbmVlZCB0byBoYXZlIFJlYWN0LCB0aGUgbWR4IGNyZWF0ZUVsZW1lbnQsXG4gICAgICAgIC8vIGFuZCBhbGwgb3VyIGNvbXBvbmVudHMgaW4gc2NvcGUgZm9yIHRoZSBmdW5jdGlvbiwgd2hpY2ggaXMgdGhlIGNhc2UgaGVyZVxuICAgICAgICAvLyB3ZSBwYXNzIHRoZSBuYW1lcyAodmlhIGtleXMpIGluIGFzIHRoZSBmdW5jdGlvbidzIGFyZ3MsIGFuZCBleGVjdXRlIHRoZVxuICAgICAgICAvLyBmdW5jdGlvbiB3aXRoIHRoZSBhY3R1YWwgdmFsdWVzLlxuICAgICAgICBjb25zdCBoeWRyYXRlRm4gPSBSZWZsZWN0LmNvbnN0cnVjdChGdW5jdGlvbiwga2V5cy5jb25jYXQoYCR7Y29tcGlsZWRTb3VyY2V9YCkpO1xuICAgICAgICByZXR1cm4gaHlkcmF0ZUZuLmFwcGx5KGh5ZHJhdGVGbiwgdmFsdWVzKS5kZWZhdWx0O1xuICAgIH0sIFtzY29wZSwgY29tcGlsZWRTb3VyY2VdKTtcbiAgICBpZiAoIWlzUmVhZHlUb1JlbmRlcikge1xuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgcmVhZHkgdG8gcmVuZGVyLCByZXR1cm4gYW4gZW1wdHkgZGl2IHRvIHByZXNlcnZlIFNTUidkIG1hcmt1cFxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6ICcnIH0sIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSB9KSk7XG4gICAgfVxuICAgIC8vIHdyYXBwaW5nIHRoZSBjb250ZW50IHdpdGggTURYUHJvdmlkZXIgd2lsbCBhbGxvdyB1cyB0byBjdXN0b21pemUgdGhlIHN0YW5kYXJkXG4gICAgLy8gbWFya2Rvd24gY29tcG9uZW50cyAoc3VjaCBhcyBcImgxXCIgb3IgXCJhXCIpIHdpdGggdGhlIFwiY29tcG9uZW50c1wiIG9iamVjdFxuICAgIGNvbnN0IGNvbnRlbnQgPSAoUmVhY3QuY3JlYXRlRWxlbWVudChtZHguTURYUHJvdmlkZXIsIHsgY29tcG9uZW50czogY29tcG9uZW50cyB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRlbnQsIG51bGwpKSk7XG4gICAgLy8gSWYgbGF6eSA9IHRydWUsIHdlIG5lZWQgdG8gcmVuZGVyIGEgd3JhcHBpbmcgZGl2IHRvIHByZXNlcnZlIHRoZSBzYW1lIG1hcmt1cCBzdHJ1Y3R1cmUgdGhhdCB3YXMgU1NSJ2RcbiAgICByZXR1cm4gbGF6eSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgY29udGVudCkgOiBjb250ZW50O1xufVxuXG5leHBvcnQgeyBNRFhSZW1vdGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-mdx-remote/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/next-mdx-remote/index.js":
/*!***********************************************!*\
  !*** ./node_modules/next-mdx-remote/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"./node_modules/next-mdx-remote/dist/index.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _dist_index_js__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _dist_index_js__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/**\n * Copyright (c) HashiCorp, Inc.\n * SPDX-License-Identifier: MPL-2.0\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1tZHgtcmVtb3RlL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LW1keC1yZW1vdGUvaW5kZXguanM/NmU2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgSGFzaGlDb3JwLCBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuICovXG5cbmV4cG9ydCAqIGZyb20gJy4vZGlzdC9pbmRleC5qcydcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-mdx-remote/index.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fopt%2Fprojects%2Fblog%2Fpages%2Fsnippets%2Findex.tsx&page=%2Fsnippets!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);